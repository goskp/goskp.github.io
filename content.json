{"meta":{"title":"kpsun","subtitle":"","description":"","author":"kpsun","url":"http://goskp.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-07-14T04:24:56.000Z","updated":"2022-10-13T13:05:22.823Z","comments":true,"path":"about/index.html","permalink":"http://goskp.github.io/about/index.html","excerpt":"","text":"个人简介孙楷朋准大二计算机相关专业在读热爱编程,乐于合作,善于总结分享,有良好的的编程习惯目标BAT大厂联系方式 QQ: 1287923885 WeChat: code_cpp Email: &#107;&#x70;&#x73;&#117;&#x6e;&#64;&#x66;&#111;&#120;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;"},{"title":"category","date":"2022-08-14T04:20:49.000Z","updated":"2022-08-14T04:20:49.238Z","comments":true,"path":"category/index.html","permalink":"http://goskp.github.io/category/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构-平衡二叉树(AVLTree)","slug":"数据结构-平衡二叉树(AVLTree)","date":"2022-10-22T02:54:28.000Z","updated":"2022-10-22T03:35:35.524Z","comments":true,"path":"2022/10/22/数据结构-平衡二叉树(AVLTree)/","link":"","permalink":"http://goskp.github.io/2022/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVLTree)/","excerpt":"","text":"#include &lt;iostream&gt; using namespace std; const int g_NUM = 10; //平衡二叉树结点类型 template &lt;typename T&gt; class TreeNode &#123; public: TreeNode(const T&amp; data) &#123; this-&gt;data = data; p_left = p_right = nullptr; height = 0; &#125; protected: T data; //数据 TreeNode* p_left; //左孩子 TreeNode* p_right; //右孩子 int height; //高度 &#125;; template &lt;typename T&gt; class AVLTree &#123; public: AVLTree() &#123; p_root = nullptr; &#125; ~AVLTree() &#123;&#125; void InsertNode(const T&amp; data) &#123; _InsertNode(p_root, data); &#125; protected: TreeNode&lt;T&gt;* p_root; //指向根节点的指针 private: //插入结点 void _InsertNode(TreeNode&lt;T&gt;*&amp; p_root, const T&amp; data); //获取某个结点的高度 int _GetHeight(TreeNode&lt;T&gt;* p_root) const; //右旋 TreeNode&lt;T&gt;* RR(TreeNode&lt;T&gt;* p_root); //左旋 TreeNode&lt;T&gt;* LL(TreeNode&lt;T&gt;* p_root); //左右旋 TreeNode&lt;T&gt;* LR(TreeNode&lt;T&gt;* p_root); //右左旋 TreeNode&lt;T&gt;* RL(TreeNode&lt;T&gt;* p_root); &#125;; //右旋 template &lt;typename T&gt; TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::RR(TreeNode&lt;T&gt;* p_root) &#123;&#125; //左旋 template &lt;typename T&gt; TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::LL(TreeNode&lt;T&gt;* p_root) &#123;&#125; //左右旋 template &lt;typename T&gt; TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::LR(TreeNode&lt;T&gt;* p_root) &#123; //以p_root-&gt;p_left为轴左旋 p_root-&gt;p_left = LL(p_root-&gt;p_left); //以p_root为轴右旋 return RR(p_root); &#125; //右左旋 template &lt;typename T&gt; TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::RL(TreeNode&lt;T&gt;* p_root) &#123; //以p_root-&gt;p_right为轴右旋 &#125; template &lt;typename T&gt; int AVLTree&lt;T&gt;::_GetHeight(TreeNode&lt;T&gt;* p_root) const &#123; if (nullptr != p_root) &#123; return p_root-&gt;height; &#125; else &#123; return 0; &#125; &#125; template &lt;typename T&gt; void AVLTree&lt;T&gt;::_InsertNode(TreeNode&lt;T&gt;*&amp; p_root, const T&amp; data) &#123; //先用有序二叉树方式插入,判断当前是否为空 if (nullptr == p_root) &#123; p_root = new TreeNode&lt;T&gt;(data); &#125; else if (data &lt; p_root-&gt;data) &#123; //往左子树进行插入 _InsertNode(p_root-&gt;p_left, data); //判断是否平衡 if (_GetHeight(p_root-&gt;p_left) - _GetHeight(p_root-&gt;right) &gt; 1) &#123; //不平衡,需要旋转 //需要右旋 if (data &lt; p_root-&gt;p_left-&gt;data) &#123; p_root = RR(p_root); &#125; else if (data &gt; p_root-&gt;p_left-&gt;data) &#123; //需要左右旋 p_root = LR(p_root); &#125; &#125; &#125; else if (data &gt; p_root-&gt;data) &#123; //往右子树插入 _InsertNode(p_root-&gt;p_right, data); //判断是否平衡 if (_GetHeight(p_root-&gt;p_right) - _GetHeight(p_root-&gt;p_left) &gt; 1) &#123; //不平衡,需要旋转 //需要左旋 if (data &gt; p_root-&gt;p_right-&gt;data) &#123; p_root = LL(p_root); &#125; else if (data &lt; p_root-&gt;p_right-&gt;data) &#123; //需要右左旋 p_root = RL(p_root); &#125; &#125; &#125; &#125; int main(int argc, char** argv) &#123; int arr[g_NUM] = &#123;55, 99, 24, 66, 11, 10, 77, 13, 38, 91&#125;; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法-BF,KMP","slug":"算法-BF,KMP","date":"2022-10-20T14:53:20.000Z","updated":"2022-10-20T15:00:37.947Z","comments":true,"path":"2022/10/20/算法-BF,KMP/","link":"","permalink":"http://goskp.github.io/2022/10/20/%E7%AE%97%E6%B3%95-BF,KMP/","excerpt":"","text":"在数据结构 “串”这篇已经写过了.放这里单纯是因为属于算法篇BF算法: 从父串中找字串,并返回字串的第一个元素位置 父串下标: i , 字串下标: j 从字串的第一个元素开始遍历,并与父串进行匹配 如果不匹配 将字串下标 j 归为0, 字串再从第一个元素与父串进行匹配,并将临时记录序号+1 如果字串的最后一个元素为’\\0’,证明找完了, 返回index + 1 验证的最好方法,代数即可 int BruteForce(LPSTR p_str_one, LPSTR p_str_two) &#123; int index = 0; //临时记录序号,用来返回找到的位置 int i = 0; int j = 0; while (p_str_one-&gt;memory[i] != &#39;\\0&#39; &amp;&amp; p_str_two-&gt;memory[j] != &#39;\\0&#39;) &#123; if (p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; //不匹配, 重新从第一个 ++index; i = index; j = 0; //换第二个位置又从父串第一个位置开始比 &#125; &#125; if (p_str_two-&gt;memory[j] == &#39;\\0&#39;) &#123; return ++index; &#125; return -1; &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str1 = CreateStr(&quot;abcabcacb&quot;); LPSTR p_str2 = CreateStr(&quot;abcac&quot;); printf(&quot;从第%d个元素开始匹配&quot;, BruteForce(p_str1, p_str2)); return 0; &#125; KMP算法: 基本概念: 字符串的”前缀”和”后缀” “前缀”指除了最后一个字符外,一个字符串的全部头部组合; “后缀”指除了第一个字符以外,一个字符串的全部尾组合. 以ABCDABD为例 前缀: A AB ABC ABCD ABCDA ABCDAB 后缀: BCDABD CDABD DABD ABD BD D 部分匹配表 每一个字串里去找前缀和后缀中相同的元素的长度 “A”的前缀和后缀都为空集，共有元素的长度为0； “AB”的前缀为[A]，后缀为[B]， 共有元素的长度为0； “ABC”的前缀为[A, AB]，后缀为[BC, C]， 共有元素的长度0； “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]， 共有元素的长度为0； “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]， 共有元素为”AB”，长度为2； “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]， 共有元素的长度为0。 生成部分匹配表 //获取匹配值 void GetNext(LPSTR p_str, int next[]) &#123; int len = p_str-&gt;cur_size; //用的是数组下标 int i = 0; int j = -1; // 0在这里表示共同元素为0, 有具体的含义,所以初始化为-1了 next[0] = -1; while (i &lt; len) &#123; if (j == -1 || p_str-&gt;memory[i] == p_str-&gt;memory[j]) &#123; ++i; ++j; next[i] = j; //部分匹配元素的长度 &#125; else &#123; j = next[j]; //重置j为-1 &#125; &#125; &#125; int KMP(LPSTR p_str_one, LPSTR p_str_two, int next[]) &#123; //第一个得到表 GetNext(p_str_two, next); int i = 0; int j = 0; while (i &lt; p_str_one-&gt;cur_size &amp;&amp; j &lt; p_str_two-&gt;cur_size) &#123; if (j == -1 || p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if (j == p_str_two-&gt;cur_size) &#123; return i - j; &#125; return -1; &#125; //测试数据 int main(int argc, char** argv) &#123; LPSTR p_str = CreateStr(&quot;ABCDABD&quot;); int next[8]; GetNext(p_str, next); for (int i = 0; i &lt; 8; ++i) &#123; printf(&quot;%d\\t&quot;, next[i]); &#125; putchar(&#39;\\n&#39;); LPSTR p_str_one = CreateStr(&quot;BBC ABCDAB ABCDABCDABDE&quot;); LPSTR p_str_two = CreateStr(&quot;ABCDABD&quot;); printf(&quot;第%d个元素开始匹配\\n&quot;, KMP(p_str_one, p_str_two, next)); putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://goskp.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://goskp.github.io/tags/Algorithm/"}]},{"title":"QT(信号与槽)","slug":"QT(信号与槽)","date":"2022-10-20T14:40:59.000Z","updated":"2022-10-21T14:19:45.383Z","comments":true,"path":"2022/10/20/QT(信号与槽)/","link":"","permalink":"http://goskp.github.io/2022/10/20/QT(%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD)/","excerpt":"","text":"_QtWindowCut:CMakeLists.txt: #请求CMake的版本 cmake_minimum_required(VERSION 3.8) #指定项目名称 project(QtPro) set(CMAKE_AUTOMOC ON) #指定C++标准为17 set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) #在MSVC上必须指定 /Zc:__cplusplus 选项 if(MSVC) add_compile_options(/Zc:__cplusplus) endif() #指定头文件包含目录 include_directories(&quot;D:/MysoftWare/Qt/6.2.4/msvc2019_64/include&quot;) #查找指定的模块 find_package(Qt6 COMPONENTS Widgets REQUIRED) #指定目标生成位置 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_CURRENT_LIST_DIR&#125;/bin) #添加宏定义 #QT_NO_DEBUG_OUTPUT add_compile_definitions( QT_DISABLE_DEPRECATED_BEFORE=0x060000) #根据指定的文件生成可执行程序 add_executable(QtPro &quot;main.cpp&quot; &quot;Widget.h&quot; &quot;Widget.cpp&quot; &quot;SubWidget.h&quot; &quot;SubWidget.cpp&quot;) #给目标连接库文件 target_link_libraries(QtPro Qt6::Widgets) SubWidget.h: #ifndef _SUBWIDGET_H_ #define _SUBWIDGET_H_ #include &lt;QWidget&gt; class SubWidget : public QWidget &#123; Q_OBJECT public: SubWidget(QWidget* parent = nullptr); //自定义信号 //1,返回类型必须是void //2,参数必须等于(或多于)槽函数的参数 //3,信号只有函数的声明，不需要自己定义 //4,信号必须定义在signals下面 //5,发送信号使用emit宏 signals: void cutMainWindow(); void cutMainWindow(int); void cutMainWindow1(const QString&amp;); &#125;; #endif SubWidget.cpp: #include &quot;SubWidget.h&quot; #include &lt;QPushButton&gt; SubWidget::SubWidget(QWidget* parent) :QWidget(parent) &#123; resize(640, 480); setWindowTitle(&quot;子窗口&quot;); auto btn = new QPushButton(&quot;切换到主窗口&quot;, this); //信号可以关联信号 //connect(btn, &amp;QPushButton::clicked, this, &amp;SubWidget::cutMainWindow); connect(btn, &amp;QPushButton::clicked, this, [=]() &#123; emit this-&gt;cutMainWindow(); emit this-&gt;cutMainWindow1(&quot;我还想再显示会儿&quot;); emit cutMainWindow(1314520); &#125;); &#125; Widget.h: #ifndef _WIDGET_H_ #define _WIDGET_H_ #include &lt;QWidget&gt; class SubWidget; class Widget : public QWidget &#123; Q_OBJECT public: Widget(QWidget* parent = nullptr); public slots: void onCutMainWindow(); void onCutMainWindow(int); private: SubWidget* subWidget = nullptr; &#125;; #endif Widget.cpp: #include &quot;Widget.h&quot; #include &lt;QPushButton&gt; #include &quot;SubWidget.h&quot; #include &lt;QDebug&gt; Widget::Widget(QWidget* parent) :QWidget(parent) ,subWidget(new SubWidget) &#123; //subWidget-&gt;show(); resize(640, 480); setWindowTitle(&quot;主窗口&quot;); auto btn = new QPushButton(&quot;切换到子窗口&quot;, this); connect(btn, &amp;QPushButton::clicked, subWidget,&amp;QWidget::show); connect(btn, &amp;QPushButton::clicked, this, &amp;QWidget::hide); //切换到主窗口 //cutMainWindow有重载，connect不知道你要关联哪个信号，二义性问题 //connect(subWidget, &amp;SubWidget::cutMainWindow, this, &amp;Widget::onCutMainWindow); //1,通过函数指针解决 void (SubWidget:: *cutOne)() = &amp;SubWidget::cutMainWindow; //void SubWidget::cutMainWindow(); void (SubWidget:: * cutTwo)(int) = &amp;SubWidget::cutMainWindow; //void SubWidget::cutMainWindow(int); //connect(subWidget, cutOne, this, &amp;Widget::onCutMainWindow); //connect(subWidget, cutTwo, this, &amp;Widget::onCutMainWindow); //2,通过QOverload类解决 推荐使用这一种 //connect(subWidget,QOverload&lt;&gt;::of(&amp; SubWidget::cutMainWindow), this,QOverload&lt;&gt;::of(&amp; Widget::onCutMainWindow)); connect(subWidget, QOverload&lt;int&gt;::of(&amp;SubWidget::cutMainWindow), this, QOverload&lt;int&gt;::of( &amp; Widget::onCutMainWindow)); //3,可以使用Qt4的方式解决 通过宏进行转换 //不安全，因为是使用宏来转换的，会把函数转换成字符串，不会进行安全检查 //函数名写错了也不会报错，只有再运行的时候，才会给你提示 connect(subWidget,SIGNAL(cutMainWindow()), this, SLOT(onCutMainWindow())); connect(subWidget, SIGNAL(cutMainWindow(int)), this, SLOT(onCutMainWindow(int))); //connect(subWidget, &amp;SubWidget::cutMainWindow1, this, [=](const QString&amp; str) // &#123; // qInfo() &lt;&lt; str; // subWidget-&gt;hide(); //子窗口隐藏 // this-&gt;show(); //主窗口显示 // &#125;); &#125; void Widget::onCutMainWindow() &#123; subWidget-&gt;hide(); //子窗口隐藏 this-&gt;show(); //主窗口显示 &#125; void Widget::onCutMainWindow(int val) &#123; onCutMainWindow(); qInfo() &lt;&lt; val; &#125; main.cpp: #include &lt;QApplication&gt; #include &quot;Widget.h&quot; //创建两个窗口，每个窗口都给一个按钮，点击按钮切换窗口 int main(int argc,char* argv[]) &#123; QApplication a(argc, argv); Widget w; w.show(); return a.exec(); &#125; QBasic:CMakeLists.txt: #请求CMake的版本 cmake_minimum_required(VERSION 3.8) #指定项目名称 project(QtPro) #自动moc set(CMAKE_AUTOMOC ON) #指定C++标准为17 set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) #在MSVC上必须指定 /Zc:__cplusplus 选项 if(MSVC) add_compile_options(/Zc:__cplusplus) endif() #指定头文件包含目录 include_directories(&quot;D:/MysoftWare/Qt/6.2.4/msvc2019_64/include&quot;) #查找指定的模块 find_package(Qt6 COMPONENTS Widgets REQUIRED) #指定目标生成位置 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_CURRENT_LIST_DIR&#125;/bin) #添加宏定义 #QT_NO_DEBUG_OUTPUT add_compile_definitions( QT_DISABLE_DEPRECATED_BEFORE=0x060000) #根据指定的文件生成可执行程序 add_executable(QtPro &quot;main1.cpp&quot; &quot;Widget.h&quot; &quot;Widget.cpp&quot;) #给目标连接库文件 target_link_libraries(QtPro Qt6::Widgets) Widget.h: #ifndef _WIDGET_H_ #define _WIDGET_H_ #include &lt;QWidget&gt; class Widget :public QWidget &#123; Q_OBJECT public: Widget(QWidget* parent = nullptr); //槽函数，一般写在 public slots:下 //Qt5以上可以不用写slots public slots: //响应按钮的pressed信号 void onButtonPressed(); public: static void onButtonReleased(); &#125;; #endif // !_WIDGET_H_ Widget.cpp: #include &quot;Widget.h&quot; #include &lt;QPushButton&gt; #include &lt;QDebug&gt; void globalOnClicked() &#123; qInfo() &lt;&lt; __FUNCTION__; &#125; Widget::Widget(QWidget* parent) :QWidget(parent) &#123; auto btn = new QPushButton(&quot;f**k me&quot;,this); //自定义的槽函数 //1,槽函数返回类型为void //2,槽函数的参数不能多于信号的参数(只能等于或少于信号的参数) //关联信号与槽 这里会导致循环，禁止 //connect(btn, &amp;QPushButton::clicked, btn, &amp;QPushButton::click); //1，关联成员函数 connect(btn, &amp;QPushButton::pressed, this, &amp;Widget::onButtonPressed); //2，关联静态函数 connect(btn, &amp;QPushButton::released, this, &amp;Widget::onButtonReleased); //3，关联全局函数 connect(btn, &amp;QPushButton::clicked, this, globalOnClicked); connect(btn, &amp;QPushButton::clicked, globalOnClicked); //4，关联lambda表达式 connect(btn, &amp;QPushButton::clicked, this, [=]() &#123; qInfo() &lt;&lt; __FUNCTION__; btn-&gt;setText(&quot;我是kpsun&quot;); &#125;); //lambda表示式使用注意事项 //int cnt = 0; //栈区的临时变量，构造函数结束，会自动释放 //connect(btn, &amp;QPushButton::clicked, this, [=,&amp;cnt]() //&#123; // qInfo() &lt;&lt; __FUNCTION__&lt;&lt;cnt++; //&#125;); ////在这里呢，禁止引用捕获，否则会出错 //connect(btn, &amp;QPushButton::clicked, this, [&amp;]() // &#123; // qInfo() &lt;&lt; __FUNCTION__; // static int i = 0; // btn-&gt;setText(&quot;我是kpsun&quot; + QString::number(i++)); // &#125;); &#125; void Widget::onButtonReleased() &#123; qInfo() &lt;&lt; __FUNCTION__; &#125; void Widget::onButtonPressed() &#123; qInfo() &lt;&lt; __FUNCTION__; &#125; main.cpp: #include &lt;QApplication&gt; #include &lt;QWidget&gt; //窗口 #include &lt;QPushButton&gt; class Widget : public QWidget &#123; Q_OBJECT //使用信号与槽，必须包含此宏 public: Widget(QWidget* parent = nullptr) &#123; resize(640, 480); auto* btn = new QPushButton(&quot;关闭窗口&quot;, this); //绑定信号与槽 //信号发送者:btn //发送什么信号:clicked //信号接收者:this //槽函数: &amp;Widget::close QObject::connect(btn, &amp;QPushButton::clicked, this,&amp;Widget::close); auto con = connect(btn, &amp;QPushButton::clicked, btn, &amp;QPushButton::close); //断开信号和槽的连接 //disconnect(btn, &amp;QPushButton::pressed, btn, &amp;QPushButton::close); //disconnect(con); &#125; void button() &#123; //先玩一个简单的按钮 auto button = new QPushButton; //显示按钮 button-&gt;show(); //按钮需要显示在主窗口上面,通过这个设置父对象，按钮会出现在主窗口的中心(父窗口会变得很大) button-&gt;setParent(this); //给按钮设置文本 button-&gt;setText(&quot;Button&quot;); auto btn = new QPushButton(&quot;主要靠骚&quot;, this); button-&gt;move(btn-&gt;x() + btn-&gt;width(), 0); btn-&gt;resize(150, 50); //为什么要new? QPushButton btn2(&quot;我是按钮&quot;, this); &#125; &#125;; int main(int argc,char* argv[]) &#123; QApplication a(argc, argv); Widget w; w.show(); return a.exec(); &#125; //当我们把类的声明和定义放在一个源文件里面的时候，才需要告诉moc //显示的告诉moc我这个源文件，需要元编译 //#include&lt;空格&gt;&quot;文件名.moc&quot; #include &quot;main.moc&quot;","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"Unity","slug":"Unity项目","date":"2022-10-14T14:37:13.000Z","updated":"2022-10-20T14:31:28.132Z","comments":true,"path":"2022/10/14/Unity项目/","link":"","permalink":"http://goskp.github.io/2022/10/14/Unity%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"PlayerMovement.cs: 命名空间 System.Collections.Generic 包含了一些基于泛型的集合类，使用泛型集合类可以提供更高的类型安全性, 个人认为类似于C++标准模板库,封装了list, stack, vector等. using System.Collections.Generic; using System.Collections; 使用 Unity引擎 using UnityEngine; 重要的类 - MonoBehaviour MonoBehaviour 类是一个基类，所有 Unity 脚本都默认派生自该类 只要从Unity项目窗口创建一个C#脚本,就会自动继承MonoBehaviour类 有关代码示例点击:MonoBehaviour public class PlayerMovement : MonoBehaviour &#123;&#125; Unity3D中[SerializeField]特性的使用 强制 Unity 对私有字段进行序列化 当 Unity 对脚本进行序列化时，仅对公共字段进行序列化。 如果还需要 Unity 对私有字段进行序列化， 可以将 SerializeField 属性添加到这些字段 Unity 不会序列化 Dictionary，但您可以为键存储一个 List&lt;&gt; 和为值存储一个 List&lt;&gt;，然后在 Awake() 上将它们组合在非序列化字典中。这不能解决您需要修改字典 并将其“保存”回时出现的问题，但在许多其他情况下，这是一个方便的技巧 using UnityEngine; public class SomePerson : MonoBehaviour &#123; //这个字段被序列化，因为它是公共的 public string firstName = &quot;John&quot;; //这个字段不会被序列化，因为它是私有的。 private int age = 40; //这个字段即使是私有的也会被序列化 //因为它应用了SerializeField属性。 [SerializeField] private bool hasHealthPotion = true; void Start() &#123; if (hasHealthPotion) &#123; Debug.Log(&quot;Person&#39;s first name: &quot; + firstName + &quot; Person&#39;s age: &quot; + age); &#125; &#125; &#125; PlayerMovement类的数据成员: 使用Vecotr3三维向量 记录玩家出生点 public Vector3 spownPosition; 记录玩家在垂直方向上的速度(起跳速度) private Vector3 jumpVelocity; 使用float数据类型存储玩家奔跑,左右移动,跳跃的高度[SerializeField] private float runForwardSpeed = 3f; [SerializeField] private float moveHorizonSpeed = 2f; [SerializeField] private float jumpHeight = 2f; 玩家初始化状态设置为false//玩家向左移动 private bool moveLeft = false; //玩家向右移动 private bool moveRight = false; //玩家是否起跳 private bool jumpable = false; //玩家是否接触地面 private bool isGrounded = true; Unity 3D 刚体（Rigidbody） 为游戏对象赋予物理特性,使游戏对象在物理系统的控制下接受推力与扭力，从而实现现实世界中的物理学现象 Rigidbody提供了多个实现接口,可以通过这些参数来控制物体的各种物理状态 private Rigidbody m_rigidbody; Awake: 初始化玩家状态 private void Awake() &#123; //初始化玩家出生点 transform.position = spownPosition; //初始化玩家的起跳速度 jumpVelocity = Vector3.zero; //初始化玩家刚体属性 m_rigidbody = GetComponent&lt;Rigidbody&gt;(); &#125; Start:private void Start() &#123; //初始化起跳速度 jumpVelocity = new Vector3(0, Mathf.Sqrt(2f * 9.81f * jumpHeight)); SectionController.GenerateSection(); &#125; HandleHorizontalMovementInput: 处理玩家水平移动输入 从键盘读入 ‘A’ 或者 小键盘中的向左,则将moveLeft标记为true 从键盘读入 ‘D’ 或者 小键盘中的向右,则将moveRight标记为true private void HandleHorizontalMovementInput() &#123; if (Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow)) &#123; moveLeft = true; &#125; else if (Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow)) &#123; moveRight = true; &#125; &#125; HorizontalMove(int direction): 先获取玩家当前的横坐标(x) 判断direction正负,正则水平右移,负责水平左移 在左移右移的过程中要判定玩家是否越界 private void HorizontalMove(int direction) &#123; float playerXPos = transform.position.x; if (direction &lt; 0) &#123; if (playerXPos &gt; SectionController.leftSide) &#123; transform.Translate(Vector3.right * direction * moveHorizonSpeed * Time.deltaTime, Space.World); &#125; &#125; else if (direction &gt; 0) &#123; if (playerXPos &lt; SectionController.rightSide) &#123; transform.Translate(Vector3.right * direction * moveHorizonSpeed * Time.deltaTime, Space.World); &#125; &#125; &#125; ResetPlayerRotation: 使玩家始终面向前方 private void ResetPlayerRotation() &#123; transform.rotation = Quaternion.Euler(new Vector3(0, 0, 0)); &#125; RunForward: 使玩家向前跑 private void RunForward() &#123; transform.Translate(Vector3.forward * runForwardSpeed * Time.deltaTime, Space.World); &#125; HandlePlayerHorizontalMovement: 处理玩家水平移动 private void HandlePlayerHorizontalMovement() &#123; //使玩家始终面向前方 ResetPlayerRotation(); //使玩家向前跑 RunForward(); //判断玩家左移右移 if (moveLeft) &#123; HorizontalMove(-1); &#125; else if (moveRight) &#123; HorizontalMove(1); &#125; &#125; Jump: 玩家跳跃,初始化玩家起跳速度 private void Jump() &#123; m_rigidbody.velocity = jumpVelocity; &#125; HandleVerticalMovementInput: 判定玩家能否处于跳跃状态 从键盘读入空格 如果玩家没有接触地面,即处于跳跃状态 private void HandleVerticalMovementInput() &#123; if (Input.GetKeyDown(KeyCode.Space)) &#123; if (isGrounded) &#123; jumpable = true; &#125; &#125; &#125; HandlePlayerVerticalMovement: 使玩家起跳 private void HandlePlayerVerticalMovement() &#123; if (jumpable) &#123; Jump(); &#125; &#125; MovementStateReset: 重置玩家移动状态: private void MovementStateReset() &#123; if (Mathf.Abs(transform.position.y) &lt;= 0.51f) &#123; isGrounded = true; &#125; else if (Mathf.Abs(transform.position.y) &gt; 0.51f) &#123; isGrounded = false; &#125; moveRight = false; moveLeft = false; jumpable = false; &#125; PrefabRotate.cs: transform.Rotate: Vector3参数作为欧拉角 rotateSpeed* Time为起跳距离 全局轴(Space.World) using System.Collections; using System.Collections.Generic; using UnityEngine; public class PrefabRotate : MonoBehaviour &#123; public float rotateSpeed = 360f; private void Update() &#123; transform.Rotate(Vector3.up, rotateSpeed * Time.deltaTime, Space.World); &#125; &#125;","categories":[],"tags":[]},{"title":"MySQL配置过程的细节","slug":"MySQL配置过程的细节","date":"2022-10-13T13:05:13.000Z","updated":"2022-10-19T11:31:33.010Z","comments":true,"path":"2022/10/13/MySQL配置过程的细节/","link":"","permalink":"http://goskp.github.io/2022/10/13/MySQL%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BB%86%E8%8A%82/","excerpt":"","text":"最好全在管理员权限下运行管理员打开bin,转到D盘, cd bin目录 安装MySQL , mysqld –install —&gt;Service successfully Installed mysqld –initalize –console —&gt;初始化mysqld服务 net start mysql —&gt;启动服务 mysql -uroot -p默认密码 —&gt;登录mysql show databases; —&gt;查看数据库 set password for ‘root‘@’localhost’&#x3D;’123456’; —&gt;修改密码 —&gt;Query OK quit; —&gt;退出数据库 mysql -uroot -p123456 —&gt;重新登录mysql 停止MySQL服务 删除注册表 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL默认路径C盘：C:\\Program Files\\MySQL\\MySQL Server 5.7 mysql 服务路径:HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MySql mysql\\mysql-5.6.26-winx64\\bin\\mysqld.exe 控制面板-&gt;卸载MySQL Server 删除MySQL安装的位置 删除C:\\Program Files (x86)\\MySQL 删除隐藏的ProgramData 忘记密码:先关闭mysql服务net stop mysql mysqld –console –skip-grant-tables –shared-memory在打开一个cmd窗口(管理员),上面的不要关了mysqlshow databases;use mysql;更新权限:flush privileges;alter user root@localhost identified by ‘123456’;quitBye","categories":[{"name":"数据库","slug":"数据库","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://goskp.github.io/tags/MySQL/"}]},{"title":"设计模式-观察者模式","slug":"设计模式-观察者模式","date":"2022-10-01T02:34:34.000Z","updated":"2022-10-20T15:00:29.639Z","comments":true,"path":"2022/10/01/设计模式-观察者模式/","link":"","permalink":"http://goskp.github.io/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"基于QT信号与槽机制,简单实现一下观察者模式#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; class Boss; //观察者类 class Staff &#123; public: Staff(std::string name, Boss* pBoss) : name(name), pBoss(pBoss) &#123;&#125; void Update(std::string action) &#123; std::cout &lt;&lt; name &lt;&lt; &quot;收到信息:&quot; &lt;&lt; action; if (action == &quot;老板大门走进来&quot;) &#123; std::cout &lt;&lt; &quot;--&gt;开启认真工作模式&quot; &lt;&lt; std::endl; &#125; else if (action == &quot;老板走出大门&quot;) &#123; std::cout &lt;&lt; &quot;--&gt;开启摸鱼状态&quot; &lt;&lt; std::endl; &#125; &#125; private: std::string name; Boss* pBoss; &#125;; //被观察者 class Boss &#123; public: void AddObserver(Staff* pstaff) &#123; staff.push_back(pstaff); &#125; void NotiFy(std::string action) &#123; for (auto&amp; v : staff) &#123; v-&gt;Update(action); &#125; &#125; void SetAction(std::string action) &#123; this-&gt;action = action; NotiFy(action); &#125; private: std::string action; std::vector&lt;Staff*&gt; staff; &#125;; int main(void) &#123; //创建被观察者 Boss* pBoss = new Boss; //创建观察者 Staff* p1 = new Staff(&quot;kpsun&quot;, pBoss); Staff* p2 = new Staff(&quot;skp&quot;, pBoss); //添加到观察者中,建立关联 pBoss-&gt;AddObserver(p1); pBoss-&gt;AddObserver(p2); //设置观察者状态 pBoss-&gt;SetAction(&quot;老板大门走进来&quot;); pBoss-&gt;SetAction(&quot;老板走出大门&quot;); return 0; &#125; kpsun收到信息:老板大门走进来–&gt;开启认真工作模式skp收到信息:老板大门走进来–&gt;开启认真工作模式kpsun收到信息:老板走出大门–&gt;开启摸鱼状态skp收到信息:老板走出大门–&gt;开启摸鱼状态","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://goskp.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://goskp.github.io/tags/DesignPattern/"}]},{"title":"算法-C/C++常用刷题技巧","slug":"算法-CC++常用刷题技巧","date":"2022-09-30T07:36:35.000Z","updated":"2022-10-20T14:56:46.481Z","comments":true,"path":"2022/09/30/算法-CC++常用刷题技巧/","link":"","permalink":"http://goskp.github.io/2022/09/30/%E7%AE%97%E6%B3%95-CC++%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/","excerpt":"","text":"C&#x2F;C++常用刷题技巧万能头文件 万能头文件 基本包括了大部分的STL库函数，使用方便快捷 #include &lt;bits/stdc++.h&gt; vectorvector&lt;int&gt; first; // 空的vector，只是一个列表的头，里面没有元素 vector&lt;int&gt; second (4, 100); // 初始化一个具有4个元素的vector，每个元素的值都是100 vector&lt;int&gt; third (second.begin(), second.end()); // 通过其他vector的迭代器的方式，进行拷贝复制初始化 vector&lt;int&gt; fourth (third); // 直接对其他vector的拷贝复制 int myints[] = &#123;16, 2, 77&#125;; vector&lt;int&gt; fifth (myints, myints+sizeof(myints) / sizeof(int)); // 将数组转化成vector，需要提供的是数组的首地址和地址偏移。 vector&lt;int&gt; sixth = &#123;1,5,4,6&#125;; // 指定内容进行构造，内容为1,5,4,6的vector vector&lt; vector&lt;int&gt; &gt; vars; // 二维vector的初始化 int size = 10; vector&lt;vector&lt;int&gt;&gt; vars(size, vector&lt;int&gt;(size, 0)); // （size,size）的矩阵，元素全部是0 #include&lt;vector&gt; vector&lt;int&gt; test;//建立一个vector test.push_back(1); test.push_back(2);//把1和2压入vector，这样test[0]就是1,test[1]就是2 cout&lt;&lt;vec[0]&lt;&lt;endl;//使用下标访问元素 //使用迭代器访问元素. vector&lt;int&gt;::iterator it; for(it=vec.begin();it!=vec.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; vec.insert(vec.begin()+i,a);//在第i+1个元素前面插入a; vec.erase(vec.begin()+2);//删除第3个元素 vec.erase(vec.begin()+i,vec.end()+j);//删除区间[i,j-1];区间从0开始 cout&lt;&lt;vec.size()&lt;&lt;endl;//向量大小 vec.clear();//清空 sort(v.begin(),v.end()); //用sort()函数从小到大进行排序 reverse(v.begin(),v.end()); // 用reverse()函数翻转数组 v.size() // 返回容器的大小 v.empty() //判断容器是否为空，为空返回0，不为空则为1 cout&lt;&lt;v[0]; // 打印第一个元素 cout&lt;&lt;v[v.size()] //打印最后一个元素 lower_bound(v.begin(),v.end(),a) //在有序数组中返回第一个大于等于a的元素的下标,返回值的是地址 upper_bound(v.begin(),v.end(),a)-v.begin() //在有序数组中返回第一个大于a的元素的下标,这里通过减去首地址，得到了下标位置 vector&lt;int&gt;::iterator it; //定义迭代器方便得到元素值，相当于指针 it=upper_bound(v.begin,v.end(),a) cout&lt;&lt;(*it) //这里返回的是第一个大于a的元素的值 二维数组初始化vector&lt;vector &lt;int&gt; &gt; a(3);//初始化的是3*3的矩阵,注意我们所申请的矩阵行数和列数默认相等的 //如果我们需要行数和列数不相等的二维数组，那么我们可以对每一行所包含的元素个数加以限制； for(int i=0;i&lt;a.size();i++)//利用resize函数将每一行的元素个数设置为5个，即5列 a[i].resize(5);//此时我们得到的就是一个3行5列的二维数组 如果我们采用size函数来得到数组规模，那么我们所得到的结果是矩阵的行数，如果需要得到列数可以使用a[0].size() vector&lt;vector &lt;int&gt; &gt; a(3);//初始化的是3*3的矩阵 for(int i=0;i&lt;a.size();i++)//利用resize函数将每一行的元素个数设置为5个，即5列 a[i].resize(5); cout&lt;&lt;a.size()&lt;&lt;endl;//打印的是vector的行数 除上述初始化行列数不同的二维数组之外，我们也可以直接定义，结果也是3行5列的二维数组 vector&lt;vector&lt;int&gt; &gt; Array(3, vector&lt;int&gt;(5)); cout&lt;&lt;Array[0].size()&lt;&lt;endl; //以下也可以 vector&lt;vector&lt;int&gt; &gt;num = &#123; &#123; 1, 1, 1, 0, 1, 1 &#125;, &#123; 1, 0, 1, 1, 1, 1 &#125;, &#123; 1, 1, 1, 0, 0, 1 &#125;, &#123; 1, 0, 1, 0, 0, 1 &#125;, &#123; 1, 1, 1, 1, 1, 1 &#125; &#125;; 字符串部分string s; string t=&quot;m&quot;; cin&gt;&gt;s;//不包括空格 getline(cin,s);//读取一行，可以包含空格 s.append(t);//将字符t添加到s cout&lt;&lt;s+t; //同上述效果一样 //find(“字符串”) / find(&quot;字符串&quot;,postion) ---找不到就返回很大很大的数,可以与-1比较 if(s1.find(s2)==-1)&#123; cout&lt;&lt;&quot;在s1中未找到s2&quot;&lt;&lt;endl; &#125; cout&lt;&lt;s.find(t)&lt;&lt;endl; //找子序列t在s中出现的首次位置 cout&lt;&lt;s.find(t,2)&lt;&lt;endl; //从第二个位置开始找，找子序列t在s中出现的首次位置 int len = s.size();//字符串s的⻓度 int len = s.length();//字符串s的⻓度 cout&lt;&lt;*s1.begin()&lt;&lt;endl;//指向字符串的第一个元素 cout&lt;&lt;*(s1.end()-1)&lt;&lt;endl;//指向字符串的最后一个元素 reverse(s.begin(), s.end());//字符串反转 string s1 = &quot;hello&quot;; string sTemp=s1.substr(1);//下标1开始到结束 //截取substr（pos,num） ----在哪个位置截取，截取多少字符 string sTemp2 = s1.substr(1,3);//下标1开始，截取3个字符 cout&lt;&lt;sTemp&lt;&lt;&quot;----&quot;&lt;&lt;sTemp2&lt;&lt;endl; cout&lt;&lt;s1[0]&lt;&lt;endl; //访问字符串的0处的位置 string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; //两个字符串之间的大小关系 cout&lt;&lt;(s1==s2)&lt;&lt;endl; cout&lt;&lt;(s1&gt;s2)&lt;&lt;endl; cout&lt;&lt;(s1&lt;s2)&lt;&lt;endl; //插入insert(position,&quot;字符串&quot;) s1.insert(1,&quot;b&quot;); cout&lt;&lt;s1; //删除 erase(pos,num)----在哪个位置删除多少字符 s1.earse(1,2); //将123456转为字符串 s1 = to_string(123456); cout&lt;&lt;s1; //将字符型1234转为int类型 ---string to int int x=stoi(&quot;1234&quot;); cout&lt;&lt;x&lt;&lt;endl; 栈 #include&lt;stack&gt; //要引入库函数 stack&lt;int&gt; s ; for(int i=0;i&lt;6;i++)&#123; s.push(i);//入栈操作 &#125; cout&lt;&lt;s.top()&lt;&lt;endl; //访问s的栈顶元素 cout&lt;&lt;s.size()&lt;&lt;endl; 输出s的元素个数 s.pop(); // 删除栈顶元素但不返回其值 cout&lt;&lt;s.empty()&lt;&lt;endl; //非空返回0，是空返回1 队列#include&lt;queue&gt;//要引入库函数 queue&lt;int&gt; s ; for(int i=0;i&lt;6;i++)&#123; s.push(i);//将i元素接到队列的末端； &#125; cout&lt;&lt;&quot;首元素为：&quot;&lt;&lt;s.front()&lt;&lt;endl; //访问队首元素 cout&lt;&lt;&quot;队尾元素：&quot;&lt;&lt;s.back()&lt;&lt;endl; 访问队尾元素 s.pop(); // 弹出队列的第一个元素，并不会返回元素的值； cout&lt;&lt;s.empty()&lt;&lt;endl; //非空返回0，是空返回1 set ⼀个set⾥⾯的各元素是各不相同的（重复元素自动删除），⽽且set会按照元素进⾏从⼩到⼤排序 #include&lt;set&gt; set&lt;int&gt; s; s.insert(2);//插入元素 s.insert(100);//插入元素 for(int i=0;i&lt;6;i++)&#123; s.insert(i);//插入元素 &#125; //迭代变量set&lt;int&gt;::iterator it for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;//集合的遍历，it是一个迭代的指针 &#125; //方法二： for(auto v: s) cout&lt;&lt;v&lt;&lt;&quot; &quot;; //输入结果：0 1 2 3 4 5 100 //按照从小到大排序，且删除相同元素 s.erase(3);//删除元素为3的 s.clear();//清空 s.size();//长度 s.empty();//判空 cout&lt;&lt;*s.find(2)&lt;&lt;endl; //查找某一个num值，返回的是迭代器，因此需要*来输出 map map&lt;int,int&gt; mp; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; mp[x] =i; &#125; for(auto v: mp) cout&lt;&lt;v.first&lt;&lt;&quot; ： &quot;&lt;&lt;v.second&lt;&lt;endl; unordered_map//1. 头文件 #include &lt;unordered_map&gt; //2. 初始化 unordered_map&lt;char, int&gt; map; //3. 插入元素 //3.1 数组形式 map[&#39;a&#39;] = 1; //3.2 直接插入 map.insert( &#123; &#123;&#39;b&#39;,2&#125; , &#123;&#39;c&#39;,3&#125; &#125; ); //4. 修改元素 map[&#39;a&#39;] = 0; //5. 删除元素 //5.1 删除key为&#39;a&#39;的元素 map.erase(&#39;a&#39;); //5.2删除第一个元素 map.erase(map.begin()); //6. 判断元素是否存在 //6.1 如果元素存在 if(map.find(&#39;a&#39;)!=map.end()) if(map.count(&#39;a&#39;)!=0) //7. 清空所有元素 map.clear(); //8. 遍历取值并取出键和值 //方法一 for( auto&amp; a : map) &#123; char key= a.first; int value= a.second; &#125; //方法二 for (auto it = map.begin(); it != map.end(); it++) &#123; char key = it-&gt;first; int value = it-&gt;second; &#125; //9. 判断是否为空 if( map.empty() ) //10. 求元素个数 map.size(); ACM模式输入输出参考书程序#include&lt;iostream&gt; #include&lt;sstream&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;limits.h&gt; //INT_MIN 和 INT_MAX的头文件 using namespace std; struct stu &#123; string name; int num; &#125;; // 1. 直接输入一个数 int main() &#123; int n = 0; while (cin &gt;&gt; n) &#123; cout &lt;&lt; n &lt;&lt; endl; &#125; return -1; &#125; // 2. 直接输入一个字符串 int main() &#123; string str; while (cin &gt;&gt; str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; return -1; &#125; // 3. 只读取一个字符 int main() &#123; char ch; //方式1 while (cin &gt;&gt; ch) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125; //方式2： cin.get(ch) 或者 ch = cin.get() 或者 cin.get() while (cin.get(ch)) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125; //方式3 ：ch = getchar() while (getchar()) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125; return -1; &#125; // 3.1给定一个数，表示有多少组数（可能是数字和字符串的组合），然后读取 int main() &#123; int n = 0; while (cin &gt;&gt; n) &#123; //每次读取1 + n 个数，即一个样例有n+1个数 vector&lt;int&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; //处理这组数/字符串 for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; endl; &#125; &#125; return -1; &#125; //3.2 首先给一个数字，表示需读取n个字符，然后顺序读取n个字符 int main() &#123; int n = 0; while (cin &gt;&gt; n) &#123; //输入数量 vector&lt;string&gt; strs; for (int i = 0; i &lt; n; i++) &#123; string temp; cin &gt;&gt; temp; strs.push_back(temp); &#125; //处理这组字符串 sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &#39; &#39;; &#125; &#125; return 0; &#125; //4.未给定数据个数，但是每一行代表一组数据，每个数据之间用空格隔开 //4.1使用getchar() 或者 cin.get() 读取判断是否是换行符，若是的话，则表示该组数（样例）结束了，需进行处理 int main() &#123; int ele; while (cin &gt;&gt; ele) &#123; int sum = ele; // getchar() //读取单个字符 /*while (cin.get() != &#39;\\n&#39;) &#123;*/ //判断换行符号 while (getchar() != &#39;\\n&#39;) &#123; //如果不是换行符号的话，读到的是数字后面的空格或者table int num; cin &gt;&gt; num; sum += num; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; //4.2 给定一行字符串，每个字符串用空格间隔，一个样例为一行 int main() &#123; string str; vector&lt;string&gt; strs; while (cin &gt;&gt; str) &#123; strs.push_back(str); if (getchar() == &#39;\\n&#39;) &#123; //控制测试样例 sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; strs.clear(); &#125; &#125; return 0; &#125; //4.3 使用getline 读取一整行数字到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。 int main() &#123; string input; while (getline(cin, input)) &#123; //读取一行 stringstream data(input); //使用字符串流 int num = 0, sum = 0; while (data &gt;&gt; num) &#123; sum += num; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; //4.4 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。 int main() &#123; string words; while (getline(cin, words)) &#123; stringstream data(words); vector&lt;string&gt; strs; string str; while (data &gt;&gt; str) &#123; strs.push_back(str); &#125; sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; &#125; &#125; //4.5 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。每个字符中间用&#39;,&#39;间隔 int main() &#123; string line; //while (cin &gt;&gt; line) &#123; //因为加了“，”所以可以看出一个字符串读取 while(getline(cin, line))&#123; vector&lt;string&gt; strs; stringstream ss(line); string str; while (getline(ss, str, &#39;,&#39;)) &#123; strs.push_back(str); &#125; // sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; int main() &#123; string str; //C语言读取字符、数字 int a; char c; string s; scanf_s(&quot;%d&quot;, &amp;a); scanf(&quot;%c&quot;, &amp;c); scanf(&quot;%s&quot;, &amp;s); printf(&quot;%d&quot;, a); //读取字符 char ch; cin &gt;&gt; ch; ch = getchar(); while (cin.get(ch)) &#123; //获得单个字符 ; &#125; //读取字符串 cin &gt;&gt; str; //遇到空白停止 getline(cin, str); //读入一行字符串 &#125; 自带的宏常量int N = INT_MIN; int N = INT_MAX; const int INF = 0x3f3f3f3f; //通常用来代替最大值，防止运算过程中溢出 0x16进制 字符串判断函数isdigit(c) //判断c字符是不是数字 isalpha(c) //判断c字符是不是字母 isalnum(c) //判断c字符是不是数字或者字母 tolower(c) //转为小写 toupper(c) //转为大写 字符串和数值间的转换int num = 100; string str = to_string(num); //整形转字符串 int number = stoi(str); //字符串转为整形 stol()是字符串转为长整形 迭代器的二分vector&lt;int&gt; nums&#123;1,2,34,44,99&#125;; int k = lower_bound(nums.begin(), nums.end(), 56) - nums.begin(); //第一个大于等于目标值的迭代器位置 int k = upper_bound(nums.begin(), nums.end(), 56) - nums.begin(); // 找到第一个大于目标值的迭代器位置 字符串转为小写/**op作用的范围[str1.begin(), str1.end], 作用完成后，存储位置的开头为：str2.begin()，op为toupper/tolower*/ transform(str1.begin(), str1.end(), str2.begin(), ::toupper); transform(str1.begin(), str1.end(), str2.begin(), ::tolower); 小根堆priority_queue&lt;int&gt; pq; //默认是大根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; //小根堆 快速初始化数组// 注意：这个函数是按字节初始化的 memset(nums, 0, sizeof nums); memset(nums, -1, sizeof nums); memset(nums, 0x3f, sizeof nums); C++11的特性auto p = new ListNode(); // auto 关键字 Node* pre = nullptr // nullptr代替NULL unordered_map&lt;int,int&gt; mp; //哈希表 内部是无序的 unordered_set&lt;int&gt; st; //无序集合 bitsetuint32_t reverseBits(uint32_t n) &#123; string s = bitset&lt;32&gt;(n).to_string(); reverse(s.begin(), s.end()); return bitset&lt;32&gt;(s).to_ulong(); &#125; 字符串分割将字符串按照空格分割 string s = &quot;hello world my name is yao jun&quot;; stringstream ss(s); string str; int cnt = 0; while(ss &gt;&gt; str)&#123; cnt++; cout&lt;&lt;str&lt;&lt;endl; &#125; cout&lt;&lt;cnt&lt;&lt;endl; 执行结果： hello world my name is yao jun 7 四舍五入保留小数char str[10]; double num = 22.23434; sprintf(str, &quot;%.2f&quot;, num); string s = str; cout&lt;&lt;s&lt;&lt;endl; 字符串按格式拆分string a = &quot;12:59:36&quot;; char str2[100]; memcpy(str2, a.c_str(), strlen(a.c_str())); int u, v, w; sscanf(str2, &quot;%d:%d:%d&quot;, &amp;u, &amp;v, &amp;w); cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; 执行结果： 12 59 36 相同字符的字符串string s(10, &#39;a&#39;); cout&lt;&lt;s&lt;&lt;endl; 执行结果: aaaaaaaaaa 结构体排序struct node&#123; int a, b; // 从小到大排序 bool operator &lt; (const node&amp; node_)const&#123; if(a != node_.a) return a &lt; node_.a; return b &lt; node_.b; &#125; &#125;; int main()&#123; vector&lt;node&gt; tt; tt.push_back(&#123;1,5&#125;); tt.push_back(&#123;2,3&#125;); sort(tt.begin(), tt.end()); for(auto &amp;node: tt)&#123; cout&lt;&lt;node.a&lt;&lt;&quot; &quot;&lt;&lt;node.b&lt;&lt;endl; &#125; return 0; &#125; 执行结果： 1 5 2 3 优先队列自定义排序struct node&#123; int a, b; // 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面 bool operator &lt; (const node&amp; node_)const&#123; if(a != node_.a) return a &lt; node_.a; return b &lt; node_.b; &#125; &#125;; int main()&#123; priority_queue&lt;node&gt; pq; pq.push(&#123;1,5&#125;); pq.push(&#123;2,3&#125;); pq.push(&#123;2,5&#125;); while(!pq.empty()) &#123; cout&lt;&lt;pq.top().a&lt;&lt;&quot; &quot;&lt;&lt;pq.top().b&lt;&lt;endl; pq.pop(); &#125; return 0; &#125; 执行结果 2 5 2 3 1 5","categories":[{"name":"算法","slug":"算法","permalink":"http://goskp.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://goskp.github.io/tags/Algorithm/"}]},{"title":"Rust(1)","slug":"Rust(1)","date":"2022-08-31T10:39:55.000Z","updated":"2022-09-30T07:52:32.646Z","comments":true,"path":"2022/08/31/Rust(1)/","link":"","permalink":"http://goskp.github.io/2022/08/31/Rust(1)/","excerpt":"","text":"参考视频: Rust编程语言入门教程（Rust语言&#x2F;Rust权威指南配套) ahead-of-time语言 安装验证 rustc –version rust帮助文档: rustup doc 编译: rustc main.rs 在windows上还会生成一个.pdb文件 rustc只适合编译简单的rust程序 Cargo : cargo new hello_cargo 可以使用其他的VCS,或不适用VCS,cargo new 的时候使用 -vcs这个flag 代码的包称作crate cargo.toml Cargo构建项目 cargo build cargo.lock,不要乱动这个文件 构建和运行Cargo项目 cargo run cargo check 检查代码,确保能通过编译,但是不产生任何可执行文件 为发布构建 cargo build –release 尽量用Cargo [package] name = &quot;hello_cargo&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] rand = &quot;0.8.4&quot; use std::io; //prelude use std::cmp::Ordering; use rand::Rng; //trait fn main() &#123; println!(&quot;guess the number of bytes to read_line&quot;); let secret_number = rand::thread_rng().gen_range(1..1024); println!(&quot;secret number: &#123;&#125;&quot;, secret_number); let _res = 1; //mut可以改变 let mut guess = String::new(); //返回字符串新的实例 //new:创建一个空的字符串 //&amp; : 表示参数是引用类型 io::stdin().read_line(&amp;mut guess).expect(&quot;Unable to read_line&quot;); //io:Result Ok, Err //&#123;&#125;: 占位符, 对应后面变量的值 let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;); println!(&quot;number: &#123;&#125;&quot;,guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;To big&quot;), Ordering::Equal =&gt; println!(&quot;To Win!&quot;), &#125; &#125; use rand::Rng; use std::cmp::Ordering; use std::io; //prelude //trait fn main() &#123; let secret_number = rand::thread_rng().gen_range(1..1024); loop &#123; println!(&quot;guess the number of bytes to read_line&quot;); let mut guess = String::new(); //返回字符串新的实例 io::stdin().read_line(&amp;mut guess).expect(&quot;Unable to read_line&quot;); let guess: u32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; continue, &#125;; println!(&quot;number: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;To big&quot;), Ordering::Equal =&gt; &#123; println!(&quot;To Win!&quot;); break; &#125; &#125; &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://goskp.github.io/tags/Rust/"}]},{"title":"数据结构-排序算法(sort)","slug":"数据结构-排序算法(sort)","date":"2022-07-18T02:35:06.000Z","updated":"2022-10-20T15:00:17.739Z","comments":true,"path":"2022/07/18/数据结构-排序算法(sort)/","link":"","permalink":"http://goskp.github.io/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(sort)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 冒泡排序 思路:基于比较 循环比较相邻两个元素 如果不符合要求 就交换 最后那个已然符合要求 每次冒出来一个 所以循环 len-1 次 可以达成目标 void BubbleSort(int* arr, int len) &#123; for (int i = 0; i &lt; len - 1; ++i) &#123; for (int j = 0; j &lt; len - 1 - i; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; &#125; 选择排序 思路:每次选择最小的，放到应该放的位置 选 len-1 完事 void SelectSort(int* arr, int len) &#123; int min_idx; int tmp; for (int i = 0; i &lt; len - 1; ++i) &#123; min_idx = i; for (int j = i + 1; j &lt; len; ++j) &#123; min_idx = ((arr[min_idx] &lt; arr[j]) ? min_idx : j); &#125; tmp = arr[i]; arr[i] = arr[min_idx]; arr[min_idx] = tmp; // TraverArray(arr, len, false); &#125; &#125; 可以优化的选择排序(插入排序) 思路:把待排数组的第一个元素看成是一个有序数组,然后一个个的把其他元素插入到这个有序数组中去 临时存储待插入数据 从待插数据的前一个位置开始 从后往前找插入位置 没找到插入位置前 往后覆盖 找到插入位置 结束循环 然后待插数据覆盖当前位置 void InsertSort(int* arr, int len) &#123; int pre_idx; int current; for (int i = 1; i &lt; len; ++i) &#123; pre_idx = i - 1; current = arr[i]; while (pre_idx &gt;= 0 &amp;&amp; arr[pre_idx] &gt; current) &#123; arr[pre_idx + 1] = arr[pre_idx]; pre_idx--; &#125; arr[pre_idx + 1] = current; &#125; &#125; 希尔排序 思路:先分组 在组内做插入排序 一般是先分成 len&#x2F;2 组 然后分成 len&#x2F;2&#x2F;2 组 ​ 。。。。 ​ 2组 最后 1组 组的数量 我们称之为 步长 step： len&#x2F;2 len&#x2F;4 … 2 1 void ShellSort(int* arr, int len) &#123; for (int grap = len / 2; grap &gt; 0; grap /= 2) &#123; for (int i = grap; i &lt; len; ++i) &#123; int j = i; int current = arr[i]; while (j - grap &gt;= 0 &amp;&amp; current &lt; arr[j - grap]) &#123; arr[j] = arr[j - grap]; j = j - grap; &#125; arr[j] = current; &#125; &#125; &#125; 简单总结一下: 冒泡排序 每次冒出一个 选择排序 每次选出一个放到合适位置 插入排序 把左边一个元素看成一个有序数组 从第二个元素起把元素一个个的插入到有序数组中 希尔排序 按步长 分组 组内作插入排序 截止到目前,这四种基于比较的排序算法,都不稳定,数据一换,可能效率就会改变很多. 下面阐述一下分治思想二分查找: mid &#x3D; l + (r-l)&#x2F;2;分组排序 快速排序 把数据分成两组 左边的 比中间值小 右边的比中间值大 假定 a[l]是中间值 temp &#x3D; a[l] 循环让l和r并拢 如果l小于r 循环继续 循环判断 a[r] 是否大于temp 如果大于 r– 如果不大于 循环结束 循环结束后 a[l] &#x3D; a[r] 循环判断 a[l] 是否小于temp 如果小于 l++ 如果不小于 循环结束 循环结束后 a[r] &#x3D; a[l] l和r并拢后 temp覆盖 a[l] l和r并拢后 left - l 小于 temp l+1 到right 大于temp left到l 继续分组 l+1 到right 继续分组 直到 无法拆分 左边的继续分两组 右边的继续分两组 一直到无法分割为止 计数排序 void CountSort(int* arr, int len) &#123; int* count_arr = (int*)calloc(sizeof(int), 100); assert(count_arr); for (int i = 0; i &lt; len; ++i) &#123; count_arr[arr[i]]++; //把数据当做数组下标去记录当前数据的个数 &#125; int* sort_arr = (int*)malloc(sizeof(int) * len); assert(sort_arr); for (int i = 1; i &lt; 100; ++i) &#123; //求和 count_arr[i] += count_arr[i - 1]; &#125; //取数据 for (int i = len; i &gt; 0; --i) &#123; sort_arr[count_arr[arr[i - 1]] - 1] = arr[i - 1]; count_arr[arr[i - 1]]--; &#125; memcpy(arr, sort_arr, len * sizeof(int)); free(count_arr); free(sort_arr); &#125; 快速排序 //交换辅助函数 void Swap(int* arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; //改变基准 int Partition(int* arr, int left, int right) &#123; int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; ++i) &#123; if (arr[i] &lt; arr[pivot]) &#123; Swap(arr, i, index); index++; &#125; &#125; Swap(arr, pivot, index - 1); return index - 1; &#125; void Quick(int* arr, int left, int right) &#123; if (left &lt; right) &#123; int partition_index = Partition(arr, left, right); Quick(arr, left, partition_index - 1); Quick(arr, partition_index + 1, right); &#125; &#125; //统一接口 void QuickSort(int* arr, int len) &#123; Quick(arr, 0, len - 1); &#125; 归并排序 思路:把两个有序数组合并成一个有序数组 创建临时数组 一个个比较把两个有序数组中的元素逐个放到临时数组中 把剩下的放到临时数组中 临时数组覆盖待排序数组 /普通的归并排序 void BasicMerge(int* arr, int f_begin, int f_end, int s_begin, int s_end, int* new_arr) &#123; int index = f_begin; int f = f_begin; int s = s_begin; while (f &lt;= f_end &amp;&amp; s &lt;= s_end) &#123; if (arr[f] &lt;= arr[s]) &#123; new_arr[++index] = arr[++f]; &#125; else &#123; new_arr[++index] = arr[++s]; &#125; &#125; //处理剩下元素 while (f &lt;= f_end) &#123; new_arr[++index] = arr[++f]; &#125; while (s &lt;= s_end) &#123; new_arr[++index] = arr[++s]; &#125; // 1 2 3 3-1 = 2 其实元素有三个 memcpy(arr + f_begin, new_arr + f_begin, sizeof(int) * (s_end - f_begin + 1)); &#125; void Merge(int* arr, int left, int right, int* new_arr) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; Merge(arr, left, mid, new_arr); Merge(arr, mid + 1, right, new_arr); BasicMerge(arr, left, mid, mid + 1, right, new_arr); &#125; //统一接口 void MergeSort(int* arr, int len) &#123; int* tmp = (int*)malloc(sizeof(int) * len); Merge(arr, 0, len - 1, tmp); free(tmp); &#125; 基数排序与桶排序 基数排序思路:数组下标天然有序 限制超级多 只能是正整数 (如果有负数，转成正数先) 不能重复 需要特别注意空间 桶排序思路:先把数据分成若干个桶，然后桶内用其他排序方式排序，排完之后再合并 非常稳定 空间换时间 //获取当前数字的任意位上的数字 int GetPosNumber(int num, int pos) &#123; int tmp = 1; for (int i = 0; i &lt; pos - 1; ++i) &#123; tmp *= 10; &#125; return (num / tmp) % 10; &#125; //获取数组最大值 int GetMaxNumber(int* arr, int len) &#123; int max = arr[0]; for (int i = 0; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; max = arr[i]; &#125; &#125; return max; &#125; //求最大值的位数 int GetMaxNumberCount(int num) &#123; int count = 1; while (num / 10) &#123; count++; num /= 10; &#125; return count; &#125; //桶排序 void BucketSort(int* arr, int len, int pos) &#123; int* bucket_arr[10] = &#123;NULL&#125;; for (int i = 0; i &lt; 10; i++) &#123; //初始化为0 如果数据中有0的数据，换一个标记 bucket_arr[i] = (int*)calloc(sizeof(int), len); assert(bucket_arr[i]); &#125; //装桶 for (int i = 0; i &lt; len; ++i) &#123; int index = GetPosNumber(arr[i], pos); for (int j = 0; j &lt; len; ++j) &#123; if (bucket_arr[index][j] == 0) &#123; bucket_arr[index][j] = arr[i]; break; &#125; &#125; &#125; //出桶 int k = 0; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; len; ++j) &#123; if (bucket_arr[i][j] != 0) &#123; arr[k] = bucket_arr[i][j]; bucket_arr[i][j] = 0; k++; &#125; &#125; &#125; &#125; //基数排序 void RadixSort(int* arr, int len) &#123; int max_num = GetMaxNumber(arr, len); int loop = GetMaxNumberCount(max_num); for (int i = 1; i &lt;= loop; ++i) &#123; BucketSort(arr, len, i); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-图(graph)","slug":"数据结构-图(graph)","date":"2022-07-13T08:16:30.000Z","updated":"2022-09-17T13:14:44.714Z","comments":true,"path":"2022/07/13/数据结构-图(graph)/","link":"","permalink":"http://goskp.github.io/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE(graph)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 边和顶点关系: 设n为顶点数,e为边或弧的条数 对无向图: 0 &lt;= e &lt;= n(n - 1)/2 有向图: 0 &lt;= e &lt;= n(n - 1) 对于有向图,每个顶点至多有n - 1条边与其他的n - 1个顶点相连,则n个顶点至多有n(n - 1)条边,但对于无向图,每条边连接2个顶点,故最多n(n - 1) / 2 矩阵法存储: //矩阵法存储有向带权图 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; const int MAX = 10; typedef char VertexType[8]; //顶点类型 typedef int VRType; //权值描述 typedef struct Graph &#123; int arc_num; //边数 int vex_num; //顶点数 VertexType vertex[MAX]; //顶点数组 VRType matrix[MAX][MAX]; //权值 &#125; GRAPH, *LPGRAPH; //找顶点的序号 int SearchIndex(LPGRAPH p_graph, VertexType x) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; if (strcmp(p_graph-&gt;vertex[i], x) == 0) &#123; return i; &#125; &#125; return -1; &#125; LPGRAPH CreateGraph() &#123; LPGRAPH p_graph = (LPGRAPH)malloc(sizeof(GRAPH)); printf(&quot;input arc_num,ver_num:&quot;); scanf(&quot;%d%d&quot;, &amp;p_graph-&gt;arc_num, p_graph-&gt;vex_num); printf(&quot;input %d vex:&quot;, p_graph-&gt;vertex); //顶点数组 for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; scanf(&quot;%s&quot;, p_graph-&gt;vertex[i]); &#125; memset(p_graph-&gt;matrix, 0, sizeof(int) * 100); printf(&quot;input arc:&quot;); VertexType v1, v2; VRType vrt; //权值 for (int i = 0; i &lt; p_graph-&gt;arc_num; ++i) &#123; scanf(&quot;%s%s%d&quot;, v1, v2, &amp;vrt); //定位,找到在矩阵中的行列 int pos_row = SearchIndex(p_graph, v1); int pos_col = SearchIndex(p_graph, v2); p_graph-&gt;matrix[pos_row][pos_col] = vrt; &#125; return p_graph; &#125; //遍历图 void PrintGraph(LPGRAPH p_graph) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; printf(&quot;\\t%s&quot;, p_graph-&gt;vertex[i]); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; printf(&quot;%s\\t&quot;, p_graph-&gt;vertex[i]); for (int j = 0; j &lt; p_graph-&gt;vex_num; ++j) &#123; printf(&quot;%d\\t&quot;, p_graph-&gt;matrix[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125; LPGRAPH CreateGraphByFile(const char* file_name) &#123; LPGRAPH p_graph = (LPGRAPH)malloc(sizeof(GRAPH)); FILE* read = fopen(file_name, &quot;r&quot;); fscanf(read, &quot;%d\\t%d\\n&quot;, &amp;p_graph-&gt;arc_num, &amp;p_graph-&gt;vex_num); for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; fscanf(read, &quot;%s&quot;, p_graph-&gt;vertex[i]); &#125; fscanf(read, &quot;\\n&quot;); memset(p_graph-&gt;matrix, 0, sizeof(int) * 100); VertexType v1, v2; VRType vrt; //权值 for (int i = 0; i &lt; p_graph-&gt;arc_num; ++i) &#123; fscanf(read, &quot;%s\\t%s\\t%d\\n&quot;, v1, v2, &amp;vrt); //定位,找到在矩阵中的行列 int pos_row = SearchIndex(p_graph, v1); int pos_col = SearchIndex(p_graph, v2); p_graph-&gt;matrix[pos_row][pos_col] = vrt; &#125; fclose(read); return p_graph; &#125; int main(void) &#123; LPGRAPH p_graph = CreateGraphByFile(&quot;graph.txt&quot;); PrintGraph(p_graph); return 0; &#125; graph.txt: 5 5 A B C D E A B 1 A C 2 B C 3 C D 4 D E 5 邻接表存储: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; const int MAX = 10; typedef char VertexType[8]; typedef struct ArcNode &#123; int ver_index; struct ArcNode* p_next; &#125; NODE, *LPNODE; LPNODE CreateNode(int ver_index) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); p_new_node-&gt;ver_index = ver_index; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void MyPushFront(NODE** p_head_node, int ver_index) &#123; LPNODE p_new_node = CreateNode(ver_index); p_new_node-&gt;p_next = (*p_head_node); (*p_head_node) = p_new_node; &#125; //顶点信息 typedef struct VNode &#123; VertexType data; LPNODE first_node; &#125; VNODE, *LPVNODE, ARRAY[MAX]; //图 typedef struct graph &#123; int arc_num; int vex_num; ARRAY vertex; //结构体数组 &#125; GRAPH, *LPGRAPH; //定位 int SearchByVextex(LPGRAPH p_graph, VertexType x) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; if (strcmp(p_graph-&gt;vertex[i].data, x) == 0) &#123; return i; &#125; &#125; return -1; &#125; LPGRAPH CreateGraph() &#123; LPGRAPH p_graph = (LPGRAPH)malloc(sizeof(GRAPH)); printf(&quot;input arc_num,ver_num:&quot;); scanf(&quot;%d%d&quot;, &amp;p_graph-&gt;arc_num, &amp;p_graph-&gt;vex_num); printf(&quot;input %d vex:\\n&quot;, p_graph-&gt;vex_num); for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; scanf(&quot;%s&quot;, p_graph-&gt;vertex[i].data); p_graph-&gt;vertex[i].first_node = NULL; &#125; VertexType v1, v2; int pos_v1; int pos_v2; printf(&quot;input arc:\\n&quot;); for (int i = 0; i &lt; p_graph-&gt;arc_num; ++i) &#123; scanf(&quot;%s%s&quot;, v1, v2); pos_v1 = SearchByVextex(p_graph, v1); pos_v2 = SearchByVextex(p_graph, v2); MyPushFront(&amp;p_graph-&gt;vertex[pos_v1].first_node, pos_v2); MyPushFront(&amp;p_graph-&gt;vertex[pos_v2].first_node, pos_v1); &#125; return p_graph; &#125; void PrintGraph(LPGRAPH p_graph) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; printf(&quot;%s\\t&quot;, p_graph-&gt;vertex[i].data); LPNODE p_move = p_graph-&gt;vertex[i].first_node; while (p_move) &#123; printf(&quot;%s--&gt;&quot;, p_graph-&gt;vertex[p_move-&gt;ver_index].data); p_move = p_move-&gt;p_next; &#125; printf(&quot;\\n&quot;); &#125; &#125; int main(void) &#123; LPGRAPH p_graph = CreateGraph(); PrintGraph(p_graph); return 0; &#125; /* input arc_num,ver_num:7 5 input 5 vex: A B C D E input arc: A B A D D C C B C E D E B E */","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-分支定界(C++描述)","slug":"数据结构-分支定界(C++描述)","date":"2022-07-10T08:14:33.000Z","updated":"2022-09-04T12:46:46.614Z","comments":true,"path":"2022/07/10/数据结构-分支定界(C++描述)/","link":"","permalink":"http://goskp.github.io/2022/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C(C++%E6%8F%8F%E8%BF%B0)/","excerpt":"","text":"#include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;limits&gt; #include &lt;queue&gt; #include &lt;vector&gt; typedef class Node &#123; public: Node(int index, int weight) : index(index), weight(weight) &#123;&#125; Node() : index(0), weight(0) &#123;&#125; Node(const Node&amp; object) : index(object.index), weight(object.weight) &#123;&#125; //优先队列的比较内容 friend bool operator&lt;(const Node&amp; one, const Node&amp; two) &#123; return one.weight &gt; two.weight; &#125; public: int index; //顶点 int weight; //权值 &#125; NODE; typedef class Path &#123; public: // std::numeric_limits&lt;int&gt;::max() 最大的正整数 Path() : index(0), weight(std::numeric_limits&lt;int&gt;::max()) &#123;&#125; public: int index; int weight; &#125; PATH; //求解最短路径 typedef class ShortPath &#123; public: ShortPath(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; object, int end) : edge(-1), end(end), node_count(object.size()), graph(object) &#123;&#125; void PrintPath(); void GetShortPath(); private: //矩阵 std::vector&lt;std::vector&lt;int&gt;&gt; graph; int node_count; //顶点数 const int edge; //权值 const int end; //结束位置 std::vector&lt;int&gt; path_index; //最短路径 int short_path; //最短路径的长度 &#125; SHORTPATH; void SHORTPATH::PrintPath() &#123; std::cout &lt;&lt; &quot;weight_min:&quot; &lt;&lt; short_path &lt;&lt; std::endl; std::cout &lt;&lt; &quot;path:&quot;; copy(path_index.begin(), path_index.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;)); std::cout &lt;&lt; std::endl; &#125; void SHORTPATH::GetShortPath() &#123; std::vector&lt;PATH&gt; my_path(node_count); //初始化路径容器的大小 std::priority_queue&lt;NODE, std::vector&lt;NODE&gt;&gt; min_heap; //小顶堆 min_heap.push(NODE(0, 0)); //出口入队 while (true) &#123; NODE top = min_heap.top(); min_heap.pop(); if (top.index == end) &#123; break; &#125; for (int i = 0; i &lt; node_count; ++i) &#123; //剪枝过程 if (graph[top.index][i] != edge &amp;&amp; top.weight + graph[top.index][i] &lt; my_path[i].weight) &#123; min_heap.push(NODE(i, top.weight + graph[top.index][i])); my_path[i].index = top.index; my_path[i].weight = top.weight + graph[top.index][i]; &#125; &#125; if (min_heap.empty()) &#123; break; &#125; &#125; short_path = my_path[end].weight; int index = end; path_index.push_back(index); while (true) &#123; index = my_path[index].index; path_index.push_back(index); if (index == 0) &#123; break; &#125; &#125; &#125; int main(int argc, char** argv) &#123; const int size = 11; std::vector&lt;std::vector&lt;int&gt;&gt; graph(size); for (int i = 0; i &lt; size; ++i) &#123; graph[i].resize(size); &#125; for (int i = 0; i &lt; size; ++i) &#123; for (int j = 0; j &lt; size; ++j) &#123; graph[i][j] = -1; &#125; &#125; //描述图 graph[0][1] = 2; graph[0][2] = 3; graph[0][3] = 4; graph[1][2] = 3; graph[1][5] = 2; graph[1][4] = 7; graph[2][5] = 9; graph[2][6] = 2; graph[3][6] = 2; graph[4][7] = 3; graph[4][8] = 3; graph[5][8] = 3; graph[5][6] = 1; graph[6][9] = 1; graph[6][8] = 5; graph[7][10] = 3; graph[8][10] = 2; graph[9][8] = 2; graph[9][10] = 2; SHORTPATH short_path(graph, 10); short_path.GetShortPath(); short_path.PrintPath(); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈夫曼树(tree)","slug":"数据结构-哈夫曼树(tree)","date":"2022-07-09T08:06:00.000Z","updated":"2022-10-16T10:43:49.876Z","comments":true,"path":"2022/07/09/数据结构-哈夫曼树(tree)/","link":"","permalink":"http://goskp.github.io/2022/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 哈夫曼树:#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; const int g_MAX = 100; typedef struct HuffmanNode &#123; int key; struct HuffmanNode* p_parent_node; struct HuffmanNode* p_left_child_node; struct HuffmanNode* p_right_child_node; &#125; NODE, *LPNODE, *LPTREE; typedef struct MinHeap &#123; int heap_size; LPNODE* pp_heap_data; &#125; MINHEAP, *LPMINHEAP; LPMINHEAP CreateMinHeap() &#123; LPMINHEAP p_min_heap = (LPMINHEAP)malloc(sizeof(MINHEAP)); if (NULL == p_min_heap) &#123; return NULL; &#125; p_min_heap-&gt;heap_size = 0; p_min_heap-&gt;pp_heap_data = (LPNODE*)malloc(sizeof(LPNODE) * g_MAX); return p_min_heap; &#125; int Size(LPMINHEAP p_heap) &#123; return p_heap-&gt;heap_size; &#125; int Empty(LPMINHEAP p_heap) &#123; return p_heap-&gt;heap_size == 0; &#125; void UpwardPenetration(LPMINHEAP p_heap, int cur_index) &#123; while (cur_index &gt; 1) &#123; LPNODE p_min = p_heap-&gt;pp_heap_data[cur_index]; int parent_index = cur_index / 2; if (p_min-&gt;key &lt; p_heap-&gt;pp_heap_data[parent_index]-&gt;key) &#123; p_heap-&gt;pp_heap_data[cur_index] = p_heap-&gt;pp_heap_data[parent_index]; p_heap-&gt;pp_heap_data[parent_index] = p_min; cur_index = parent_index; &#125; else &#123; break; &#125; &#125; &#125; void InsertMinHeap(LPMINHEAP p_heap, LPNODE p_new_data) &#123; p_heap-&gt;pp_heap_data[++p_heap-&gt;heap_size] = p_new_data; UpwardPenetration(p_heap, p_heap-&gt;heap_size); &#125; LPNODE PopHeap(LPMINHEAP p_heap) &#123; LPNODE p_min = p_heap-&gt;pp_heap_data[1]; int cur_index = 1; int child_index = cur_index * 2; while (child_index &lt;= p_heap-&gt;heap_size) &#123; LPNODE p_tmp_node = p_heap-&gt;pp_heap_data[child_index]; if (child_index + 1 &lt;= p_heap-&gt;heap_size &amp;&amp; p_tmp_node-&gt;key &gt; p_heap-&gt;pp_heap_data[child_index + 1]-&gt;key) &#123; p_tmp_node = p_heap-&gt;pp_heap_data[++child_index]; &#125; p_heap-&gt;pp_heap_data[cur_index] = p_tmp_node; cur_index = child_index; child_index *= 2; &#125; p_heap-&gt;pp_heap_data[cur_index] = p_heap-&gt;pp_heap_data[p_heap-&gt;heap_size]; --p_heap-&gt;heap_size; return p_min; &#125; LPNODE CreateNode(int key) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;key = key; p_new_node-&gt;p_parent_node = NULL; p_new_node-&gt;p_left_child_node = NULL; p_new_node-&gt;p_right_child_node = NULL; return p_new_node; &#125; LPNODE CreateHuffmanNode(LPNODE p_first, LPNODE p_second) &#123; LPNODE p_parent_node = CreateNode(p_first-&gt;key + p_second-&gt;key); LPNODE p_min = p_first-&gt;key &gt; p_second-&gt;key ? p_second : p_first; LPNODE p_max = p_first-&gt;key &gt; p_second-&gt;key ? p_first : p_second; p_parent_node-&gt;p_left_child_node = p_min; p_parent_node-&gt;p_right_child_node = p_max; p_first-&gt;p_parent_node = p_parent_node; p_second-&gt;p_parent_node = p_parent_node; return p_parent_node; &#125; void InsertArrayToHeap(LPMINHEAP p_heap, int* arr, int arr_len) &#123; for (int i = 0; i &lt; arr_len; ++i) &#123; InsertMinHeap(p_heap, CreateNode(arr[i])); &#125; &#125; LPTREE CreateHuffmanTree(int* arr, int arr_len) &#123; if (arr_len &lt;= 0) &#123; return NULL; &#125; else if (arr_len == 1) &#123; return CreateNode(arr[0]); &#125; else &#123; LPMINHEAP p_heap = CreateMinHeap(); InsertArrayToHeap(p_heap, arr, arr_len); LPTREE p_root = (LPTREE)malloc(sizeof(NODE)); while (!Empty(p_heap)) &#123; LPNODE p_first = PopHeap(p_heap); LPNODE p_second = PopHeap(p_heap); p_root = CreateHuffmanNode(p_first,p_second); if (Empty(p_heap)) &#123; break; &#125; InsertMinHeap(p_heap, p_root); &#125; return p_root; &#125; &#125; void PrintCurNode(LPNODE p_cur_node) &#123; printf(&quot;%d\\t&quot;, p_cur_node-&gt;key); &#125; void PreOrderTraversalHuffmanTree(LPTREE p_root) &#123; if (NULL != p_root) &#123; PrintCurNode(p_root); PreOrderTraversalHuffmanTree(p_root-&gt;p_left_child_node); PreOrderTraversalHuffmanTree(p_root-&gt;p_right_child_node); &#125; &#125; LPNODE SearchHuffmanTree(LPTREE p_tree, int key) &#123; LPNODE p_move = p_tree; LPNODE p_stack[100]; int top = -1; while (NULL != p_move || top != -1) &#123; while (NULL != p_move &amp;&amp; p_move-&gt;key != key) &#123; p_stack[++top] = p_move; p_move = p_move-&gt;p_left_child_node; &#125; if (NULL == p_move) &#123; p_move = p_stack[top--]; p_move = p_move-&gt;p_right_child_node; &#125; else if (p_move-&gt;key == key) &#123; break; &#125; &#125; return p_move; &#125; void PrintCode(LPNODE p_leaf) &#123; LPNODE p_move = p_leaf; int stack[100]; int top = -1; while (p_move) &#123; if (p_move-&gt;p_parent_node != NULL &amp;&amp; p_move-&gt;p_parent_node-&gt;p_left_child_node == p_move) &#123; stack[++top] = 0; &#125; else if (p_move-&gt;p_parent_node != NULL &amp;&amp; p_move-&gt;p_parent_node-&gt;p_right_child_node == p_move) &#123; stack[++top] = 1; &#125; else &#123; break; &#125; p_move = p_move-&gt;p_parent_node; &#125; while (top != -1) &#123; printf(&quot;%d&quot;,stack[top--]); &#125; printf(&quot;\\n&quot;); &#125; struct Flag &#123; unsigned int a : 8; unsigned int b : 8; &#125;; int main(int argc, char* argv[]) &#123; int arr[]=&#123;7,4,2,5&#125;; LPTREE p_huffmantree = CreateHuffmanTree(arr, 4); PreOrderTraversalHuffmanTree(p_huffmantree); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%d:&quot;,arr[i]); PrintCode(SearchHuffmanTree(p_huffmantree, arr[i])); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-二叉搜索树(tree)","slug":"数据结构-二叉搜索树(tree)","date":"2022-07-08T11:34:11.000Z","updated":"2022-10-17T03:42:54.466Z","comments":true,"path":"2022/07/08/数据结构-二叉搜索树(tree)/","link":"","permalink":"http://goskp.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 描述二叉搜索树单一类型://处理二叉搜索树的数据 typedef struct DataPair &#123; int first; //比较准则 char second[20]; //字符串数据为例 &#125; DATA, *LPDATA; //二叉树的结点 typedef struct TreeNode &#123; DATA data; struct TreeNode* p_left_child_node; struct TreeNode* p_right_child_node; &#125; TREENODE, *LPTREENODE; //二叉搜索树 typedef struct BinarySearchTree &#123; LPTREENODE p_root; //根节点 int tree_size; &#125; BST, *LPBST; 创建结点://创建结点 LPTREENODE CreateTreeNode(DATA new_data) &#123; LPTREENODE p_new_node = (LPTREENODE)malloc(sizeof(TREENODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_left_child_node = NULL; p_new_node-&gt;p_right_child_node = NULL; return p_new_node; &#125; 描述二叉搜索树最初状态://创建树,就是描述树的最初状态 LPBST CreateBST() &#123; LPBST p_new_bst = (LPBST)malloc(sizeof(BST)); if (NULL == p_new_bst) &#123; return NULL; &#125; p_new_bst-&gt;p_root = NULL; p_new_bst-&gt;tree_size = 0; return p_new_bst; &#125; 万金油://万金油 int Size(LPBST p_tree) &#123; return p_tree-&gt;tree_size; &#125; int Empty(LPBST p_tree) &#123; return p_tree-&gt;tree_size == 0; &#125; 二叉搜索树的插入:void InsertNode(LPBST p_tree, DATA new_data) &#123; //插入的数据变成一个结点 LPTREENODE p_new_node = CreateTreeNode(new_data); //找合适的位置 LPTREENODE p_move = p_tree-&gt;p_root; LPTREENODE p_move_parent = NULL; // p_move的父结点 while (NULL != p_move) &#123; p_move_parent = p_move; if (new_data.first &lt; p_move-&gt;data.first) &#123; //新数据小于p_move里的数据,往左走 p_move = p_move-&gt;p_left_child_node; &#125; else if (new_data.first &gt; p_move-&gt;data.first) &#123; //新数据大于p_move里的数据 p_move = p_move-&gt;p_right_child_node; &#125; else &#123; //如果新数据等于p_move里的数据, //采用覆盖的方式 strcpy(p_move-&gt;data.second, new_data.second); return; &#125; &#125; //分析查找的结果 if (p_tree-&gt;p_root == NULL) &#123; //如果根节点为空 p_tree-&gt;p_root = p_new_node; &#125; else &#123; //如果不为空,要考虑插在父结点的左边还是右边 if (p_move_parent-&gt;data.first &gt; new_data.first) &#123; //父结点的数据大于新结点的数据,插在父结点的左边 p_move_parent-&gt;p_left_child_node = p_new_node; &#125; else &#123; //反之,插在父结点的右边 p_move_parent-&gt;p_right_child_node = p_new_node; &#125; &#125; &#125; 二叉搜索树的遍历:void PrintCurNode(LPTREENODE p_cur_node) &#123; printf(&quot;%d:%s\\n&quot;, p_cur_node-&gt;data.first, p_cur_node-&gt;data.second); &#125; //中序遍历 void InorderTraversal(LPTREENODE p_root) &#123; if (NULL != p_root) &#123; InorderTraversal(p_root-&gt;p_left_child_node); PrintCurNode(p_root); InorderTraversal(p_root-&gt;p_right_child_node); &#125; &#125; 查找树结点LPTREENODE SearchBST(LPBST p_tree, int first) &#123; LPTREENODE p_move = p_tree-&gt;p_root; if (NULL == p_move) &#123; return p_move; &#125; else &#123; while (NULL != p_move &amp;&amp; p_move-&gt;data.first != first) &#123; if (p_move-&gt;data.first &gt; first) &#123; p_move = p_move-&gt;p_left_child_node; &#125; else &#123; p_move = p_move-&gt;p_right_child_node; &#125; &#125; return p_move; &#125; &#125; 测试数据:int main(int argc, char* argv[]) &#123; LPBST p_tree = CreateBST(); DATA data[8] = &#123;10, &quot;物理&quot;, 18, &quot;大力&quot;, 3, &quot;菜鸟&quot;, 12, &quot;hh&quot;, 2, &quot;C语言&quot;, 7, &quot;C++&quot;, 4, &quot;Py&quot;&#125;; for (int i = 0; i &lt; 8; ++i) &#123; InsertNode(p_tree, data[i]); &#125; InorderTraversal(p_tree-&gt;p_root); LPTREENODE p_result = SearchBST(p_tree, 100); if (NULL == p_result) &#123; printf(&quot;未找到相关信息\\n&quot;); &#125; printf(&quot;查找18: %s\\n&quot;, SearchBST(p_tree, 18)-&gt;data.second); return 0; &#125; 二叉搜索树的删除://删除结点 // 1.从当前结点左子树中找最右边放上去 // 2.从当前结点右子树中找最左边放上去 //创建一个结点替换要删除的结点 //再去删除拿上来的哪个结点 //二叉搜索树的删除 void DeleteNode(LPBST p_tree, int first) &#123; LPTREENODE p_move = p_tree-&gt;p_root; LPTREENODE p_move_parent = NULL; while (NULL != p_move &amp;&amp; p_move-&gt;data.first != first) &#123; p_move_parent = p_move; if (first &lt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_left_child_node; &#125; else if (first &gt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_right_child_node; &#125; else &#123; break; &#125; &#125; //分析结果 if (NULL == p_move) &#123; printf(&quot;无此处,删除失败\\n&quot;); return; &#125; else if (p_move-&gt;p_left_child_node != NULL &amp;&amp; p_move-&gt;p_right_child_node != NULL) &#123; //左右子树都健在的情况 LPTREENODE p_move_node = p_move-&gt;p_left_child_node; LPTREENODE p_move_node_parent = p_move; while (NULL != p_move_node-&gt;p_right_child_node) &#123; p_move_node_parent = p_move_node; p_move_node = p_move_node-&gt;p_right_child_node; &#125; LPTREENODE p_new_node = CreateTreeNode(p_move_node-&gt;data); p_new_node-&gt;p_left_child_node = p_move-&gt;p_left_child_node; p_new_node-&gt;p_left_child_node = p_move-&gt;p_right_child_node; //分类讨论父节点是否存在 if (NULL == p_move_parent) &#123; p_tree-&gt;p_root = p_new_node; &#125; else if (p_move == p_move_parent-&gt;p_left_child_node) &#123; p_move_parent-&gt;p_left_child_node = p_new_node; &#125; else &#123; p_move_parent-&gt;p_right_child_node = p_new_node; &#125; //调整二叉树 //改变删除指针的位置 if (p_move_node_parent == p_move) &#123; //调整的结点在左边 p_move_parent = p_new_node; &#125; else &#123; p_move_parent = p_move_node_parent; &#125; free(p_move); //原来的结点干掉 p_move = p_move_node; //删除指针调整到要调节的位置 &#125; //只有一边的情况的删除 LPTREENODE p_side_node = NULL; if (NULL != p_move-&gt;p_left_child_node) &#123; p_side_node = p_move-&gt;p_left_child_node; &#125; else &#123; p_side_node = p_move-&gt;p_right_child_node; &#125; if (p_tree-&gt;p_root == p_move) &#123; p_tree-&gt;p_root = p_side_node; &#125; else &#123; if (p_move == p_move_parent-&gt;p_left_child_node) &#123; p_move_parent-&gt;p_left_child_node = p_side_node; &#125; else &#123; p_move_parent-&gt;p_right_child_node = p_side_node; &#125; &#125; free(p_move); p_tree-&gt;tree_size--; &#125; 测试数据:printf(&quot;删除结点3\\n&quot;); DeleteNode(p_tree, 3); InorderTraversal(p_tree-&gt;p_root);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-二叉树(tree)","slug":"数据结构-二叉树(tree)","date":"2022-07-07T00:26:46.000Z","updated":"2022-09-04T08:10:38.361Z","comments":true,"path":"2022/07/07/数据结构-二叉树(tree)/","link":"","permalink":"http://goskp.github.io/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 最容易想到的创建方法 先创建结点,在根据树结构链接树结点 //结构体描述 typedef struct TreeNode &#123; char data; struct TreeNode* p_left_child; struct TreeNode* p_right_child; &#125; TREE, *LPTREE; //暴力创建法 LPTREE CreateTreeNode(char data) &#123; LPTREE p_tree_node = (LPTREE)malloc(sizeof(TREE)); p_tree_node-&gt;data = data; p_tree_node-&gt;p_left_child = NULL; p_tree_node-&gt;p_right_child = NULL; return p_tree_node; &#125; //插入树 void InsertTreeNode(LPTREE p_parent, LPTREE p_left_child, LPTREE p_right_child) &#123; p_parent-&gt;p_left_child = p_left_child; p_parent-&gt;p_right_child = p_right_child; &#125; int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); printf(&quot;先序遍历:&quot;); PreOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;中序遍历:&quot;); MidOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;后序遍历:&quot;); LastOrderTree(A); putchar(&#39;\\n&#39;); return 0; &#125; 递归遍历: //先序遍历 void PreOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; printf(&quot;%c\\t&quot;, p_root-&gt;data); PreOrderTree(p_root-&gt;p_left_child); PreOrderTree(p_root-&gt;p_right_child); &#125; &#125; //中序 void MidOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; MidOrderTree(p_root-&gt;p_left_child); printf(&quot;%c\\t&quot;, p_root-&gt;data); MidOrderTree(p_root-&gt;p_right_child); &#125; &#125; //后序 void LastOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; LastOrderTree(p_root-&gt;p_left_child); LastOrderTree(p_root-&gt;p_right_child); printf(&quot;%c\\t&quot;, p_root-&gt;data); &#125; &#125; 递归法创建二叉树//递归创建 void CreateTree(LPTREE* p_tree) &#123; char user_key = &#39;\\0&#39;; scanf(&quot;%c&quot;, &amp;user_key); if (user_key == &#39;#&#39;) &#123; *p_tree = NULL; &#125; else &#123; *p_tree = (TREE*)malloc(sizeof(TREE)); (*p_tree)-&gt;data = user_key; CreateTree(&amp;(*p_tree)-&gt;p_left_child); CreateTree(&amp;(*p_tree)-&gt;p_right_child); &#125; &#125; int main(int argc, char** argv) &#123; //测试数据:ABD#G###CE##F## LPTREE A = NULL; CreateTree(&amp;A); printf(&quot;先序遍历:&quot;); PreOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;中序遍历:&quot;); MidOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;后序遍历:&quot;); LastOrderTree(A); putchar(&#39;\\n&#39;); return 0; &#125; 先序遍历:A B D G C E F 中序遍历:D G B A E C F 后序遍历:G D B E F C A 层次遍历://层次遍历,(队列) void LayerOrder(LPTREE p_root) &#123; //准备一个移动结点 LPTREE p_move = p_root; //准备一个队列 LPTREE p_queue[1024]; int front = 0; int tail = 0; p_queue[tail++] = p_move; printf(&quot;%c\\t&quot;, p_move-&gt;data); while (front != tail) &#123; //出队 p_move = p_queue[front++]; //如果有左子树,左子树入队,右子树同理 if (p_move-&gt;p_left_child != NULL) &#123; p_queue[tail++] = p_move-&gt;p_left_child; printf(&quot;%c\\t&quot;,p_move-&gt;p_left_child-&gt;data); &#125; if (p_move-&gt;p_right_child != NULL) &#123; p_queue[tail++] = p_move-&gt;p_right_child; printf(&quot;%c\\t&quot;,p_move-&gt;p_right_child-&gt;data); &#125; &#125; &#125; //测试数据 int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); // printf(&quot;先序遍历:&quot;); // PreOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;中序遍历:&quot;); // MidOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;后序遍历:&quot;); // LastOrderTree(A); // putchar(&#39;\\n&#39;); // LPTREE A = NULL; // CreateTree(&amp;A); // printf(&quot;先序遍历:&quot;); // PreOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;中序遍历:&quot;); // MidOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;后序遍历:&quot;); // LastOrderTree(A); // putchar(&#39;\\n&#39;); printf(&quot;层次遍历:&quot;); LayerOrder(A); return 0; &#125; 非递归遍历(通过栈的方式): 先序: //非递归遍历 //先序遍历 // 1.一直走走左子树,边走边打印相关结点数据,ABD,把走过的结点入栈,不然回退不了,当前栈里元素:DBA // 2.p_move = D, 栈里还剩下BA, 出栈后,p_move走右边,做同样的事情 void PreOrderTreeByStack(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; LPTREE p_move = p_root; LPTREE p_stack[1000]; int stack_top = -1; while (stack_top != -1 || NULL != p_move) &#123; //往左边走,边走边打印,走过的路入栈 while (p_move) &#123; printf(&quot;%c\\t&quot;, p_move-&gt;data); p_stack[++stack_top] = p_move; //走过的地方入栈 p_move = p_move-&gt;p_left_child; &#125; //出栈 if (stack_top != -1) &#123; p_move = p_stack[stack_top--]; //出站后往右面走 p_move = p_move-&gt;p_right_child; &#125; &#125; &#125; 中序: //中序遍历的非递归方式 //左边一直走,不做打印,入栈即可 //出栈的时候,打印结点,再去找右边 void MidOrderTreeByStack(LPTREE p_root) &#123; if (NULL == p_root) &#123; return; &#125; LPTREE p_move = p_root; LPTREE p_stack[1000]; int stack_top = -1; while (NULL != p_move || stack_top != -1) &#123; while (p_move) &#123; //入栈 p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; if (stack_top != -1) &#123; //出栈 p_move = p_stack[stack_top--]; printf(&quot;%c\\t&quot;, p_move-&gt;data); //往右面走 p_move = p_move-&gt;p_right_child; &#125; &#125; &#125; 后序: //后续非递归遍历 //把最后一次访问过的结点标注 void LastOrderTreeByStack(LPTREE p_root) &#123; if (NULL == p_root) &#123; return NULL; &#125; LPTREE p_stack[1000]; int stack_top = -1; LPTREE p_move = p_root; LPTREE p_last_visit = NULL; while (p_move) &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; while (stack_top != -1) &#123; p_move = p_stack[stack_top--]; // D if (p_move-&gt;p_right_child == NULL || p_move-&gt;p_right_child == p_last_visit) &#123; printf(&quot;%c\\t&quot;, p_move-&gt;data); p_last_visit = p_move; &#125; else &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_right_child; while (p_move) &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; &#125; &#125; &#125; 测试数据: int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); printf(&quot;非递归前序遍历:&quot;); PreOrderTreeByStack(A); putchar(&#39;\\n&#39;); printf(&quot;非递归中序遍历:&quot;); MidOrderTreeByStack(A); putchar(&#39;\\n&#39;); printf(&quot;非递归后序遍历:&quot;); LastOrderTreeByStack(A); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-堆(heap)","slug":"数据结构-堆(heap)","date":"2022-07-06T04:50:51.000Z","updated":"2022-09-04T08:28:58.080Z","comments":true,"path":"2022/07/06/数据结构-堆(heap)/","link":"","permalink":"http://goskp.github.io/2022/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86(heap)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 系统堆: malloc, new出来的内存,可以随便拿,随便取人为堆: 引申出的一种特定堆,按照二叉树形式排列的一种堆大顶堆: 数组中依次插入元素: 从下标1开始依次插入元素, ++cur_size 形成二叉树形式: 父结点的下标等于孩子结点的一半 相邻的层数相比,上面的元素要比下面的大 描述大顶堆单一结构://存10个元素, 第0个位置不存放元素 const int g_MAX = 11; typedef struct &#123; int* p_heap_data; int heap_size; &#125; HEAP, *LPHEAP; 创建堆:LPHEAP CreateHeap() &#123; LPHEAP p_heap = (LPHEAP)malloc(sizeof(HEAP)); if (NULL == p_heap) &#123; return NULL; &#125; p_heap-&gt;heap_size = 0; p_heap-&gt;p_heap_data = (int*)malloc(sizeof(int) * g_MAX); return p_heap; &#125; 形成二叉树:void CreateBigHeap(LPHEAP p_heap, int cur_pos) &#123; while (cur_pos &gt; 1) &#123; int max = p_heap-&gt;p_heap_data[cur_pos]; //假设当前下标为最大元素 int parent_index = cur_pos / 2; //父结点的下标 //父结点与最大元素相比,如果当前元素大,就交换 if (max &gt; p_heap-&gt;p_heap_data[parent_index]) &#123; //父结点与当前结点元素交换 p_heap-&gt;p_heap_data[cur_pos] = p_heap-&gt;p_heap_data[parent_index]; p_heap-&gt;p_heap_data[parent_index] = max; //当前下标变为父结点 cur_pos = parent_index; &#125; else &#123; break; &#125; &#125; &#125; 向堆中插入元素:void InsertHeap(LPHEAP p_heap, int new_data) &#123; if (p_heap-&gt;heap_size == g_MAX - 1) &#123; return; &#125; //直接插在当前下标 p_heap-&gt;p_heap_data[++p_heap-&gt;heap_size] = new_data; CreateBigHeap(p_heap, p_heap-&gt;heap_size); &#125; 遍历大顶堆:void PrintHeap(LPHEAP p_heap) &#123; for (int i = 1; i &lt;= p_heap-&gt;heap_size; ++i) &#123; printf(&quot;%d\\t&quot;, p_heap-&gt;p_heap_data[i]); &#125; putchar(&#39;\\n&#39;); &#125; 有序出堆://出堆 //先将堆顶,再找下面一层最大的依次抛出 int OutHeap(LPHEAP p_heap) &#123; int max = p_heap-&gt;p_heap_data[1]; //大顶堆第一个元素就是最大的 int cur_pos = 1; //当前下标 int child_pos = cur_pos * 2; //孩子结点序号 while (child_pos &lt;= p_heap-&gt;heap_size) &#123; int tmp = p_heap-&gt;p_heap_data[child_pos]; //每一层的第一个 //同一层上进行左右结点比较 if (child_pos + 1 &lt;= p_heap-&gt;p_heap_data &amp;&amp; //左边的元素小于右边的元素 tmp &lt; p_heap-&gt;p_heap_data[child_pos + 1]) &#123; tmp = p_heap-&gt;p_heap_data[++child_pos]; &#125; //向下去找 p_heap-&gt;p_heap_data[cur_pos] = tmp; cur_pos = child_pos; child_pos *= 2; &#125; p_heap-&gt;p_heap_data[cur_pos]=p_heap-&gt;p_heap_data[p_heap-&gt;heap_size]; --p_heap-&gt;heap_size; return max; &#125; int Size(LPHEAP p_heap) &#123; return p_heap-&gt;heap_size; &#125; int Empty(LPHEAP p_heap) &#123; return p_heap-&gt;heap_size == 0; &#125; //测试数据 int main(int argc, char** argv) &#123; srand((unsigned int)time(NULL)); LPHEAP p_heap = CreateHeap(); for (int i = 0; i &lt; 10; ++i) &#123; InsertHeap(p_heap, rand() % 100); &#125; printf(&quot;存储情况:&quot;); PrintHeap(p_heap); putchar(&#39;\\n&#39;); printf(&quot;堆排序:&quot;); while(!Empty(p_heap)) &#123; printf(&quot;%d\\t&quot;,OutHeap(p_heap)); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈希表(hash)","slug":"数据结构-哈希表(hash)","date":"2022-07-05T10:06:58.000Z","updated":"2022-09-04T08:10:28.968Z","comments":true,"path":"2022/07/05/数据结构-哈希表(hash)/","link":"","permalink":"http://goskp.github.io/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8(hash)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 链式结构描述哈希表// 保证有序性插入 //产生相同的就以当前结点为表头创建链表插在后面 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct DataType &#123; int key; char element[20]; &#125;; struct Node &#123; struct DataType data; struct Node* p_next; &#125;; struct Node* CreateNode(struct DataType data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //散列表结点的描述 struct SkipListNode &#123; struct DataType data; struct Node* p_first_node; //横向链表的第一个结点 struct SkipListNode* p_next; //纵向,第一列的链表链接 &#125;; struct SkipListNode* CreateSkipListNode(struct DataType data) &#123; struct SkipListNode* p_new_node = (struct SkipListNode*)malloc(sizeof(struct SkipListNode)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_first_node = NULL; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //描述哈希结构 struct ListHash &#123; struct SkipListNode* p_head_node; int hash_size; int divisor; &#125;; //创建哈希结构 struct ListHash* CreateHash(int divisor) &#123; struct ListHash* p_hash = (struct ListHash*)malloc(sizeof(struct ListHash)); if (NULL == p_hash) &#123; return NULL; &#125; p_hash-&gt;divisor = divisor; p_hash-&gt;hash_size = 0; p_hash-&gt;p_head_node = NULL; return p_hash; &#125; void InsertHash(struct ListHash* p_hash, struct DataType data) &#123; int data_hash_pos = data.key % p_hash-&gt;divisor; //变成散列表结点 struct SkipListNode* p_new_skip_node = CreateSkipListNode(data); //头结点为空,直接充当表头,无头链表 if (p_hash-&gt;p_head_node == NULL) &#123; p_hash-&gt;p_head_node = p_new_skip_node; p_hash-&gt;hash_size++; return; &#125; else &#123; //头结点不为空 struct SkipListNode* p_move = p_hash-&gt;p_head_node; struct SkipListNode* p_move_left = NULL; //存在哈希冲突 //第一个结点的key大于元素的key:无表头链表的表头法插入 if (p_move-&gt;data.key % p_hash-&gt;divisor &gt; data_hash_pos) &#123; p_new_skip_node-&gt;p_next = p_hash-&gt;p_head_node; p_hash-&gt;p_head_node = p_new_skip_node; p_hash-&gt;hash_size++; &#125; else &#123; //找到合适的位置,(找到了,没找到,相同的(键相同,hash地址相同)) //第一次大于要插入元素哈希地址的位置 while (p_move != NULL &amp;&amp; (p_move-&gt;data.key % p_hash-&gt;divisor) &lt; data_hash_pos) &#123; p_move_left = p_move; p_move = p_move_left-&gt;p_next; &#125; //存在冲突,则插入到横向链表中 if (p_move != NULL &amp;&amp; (p_move-&gt;data.key % p_hash-&gt;divisor) == data_hash_pos) &#123; if (p_move-&gt;data.key == data.key) &#123; //键相同采用覆盖的方式 strcpy(p_move-&gt;data.element, data.element); &#125; else &#123; //横向插入 struct Node* p_new_node = CreateNode(data); struct Node* p_move_ = p_move-&gt;p_first_node; if (NULL == p_move_left) &#123; p_new_node-&gt;p_next = p_move-&gt;p_first_node; p_move-&gt;p_first_node = p_new_node; p_hash-&gt;hash_size++; &#125; else &#123; //横向中冲突的元素是否存在相同的键 while (p_move_ != NULL &amp;&amp; p_move_-&gt;data.key != data.key) &#123; p_move_ = p_move_-&gt;p_next; &#125; if (NULL == p_move_) &#123; p_new_node-&gt;p_next = p_move-&gt;p_first_node; p_move-&gt;p_first_node = p_new_node; p_hash-&gt;hash_size++; &#125; else &#123; strcpy(p_move_-&gt;data.element, data.element); &#125; &#125; &#125; &#125; else &#123; //不存在冲突的情况,直接插在纵向链表中 p_move_left-&gt;p_next = p_new_skip_node; p_new_skip_node-&gt;p_next = p_move; p_hash-&gt;hash_size++; &#125; &#125; &#125; &#125; void PrintHash(struct ListHash* p_hash) &#123; struct SkipListNode* p_move = p_hash-&gt;p_head_node; while (NULL != p_move) &#123; printf(&quot;%d:%s\\t&quot;, p_move-&gt;data.key, p_move-&gt;data.element); //横向遍历 struct Node* p_move_ = p_move-&gt;p_first_node; while (NULL != p_move_) &#123; printf(&quot;%d:%s\\t\\t&quot;, p_move-&gt;data.key, p_move-&gt;data.element); p_move_ = p_move_-&gt;p_next; &#125; putchar(&#39;\\n&#39;); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char** argv) &#123; struct ListHash* p_hash = CreateHash(10); struct DataType array[] = &#123; 1,&quot;王菲&quot;,12,&quot;刘亦菲&quot;,11,&quot;LZG&quot;,15,&quot;Baby&quot;,1,&quot;睿睿&quot; ,22,&quot;王菲&quot;,32,&quot;Oracle&quot;,56,&quot;LZG&quot;,75,&quot;Baby&quot;,80,&quot;睿睿&quot; &#125;; for (int i = 0; i &lt; 10; ++i) &#123; InsertHash(p_hash, array[i]); &#125; PrintHash(p_hash); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈希存储(hash)","slug":"数据结构-哈希存储(hash)","date":"2022-07-05T09:12:58.000Z","updated":"2022-09-04T08:10:23.688Z","comments":true,"path":"2022/07/05/数据结构-哈希存储(hash)/","link":"","permalink":"http://goskp.github.io/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8(hash)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss Hash基础(hash叫做哈希,又称为散列)哈希构造函数(用来求hash地址的,不是指针),人为的地址 取余法: h(k) &#x3D; k % p h(key) &#x3D; key % p p &#x3D; 10(p由自己决定) h(10) &#x3D; 10 % 10 &#x3D; 0; h(14) &#x3D; 14 % 10 &#x3D; 4; 直接定址: h(k) &#x3D; k array[12] &#x3D; 12; array[13] &#x3D; 13 随机数法: rand(); 哈希冲突: 不同的元素会产生相同的哈希地址 如何处理哈希冲突 开放地址法: 产生冲突的元素存放到空的空间中 邻接表-&gt;图: 在冲突位置创建一个链表 任何有冲突的元素都存到此链表中 数组描述Hash结构:为数据构建关键字:typedef struct Pair &#123; int hash_address; //为数据构建一个关键字,用来产生hash地址 char element[20]; &#125; DATA, *LPDATA; Hash结构:typedef struct HashTable &#123; LPDATA* table; //注意这里是二级指针 int divisor; //除数, 采用取余法 key%p, p就是divisor int hash_size; //当前元素个数 &#125; HASH, *LPHASH; 创建Hash表LPHASH CreateHash(int divisor) &#123; LPHASH p_hash_table = (LPHASH)malloc(sizeof(HASH)); if (NULL == p_hash_table) &#123; return NULL; &#125; //初始化hash表 p_hash_table-&gt;hash_size = 0; p_hash_table-&gt;divisor = divisor; //动态内存申请HashTable p_hash_table-&gt;table = (LPDATA*)malloc(sizeof(LPDATA) * p_hash_table-&gt;divisor); // p_hash_table[i]:一级指针 for (int i = 0; i &lt; p_hash_table-&gt;divisor; ++i) &#123; p_hash_table-&gt;table[i] = NULL; &#125; return p_hash_table; &#125; 获取Hash地址:int SearchHashAddress(LPHASH p_hash_table, int data_address) &#123; //因为存在哈希地址,所以我这里单独封装一个函数做这个事情 int pos = data_address % p_hash_table-&gt;divisor; int cur_pos = pos; //查找结束的结果 do &#123; //没有值就可以存到里面 if (p_hash_table-&gt;table[cur_pos] == NULL || p_hash_table-&gt;table[cur_pos]-&gt;hash_address == data_address) &#123; return cur_pos; &#125; cur_pos = (cur_pos + 1) % p_hash_table-&gt;divisor; &#125; while (cur_pos != pos); return cur_pos; &#125; 向Hash表中插入数据:void InsertData(LPHASH p_hash_table, DATA data) &#123; //求出哈希地址 int pos = SearchHashAddress(p_hash_table, data.hash_address); if (p_hash_table-&gt;table[pos] == NULL) &#123; p_hash_table-&gt;table[pos] = (LPDATA)malloc(sizeof(DATA)); memcpy(p_hash_table-&gt;table[pos], &amp;data, sizeof(DATA)); p_hash_table-&gt;hash_size++; &#125; else &#123; //有元素 if (p_hash_table-&gt;table[pos]-&gt;hash_address == data.hash_address) &#123; //相同关键字采用覆盖方式 strcpy(p_hash_table-&gt;table[pos]-&gt;element, data.element); &#125; else &#123; printf(&quot;空间已满,无法插入\\n&quot;); return; &#125; &#125; &#125; 遍历Hash表与测试数据:void PrintHashTable(LPHASH p_hash_table) &#123; for (int i = 0; i &lt; p_hash_table-&gt;divisor; ++i) &#123; if (p_hash_table-&gt;table[i] == NULL) &#123; printf(&quot;NULL\\n&quot;); &#125; else &#123; printf(&quot;%d:%s\\n&quot;, p_hash_table-&gt;table[i]-&gt;hash_address, p_hash_table-&gt;table[i]-&gt;element); &#125; &#125; &#125; //测试数据 int main(int argc, char** argv) &#123; LPHASH p_hash_table = CreateHash(10); DATA array[5] = &#123;1,&quot;刘亦菲&quot;,12,&quot;王菲&quot;, 11,&quot;王冰冰&quot;,15,&quot;Baby&quot;, 1,&quot;睿睿&quot;&#125;; for (int i = 0; i &lt; 5; ++i) &#123; InsertData(p_hash_table, array[i]); &#125; PrintHashTable(p_hash_table); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-简单封装string类(C++描述)","slug":"数据结构-封装string类(C++描述)","date":"2022-07-04T08:17:52.000Z","updated":"2022-09-04T08:31:44.856Z","comments":true,"path":"2022/07/04/数据结构-封装string类(C++描述)/","link":"","permalink":"http://goskp.github.io/2022/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B0%81%E8%A3%85string%E7%B1%BB(C++%E6%8F%8F%E8%BF%B0)/","excerpt":"","text":"my_string.h:#pragma once #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MyString &#123; public: MyString(); MyString(const char* str); MyString(const MyString&amp; object); ~MyString(); void operator=(const MyString&amp; object); MyString&amp; operator+(const MyString&amp; object); friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MyString&amp; object); friend istream&amp; operator&gt;&gt;(istream&amp; in, MyString&amp; object); int size() const; int empty() const; char operator[](int index); //迭代器部分 char* begin(); char* end(); class iterator &#123; public: void operator=(char* pmove); bool operator!=(char* pmove); iterator&amp; operator++(); char operator*(); protected: char* pmove; &#125;; //比较部分 bool operator==(const MyString&amp; object); private: char* str; //存储字符串的指针 int curSize; //当前长度 // int capacity; //容量 &#125;; my_string.cpp:#include &quot;my_string.h&quot; MyString::MyString() &#123; this-&gt;curSize = 0; this-&gt;str = nullptr; &#125; MyString::MyString(const char* str) &#123; this-&gt;curSize = strlen(str); this-&gt;str = new char[this-&gt;curSize + 1]; strcpy_s(this-&gt;str, this-&gt;curSize + 1, str); &#125; MyString::MyString(const MyString&amp; object) &#123; this-&gt;curSize = object.curSize; this-&gt;str = new char[this-&gt;curSize + 1]; strcpy_s(this-&gt;str, this-&gt;curSize + 1, object.str); &#125; MyString::~MyString() &#123; if (str != nullptr) &#123; delete[] str; str = nullptr; &#125; &#125; void MyString::operator=(const MyString&amp; object) &#123; this-&gt;curSize = object.curSize; this-&gt;str = new char[this-&gt;curSize + 1]; strcpy_s(this-&gt;str, this-&gt;curSize + 1, object.str); &#125; MyString&amp; MyString::operator+(const MyString&amp; object) &#123; // MyString* p = new MyString(strcat(this-&gt;str,object.str)); char* temp = new char[this-&gt;curSize + object.curSize + 1]; memset(temp, 0, this-&gt;curSize + object.curSize + 1); //内存初始化 strcat(temp, this-&gt;str); strcat(temp, object.str); MyString* p = new MyString(temp); delete[] temp; return *p; &#125; int MyString::size() const &#123; return curSize; &#125; int MyString::empty() const &#123; return curSize == 0; &#125; char MyString::operator[](int index) &#123; return this-&gt;str[index]; &#125; char* MyString::begin() &#123; return this-&gt;str; &#125; char* MyString::end() &#123; return this-&gt;str + this-&gt;curSize + 1; &#125; bool MyString::operator==(const MyString&amp; object) &#123; return strcmp(this-&gt;str, object.str) == 0; &#125; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MyString&amp; object) &#123; out &lt;&lt; object.str; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MyString&amp; object) &#123; char temp[1024] = &quot;&quot;; in &gt;&gt; temp; object = MyString(temp); return in; &#125; void MyString::iterator::operator=(char* pmove) &#123; this-&gt;pmove = pmove; &#125; bool MyString::iterator::operator!=(char* pmove) &#123; return this-&gt;pmove != pmove; &#125; MyString::iterator&amp; MyString::iterator::operator++() &#123; this-&gt;pmove++; return *this; &#125; char MyString::iterator::operator*() &#123; return this-&gt;pmove[0]; //等效 return *pmove; &#125; main:#include &lt;string&gt; #include &quot;my_string.h&quot; int main(int argc, char** argv) &#123; // No.1 MyString str1; MyString str2(&quot;ILoveyou&quot;); MyString str3 = str2; //拷贝构造---&gt;深拷贝 // No.2 MyString str4 = &quot;IMiss&quot;; MyString str5; str5 = str4; MyString result; result = str5 + str4; cout &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; str5 &lt;&lt; endl; MyString str6; cin &gt;&gt; str6; cout &lt;&lt; str6 &lt;&lt; endl; // No.3 支持下标 MyString array = &quot;IMissyou&quot;; for (int i = 0; i &lt; array.size(); i++) &#123; cout &lt;&lt; array[i]; &#125; cout &lt;&lt; endl; MyString info = &quot;sdfasdfs&quot;; MyString::iterator it; for (it = info.begin(); it != info.end(); ++it) &#123; cout &lt;&lt; *it; &#125; cout &lt;&lt; endl; cout &lt;&lt; (info == array) &lt;&lt; endl; cout &lt;&lt; (info == info) &lt;&lt; endl; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-串(string,BF,KMP)","slug":"数据结构-串(string,BF,KMP)","date":"2022-07-03T06:36:09.000Z","updated":"2022-10-20T15:00:27.389Z","comments":true,"path":"2022/07/03/数据结构-串(string,BF,KMP)/","link":"","permalink":"http://goskp.github.io/2022/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2(string,BF,KMP)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 串的基本操作(string)串结构:#define MAX_SIZE 1024 typedef struct &#123; char memory[MAX_SIZE]; //串的内存 int cur_size; //当前串的大小 &#125; STR, *LPSTR; 创建串: 初始化串 内存拷贝 更新串的长度 //创建一个串 LPSTR CreateStr(const char* str) &#123; //开内存 LPSTR p_str = (LPSTR)malloc(sizeof(STR)); //防止&#39;\\0&#39;的问题,这里我选择全初始化为&#39;\\0&#39; for (int i = 0; i &lt; MAX_SIZE; ++i) &#123; p_str-&gt;memory[i] = &#39;\\0&#39;; &#125; //形参拷贝到串的内存 int count = 0; //串的长度 while (str[count] != &#39;\\0&#39;) &#123; p_str-&gt;memory[count] = str[count]; count++; &#125; //更新串的长度 p_str-&gt;cur_size = count; return p_str; &#125; 串的插入: 分两种方式 在串后面插新串(push_back) 在串中间插 注意:最后一个元素的下表是p_str-&gt;cursize - 1 (数组下标从0开始) pos是数组下标,这里写的是在pos的下一个位置进行插入 先腾位置(根据插入串的个数来决定) 插入点后面的元素要向后挪动len(插入进来的串长度)个位置 最后插入新串 //串的插入(在当前串插入多个元素) //pos是数组下标,这里写的是在pos的下一个位置进行插入 void InsertStrByPos(LPSTR p_str, const char* str, int str_len, int pos) &#123; //插在下标前面做减操作 // pos -= 1; if (pos &lt; 0 || pos &gt;= MAX_SIZE) &#123; printf(&quot;下标有误,无法插入\\n&quot;); return; &#125; //大于数组容量 if (p_str-&gt;cur_size + str_len &gt;= MAX_SIZE) &#123; printf(&quot;超出串的容量,无法插入\\n&quot;); return; &#125; //插在原来串的后面 if (pos &gt; p_str-&gt;cur_size) &#123; for (int i = 0; i &lt; str_len; ++i) &#123; p_str-&gt;memory[p_str-&gt;cur_size++] = str[i]; &#125; &#125; else &#123; //腾位置 //从最后一个元素开始挪动(p_str-&gt;cursize - 1) for (int i = p_str-&gt;cur_size - 1; i &gt;= pos; i--) &#123; p_str-&gt;memory[str_len + i] = p_str-&gt;memory[i]; &#125; //插入新串 for (int i = 0; i &lt; str_len; ++i) &#123; p_str-&gt;memory[pos + i] = str[i]; &#125; p_str-&gt;cur_size += str_len; &#125; &#125; 串的删除: 这里写的是区间删除,匹配删除在BF算法中在阐述 如何删除: 直接将后面的元素往前移动 置空后面的元素即可 void DeleteStrByIndex(LPSTR p_str, int start_idx, int end_idx) &#123; if (start_idx &lt;= 0 || start_idx &gt; end_idx || end_idx &gt; MAX_SIZE) &#123; printf(&quot;区间有误,无法删除\\n&quot;); return; &#125; int count = end_idx - start_idx + 1; //真实的区间元素个数 //后面的元素往前移动 for (int i = end_idx, j = start_idx - 1; i &lt; p_str-&gt;cur_size; ++i, ++j) &#123; p_str-&gt;memory[j] = p_str-&gt;memory[i]; &#125; //置空后面的元素 for (int i = p_str-&gt;cur_size; i &gt;= p_str-&gt;cur_size - count; --i) &#123; p_str-&gt;memory[i] = &#39;\\0&#39;; &#125; p_str-&gt;cur_size -= count; &#125; 串的遍历: 也可以用%s //串的打印 void PrintStr(LPSTR p_str) &#123; for (int i = 0; i &lt; p_str-&gt;cur_size; ++i) &#123; printf(&quot;%c&quot;, p_str-&gt;memory[i]); &#125; putchar(&#39;\\n&#39;); &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str = CreateStr(&quot;ILoveyou&quot;); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); printf(&quot;插在原来串的后面:\\n&quot;); InsertStrByPos(p_str, &quot;back&quot;, 4, p_str-&gt;cur_size); PrintStr(p_str); printf(&quot;插入XXX:\\n&quot;); InsertStrByPos(p_str, &quot;XXX&quot;, 3, 2); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); printf(&quot;删除1-&gt;3的元素:\\n&quot;); DeleteStrByIndex(p_str, 1, 3); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); return 0; &#125; BF算法: 从父串中找字串,并返回字串的第一个元素位置 父串下标: i , 字串下标: j 从字串的第一个元素开始遍历,并与父串进行匹配 如果不匹配 将字串下标 j 归为0, 字串再从第一个元素与父串进行匹配,并将临时记录序号+1 如果字串的最后一个元素为’\\0’,证明找完了, 返回index + 1 验证的最好方法,代数即可 int BruteForce(LPSTR p_str_one, LPSTR p_str_two) &#123; int index = 0; //临时记录序号,用来返回找到的位置 int i = 0; int j = 0; while (p_str_one-&gt;memory[i] != &#39;\\0&#39; &amp;&amp; p_str_two-&gt;memory[j] != &#39;\\0&#39;) &#123; if (p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; //不匹配, 重新从第一个 ++index; i = index; j = 0; //换第二个位置又从父串第一个位置开始比 &#125; &#125; if (p_str_two-&gt;memory[j] == &#39;\\0&#39;) &#123; return ++index; &#125; return -1; &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str1 = CreateStr(&quot;abcabcacb&quot;); LPSTR p_str2 = CreateStr(&quot;abcac&quot;); printf(&quot;从第%d个元素开始匹配&quot;, BruteForce(p_str1, p_str2)); return 0; &#125; KMP算法: 基本概念: 字符串的”前缀”和”后缀” “前缀”指除了最后一个字符外,一个字符串的全部头部组合; “后缀”指除了第一个字符以外,一个字符串的全部尾组合. 以ABCDABD为例 前缀: A AB ABC ABCD ABCDA ABCDAB 后缀: BCDABD CDABD DABD ABD BD D 部分匹配表 每一个字串里去找前缀和后缀中相同的元素的长度 “A”的前缀和后缀都为空集，共有元素的长度为0； “AB”的前缀为[A]，后缀为[B]， 共有元素的长度为0； “ABC”的前缀为[A, AB]，后缀为[BC, C]， 共有元素的长度0； “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]， 共有元素的长度为0； “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]， 共有元素为”AB”，长度为2； “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]， 共有元素的长度为0。 生成部分匹配表 //获取匹配值 void GetNext(LPSTR p_str, int next[]) &#123; int len = p_str-&gt;cur_size; //用的是数组下标 int i = 0; int j = -1; // 0在这里表示共同元素为0, 有具体的含义,所以初始化为-1了 next[0] = -1; while (i &lt; len) &#123; if (j == -1 || p_str-&gt;memory[i] == p_str-&gt;memory[j]) &#123; ++i; ++j; next[i] = j; //部分匹配元素的长度 &#125; else &#123; j = next[j]; //重置j为-1 &#125; &#125; &#125; int KMP(LPSTR p_str_one, LPSTR p_str_two, int next[]) &#123; //第一个得到表 GetNext(p_str_two, next); int i = 0; int j = 0; while (i &lt; p_str_one-&gt;cur_size &amp;&amp; j &lt; p_str_two-&gt;cur_size) &#123; if (j == -1 || p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if (j == p_str_two-&gt;cur_size) &#123; return i - j; &#125; return -1; &#125; //测试数据 int main(int argc, char** argv) &#123; LPSTR p_str = CreateStr(&quot;ABCDABD&quot;); int next[8]; GetNext(p_str, next); for (int i = 0; i &lt; 8; ++i) &#123; printf(&quot;%d\\t&quot;, next[i]); &#125; putchar(&#39;\\n&#39;); LPSTR p_str_one = CreateStr(&quot;BBC ABCDAB ABCDABCDABDE&quot;); LPSTR p_str_two = CreateStr(&quot;ABCDABD&quot;); printf(&quot;第%d个元素开始匹配\\n&quot;, KMP(p_str_one, p_str_two, next)); putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-队列(queue)","slug":"数据结构-队列(queue)","date":"2022-07-02T07:38:29.000Z","updated":"2022-09-04T08:09:56.752Z","comments":true,"path":"2022/07/02/数据结构-队列(queue)/","link":"","permalink":"http://goskp.github.io/2022/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97(queue)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 队列(FIFO)先进先出const int g_MAX = 10; //队列大小 入队: 队尾往后走 队头不动 出队: 队头往后走 队尾不动 注意:如果做了一次入元素和出元素,会出现伪溢出问题,最大元素个数就不是g_MAX了如何避免伪溢出:做成循环队列通过取余的方式让队尾回到队头描述队列结构:typedef struct &#123; int* p_queue_memory; int q_front; //队头 int q_tail; //队尾 int q_size; //队列大小 &#125; QUEUE, *LPQUEUE; 用数组描述队列://入队 //只需要将数据存到数组中 void Push(LPQUEUE p_queue, int data) &#123; //判断队是否满,空 if (p_queue-&gt;q_tail &gt;= g_MAX || p_queue-&gt;p_queue_memory == NULL) &#123; return; &#125; p_queue-&gt;p_queue_memory[p_queue-&gt;q_tail++] = data; p_queue-&gt;q_size++; &#125; //出队 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_front &lt; p_queue-&gt;q_tail) &#123; p_queue-&gt;q_front++; p_queue-&gt;q_size--; &#125; &#125; //获取队头元素 int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_queue_memory[p_queue-&gt;q_front]; &#125; //判断是否为空 int Empty(LPQUEUE p_queue) &#123; return p_queue-&gt;q_size == 0; &#125; 数组描述循环队列:void Push(LPQUEUE p_queue, int data) &#123; if (p_queue-&gt;q_size == g_MAX) &#123; return; &#125; p_queue-&gt;p_queue_memory[p_queue-&gt;q_tail % g_MAX] = data; p_queue-&gt;q_tail++; p_queue-&gt;q_size++; &#125; //出队 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_size != 0) &#123; p_queue-&gt;q_front = (p_queue-&gt;q_front + 1) % g_MAX; p_queue-&gt;q_size--; &#125; &#125; //获取队头元素 int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_queue_memory[p_queue-&gt;q_front % g_MAX]; &#125; 链式描述队列:typedef struct &#123; int data; struct Node* p_next; &#125; NODE, *LPNODE; typedef struct &#123; LPNODE p_front_node; //队尾 LPNODE p_tail_node; //队头 int q_size; &#125; QUEUE, *LPQUEUE; 创建结点: LPNODE CreateNode(int data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; 创建队列: LPQUEUE CreateQueue() &#123; LPQUEUE p_queue = (LPQUEUE)malloc(sizeof(QUEUE)); if (NULL == p_queue) &#123; return NULL; &#125; p_queue-&gt;p_front_node = NULL; p_queue-&gt;p_tail_node = NULL; p_queue-&gt;q_size = 0; return p_queue; &#125; 相关操作: //入队 //就是无表头链表的表尾法插入 void Push(LPQUEUE p_queue, int data) &#123; LPNODE p_new_node = CreateNode(data); if (0 == p_queue-&gt;q_size) &#123; p_queue-&gt;p_front_node = p_new_node; p_queue-&gt;p_tail_node = p_new_node; &#125; else &#123; p_queue-&gt;p_tail_node-&gt;p_next = p_new_node; p_queue-&gt;p_tail_node = p_new_node; &#125; p_queue-&gt;q_size++; &#125; //出队,表头法删除 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_size != 0) &#123; LPNODE p_next_node = p_queue-&gt;p_front_node-&gt;p_next; free(p_queue-&gt;p_front_node); p_queue-&gt;p_front_node = p_next_node; p_queue-&gt;q_size--; &#125; &#125; int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_front_node-&gt;data; &#125; int Empty(LPQUEUE p_queue) &#123; return p_queue-&gt;q_size == 0; &#125; void DeleteQueue(LPQUEUE p_queue) &#123; while (!Empty(p_queue)) &#123; Pop(p_queue); &#125; free(p_queue); p_queue = NULL; &#125; 优先队列://优先队列 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef int ElementType; #define g_MAX_SIZE 10 typedef struct &#123; int priority; //工作量 ElementType element; //队列中的元素 &#125; DataType; typedef struct &#123; int size; DataType memory[g_MAX_SIZE]; &#125; PQUEUE, *LPQUEUE; LPQUEUE CreateQueue() &#123; LPQUEUE p_queue = (LPQUEUE)malloc(sizeof(PQUEUE)); if (NULL == p_queue) &#123; return NULL; &#125; // p_queue = (DataType*)malloc(sizeof(DataType)); memset(p_queue-&gt;memory, 0, g_MAX_SIZE * sizeof(DataType)); p_queue-&gt;size = 0; return p_queue; &#125; int Empty(LPQUEUE p_queue) &#123; if (p_queue-&gt;size == 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; void Push(LPQUEUE p_queue, DataType data) &#123; if (p_queue-&gt;size &gt;= g_MAX_SIZE) &#123; return; &#125; else &#123; p_queue-&gt;memory[p_queue-&gt;size++] = data; &#125; &#125; void Pop(LPQUEUE p_queue, DataType* data) &#123; DataType min; int min_idx = 0; if (p_queue-&gt;size &lt;= 0) &#123; return; &#125; else &#123; min = p_queue-&gt;memory[0]; for (int i = 1; i &lt; p_queue-&gt;size; ++i) &#123; //当前作业量西小于原来的 if (p_queue-&gt;memory[i].priority &lt; min.priority) &#123; min = p_queue-&gt;memory[i]; min_idx = i; &#125; &#125; *data = p_queue-&gt;memory[min_idx]; //调整数组 for (int i = min_idx + 1; i &lt; p_queue-&gt;size; ++i) &#123; p_queue-&gt;memory[i - 1] = p_queue-&gt;memory[i]; min_idx = i; &#125; p_queue-&gt;size--; &#125; &#125; int main(int argc, char** argv) &#123; LPQUEUE p_queue = CreateQueue(); DataType tmp_data; FILE* fp = fopen(&quot;task.txt&quot;, &quot;r&quot;); while (!feof(fp)) &#123; fscanf(fp, &quot;%d\\t%d\\n&quot;, &amp;tmp_data.element, &amp;tmp_data.priority); Push(p_queue, tmp_data); &#125; int i = 1; //序号 printf(&quot;序号\\t任务\\t优先级啊\\n&quot;); while (!Empty(p_queue)) &#123; Pop(p_queue, &amp;tmp_data); printf(&quot;%d\\t%d\\t%d\\n&quot;, i, tmp_data.element, tmp_data.priority); i++; &#125; putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-栈(stack)","slug":"数据结构-栈(stack)","date":"2022-07-01T12:29:22.000Z","updated":"2022-09-04T08:29:14.832Z","comments":true,"path":"2022/07/01/数据结构-栈(stack)/","link":"","permalink":"http://goskp.github.io/2022/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88(stack)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 栈(FILO)先进后出 入栈 出栈 获取栈顶元素 数组栈: 封装栈单一结构 因为是用数组做的,这里定义一个变量表示数组大小 typedef int TYPE; const TYPE g_MAX = 100; typedef struct Stack &#123; TYPE* memory; //栈的容量 int top; //栈顶标记 &#125; STACK, *LPSTACK; 创建一个栈 用一个结构体指针表示栈 memory是指针变量,所以要二次申请内存 LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;memory = (TYPE*)malloc(sizeof(TYPE) * g_MAX); p_stack-&gt;top = -1; //栈顶标记初始化为-1 return p_stack; &#125; 入栈操作 void PushStack(LPSTACK p_stack, TYPE data) &#123; if (NULL == p_stack || p_stack-&gt;top &gt;= g_MAX) &#123; //栈已满 return; &#125; p_stack-&gt;memory[++p_stack-&gt;top] = data; &#125; 出栈操作 void PopStack(LPSTACK p_stack) &#123; if (NULL == p_stack || p_stack-&gt;top == -1) &#123; return; &#125; //栈顶标记往0靠拢 p_stack-&gt;top--; &#125; 获取栈顶元素 TYPE GetTop(LPSTACK p_stack) &#123; return p_stack-&gt;memory[p_stack-&gt;top]; &#125; 栈是否为空 TYPE GetTop(LPSTACK p_stack) &#123; return p_stack-&gt;memory[p_stack-&gt;top]; &#125; 双端栈: 两个栈使用同一段内存 封装栈结构单一个体 typedef struct Stack &#123; int* memory; int stack_top[2]; //双端栈 &#125; STACK, *LPSTACK; //双端栈的方向 enum Direction &#123; left = 0, right = 1 &#125;; 创建栈 LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;memory = (int*)malloc(sizeof(int) * g_MAX); p_stack-&gt;stack_top[0] = -1; ///左边 p_stack-&gt;stack_top[1] = g_MAX; //右边 return p_stack; &#125; 入栈 要清楚是左边还是右边 void Push(LPSTACK p_stack, int data, int direction) &#123; //左边的标记+1等于右边的标记就满了 if (p_stack-&gt;stack_top[0] + 1 == p_stack-&gt;stack_top[1]) &#123; printf(&quot;栈空间已满\\n&quot;); return; &#125; switch (direction) &#123; case left: p_stack-&gt;memory[++p_stack-&gt;stack_top[0]] = data; break; case right: p_stack-&gt;memory[--p_stack-&gt;stack_top[1]] = data; break; &#125; &#125; 出栈 void Pop(LPSTACK p_stack, int* data, int direction) &#123; switch (direction) &#123; case left: if (p_stack-&gt;stack_top[0] == -1) &#123; return; &#125; *data = p_stack-&gt;memory[p_stack-&gt;stack_top[0]--]; break; case right: if (p_stack-&gt;stack_top[1] == g_MAX) &#123; return; &#125; *data = p_stack-&gt;memory[p_stack-&gt;stack_top[1]++]; break; &#125; &#125; 链式栈 入栈:表头法插入 出栈:表头法删除 封装栈结构单一个体 typedef struct Node &#123; int data; struct Node* p_next; &#125; NODE, *LPNODE; 描述栈结构 typedef struct &#123; LPNODE p_stack_top; int size; &#125; STACK, *LPSTACK; 创建结点,创建栈 LPNODE CreateNode(int data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;p_stack_top = NULL; p_stack-&gt;size = 0; return p_stack; &#125; 入栈,出栈,获取栈顶元素 void Push(LPSTACK p_stack, int data) &#123; LPNODE p_new_node = CreateNode(data); //无头链表的表头法插入 p_new_node-&gt;p_next = p_stack-&gt;p_stack_top; p_stack-&gt;p_stack_top = p_new_node; p_stack-&gt;size++; &#125; //获取栈顶元素 int GetTop(LPSTACK p_stack) &#123; if (p_stack-&gt;size != 0) &#123; return p_stack-&gt;p_stack_top-&gt;data; &#125; return INT_MAX; &#125; //出栈 void Pop(LPSTACK p_stack) &#123; if (p_stack-&gt;size != 0) &#123; LPNODE p_next_node = p_stack-&gt;p_stack_top-&gt;p_next; //保存下一个结点 free(p_stack-&gt;p_stack_top); p_stack-&gt;p_stack_top = p_next_node; p_stack-&gt;size--; &#125; &#125; 括号匹配算法简单实现 //遇到左面的出栈,遇到右面的出栈 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int Match(char* str) &#123; char stak_memory[1024]; int top = -1; //栈顶标记 int i = 0; while (str[i] != &#39;\\0&#39;) &#123; if (str[i] == &#39;)&#39;) &#123; if (top &gt; -1) &#123; top--; &#125; else &#123; return -1; &#125; &#125; else if (str[i] == &#39;(&#39;) &#123; stak_memory[++top] = str[i]; &#125; i++; &#125; if (top == -1) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; int main(int argc, char** argv) &#123; while (1) &#123; char str[1024] = &quot;&quot;; gets(str); int res = Match(str); if (res == 0) &#123; printf(&quot;匹配\\n&quot;); &#125; else if (res == 1) &#123; printf(&quot;多了左边括号\\n&quot;); &#125; else &#123; printf(&quot;多了右边括号\\n&quot;); &#125; &#125; return 0; &#125; 进制转换 //栈应用:进制转化 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;stack&gt; int main(int argc, char** argv) &#123; int stack[100]; int top = -1; int num = 123; //入栈 while (num != 0) &#123; stack[++top] = num % 2; num /= 2; &#125; //出栈获取栈顶元素 while (top != -1) &#123; printf(&quot;%d&quot;, stack[top--]); &#125; putchar(&#39;\\n&#39;); std::stack&lt;int&gt; my_stack; num = 123; while (num != 0) &#123; my_stack.push(num % 2); num /= 2; &#125; while (!my_stack.empty()) &#123; std::cout &lt;&lt; my_stack.top(); my_stack.pop(); &#125; return 0; &#125; 寻路算法 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //人物坐标属性 struct Position &#123; int row; int col; &#125;; //准备栈 struct Position path_stack[100]; // 100步 int stack_top = -1; //标记 //迷宫属性 int** maze = NULL; int size = 0; //创建二维数组 int** CreateArray(int row, int col) &#123; int** array = (int**)malloc(sizeof(int*) * row); for (int i = 0; i &lt; row; ++i) &#123; array[i] = (int*)malloc(sizeof(int) * col); &#125; return array; &#125; void CreateMaze() &#123; printf(&quot;输入迷宫大小:&quot;); scanf(&quot;%d&quot;, &amp;size); maze = CreateArray(size + 2, size + 2); printf(&quot;输入地图:\\n&quot;); for (int i = 1; i &lt;= size; ++i) &#123; for (int j = 1; j &lt;= size; ++j) &#123; scanf(&quot;%d&quot;, &amp;maze[i][j]); &#125; &#125; //边框 // size + 1是最大下标 //假设用 1 表示墙 for (int i = 0; i &lt;= size + 1; ++i) &#123; maze[0][i] = maze[size + 1][i] = 1; //第一行,最后一行 maze[i][0] = maze[i][size + 1] = 1; //第一列,最后一列 &#125; &#125; //寻路的过程 int FindPath() &#123; //准备位移变换 //用0-3表示四个方向 struct Position offset[4]; //往右走 offset[0].row = 0; offset[0].col = 1; //往下走 offset[1].row = 1; offset[1].col = 0; //左 offset[2].row = 0; offset[2].col = -1; //上 offset[3].row = -1; offset[3].col = 0; //选定入口 struct Position here = &#123;1, 1&#125;; //起始位置 maze[1][1] = 1; //下一个方向 int start_dir = 0; //起始方向设定为右边,顺时针转 int end_dir = 3; //终止方向 //出口&#123; size, size &#125; while (here.row != size || here.col != size) &#123; //记录变化 int row_num; int col_num; //试探 while (start_dir &lt;= end_dir) &#123; //行变化: 原位置 + 偏移值 row_num = here.row + offset[start_dir].row; col_num = here.col + offset[start_dir].col; //当试探出一条路,直接走,走过的要入栈 if (0 == maze[row_num][col_num]) &#123; break; //能走就退出循环 &#125; start_dir++; //不能走试探下一个方向 &#125; //能走: if (start_dir &lt;= end_dir) &#123; //走下一个,上一个位置入栈 path_stack[++stack_top] = here; here.row = row_num; here.col = col_num; //走过的地方堵上 maze[row_num][col_num] = 1; //重新试探 start_dir = 0; &#125; else &#123; //出栈 if (-1 == stack_top) &#123; return 0; &#125; //出栈 struct Position next = path_stack[stack_top--]; //方向的处理:要去的方向要改为原来试探过方向的下一个 //提高效率的操作 if (next.row == here.row) &#123; //把方向变成 1 或者 3 start_dir = 2 + next.col - here.col; &#125; else &#123; // 0 2 start_dir = 3 + next.row - here.row; &#125; here = next; &#125; &#125; return 1; &#125; //打印路径 void PrintPath() &#123; printf(&quot;路径:\\n&quot;); struct Position cur_pos; //栈不为空 while (stack_top != -1) &#123; cur_pos = path_stack[stack_top--]; //栈结构,路径是反向的 printf(&quot;(%d,%d)--&gt;&quot;, cur_pos.row, cur_pos.col); &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char** argv) &#123; CreateMaze(); if (FindPath()) &#123; PrintPath(); &#125; else &#123; printf(&quot;没有找到路径\\n&quot;); &#125; return 0; &#125; /* 测试数据: 输入迷宫大小:6 输入地图: 0 1 0 1 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1 0 0 0 0 1 1 1 1 0 0 1 1 1 1 1 0 0 */","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-顺序表(list)","slug":"数据结构-顺序表(list)","date":"2022-06-30T04:46:33.000Z","updated":"2022-09-04T08:09:36.415Z","comments":true,"path":"2022/06/30/数据结构-顺序表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 顺序表(有序插入结点)与链表大差不大,只是存一下代码,不做详细解释了, 链表如果理解的透彻,顺序表就如探囊取物数组描述: 元素容量: #define MAX 2 元素数据类型: struct MM &#123; char name[20]; int age; &#125;; struct Data &#123; int index; //序号 struct MM mm_data; &#125;; //顺序表的结构体 typedef struct SqList &#123; int sqlist_size; //顺序表中元素个数 struct Data* p_memory; &#125; SQLIST, *LPSQLIST; 创建顺序表: LPSQLIST CreateSqList() &#123; LPSQLIST p_sqlist = (LPSQLIST)malloc(sizeof(SQLIST)); if (NULL == p_sqlist) &#123; return NULL; &#125; p_sqlist-&gt;sqlist_size = 0; p_sqlist-&gt;p_memory = (struct Data*)malloc(sizeof(struct Data) * MAX); return p_sqlist; &#125; 开辟更多内存 void ReallocMemory(LPSQLIST p_sqlist, int cur_size, int new_size) &#123; printf(&quot;开辟更多内存\\n&quot;); int max_size = cur_size &gt; new_size ? cur_size : new_size; p_sqlist-&gt;p_memory = (struct Data*)realloc(p_sqlist-&gt;p_memory, sizeof(struct Data) * max_size); &#125; 结点插入顺序表 void InsertData(LPSQLIST p_sqlist, struct Data new_data) &#123; //元素个数已满,内存重新申请为当前大小的两倍 if (MAX == p_sqlist-&gt;sqlist_size) &#123; ReallocMemory(p_sqlist, MAX, 2 * MAX); &#125; //直接插在表尾 p_sqlist-&gt;p_memory[p_sqlist-&gt;sqlist_size] = new_data; //调整位置 //后面的和前面的相比 for (int i = p_sqlist-&gt;sqlist_size; i &gt;= 0; --i) &#123; if (p_sqlist-&gt;p_memory[i - 1].index &gt; p_sqlist-&gt;p_memory[i].index) &#123; struct Data tmp = p_sqlist-&gt;p_memory[i - 1]; p_sqlist-&gt;p_memory[i - 1] = p_sqlist-&gt;p_memory[i]; p_sqlist-&gt;p_memory[i] = tmp; &#125; else &#123; break; &#125; &#125; //元素个数+1 p_sqlist-&gt;sqlist_size++; &#125; 删除顺序表 因为顺序表本身就有顺序,所以只需挪位置即可,移动元素 void DeleteData(LPSQLIST p_sqlist, int del_index) &#123; //找到删除元素的下标 int del_pos = -1; for (int i = 0; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; if (p_sqlist-&gt;p_memory[i].index == del_index) &#123; del_pos = i; break; &#125; &#125; //调整数组 if (del_pos == -1) &#123; printf(&quot;未找到指定元素&quot;); return; &#125; else &#123; //数组后面的元素往前移动 for (int i = del_pos; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; p_sqlist-&gt;p_memory[i] = p_sqlist-&gt;p_memory[i + 1]; &#125; //元素个数-1 p_sqlist-&gt;sqlist_size--; &#125; &#125; 遍历顺序表 void PrintSqList(LPSQLIST p_sqlist) &#123; for (int i = 0; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; printf(&quot;序号:%d\\t名字:%s\\t年龄:%d\\n&quot;, p_sqlist-&gt;p_memory[i].index, p_sqlist-&gt;p_memory[i].mm_data.name, p_sqlist-&gt;p_memory[i].mm_data.age); &#125; putchar(&#39;\\n&#39;); &#125; 链表描述: 元素数据类型: struct MM &#123; char name[20]; int age; &#125;; struct Data &#123; int index; struct MM mm_data; &#125;; typedef struct Node &#123; struct Data data; struct Node* p_next; &#125; NODE, *LPNODE; typedef struct SqList &#123; int sql_size; LPNODE p_head_node; &#125; SQLIST, *LPSQLIST; LPNODE CreateList() &#123; LPNODE p_head_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_head_node) &#123; return NULL; &#125; p_head_node-&gt;p_next = NULL; return p_head_node; &#125; LPNODE CreateNode(struct Data new_data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //创建顺序表 LPSQLIST CreateSqList() &#123; LPSQLIST p_sqlist = (LPSQLIST)malloc(sizeof(SQLIST)); if (NULL == p_sqlist) &#123; return NULL; &#125; p_sqlist-&gt;sql_size = 0; p_sqlist-&gt;p_head_node = CreateList(); return p_sqlist; &#125; void PrintSqList(LPSQLIST p_sqlist) &#123; LPNODE p_move = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d\\t姓名:%s\\t年龄:%d\\n&quot;, p_move-&gt;data.index, p_move-&gt;data.mm_data.name, p_move-&gt;data.mm_data.age); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; void InsertData(LPSQLIST p_sqlist, struct Data new_data) &#123; LPNODE p_new_node = CreateNode(new_data); //找到指定位置 LPNODE p_pre_node = p_sqlist-&gt;p_head_node; LPNODE p_pos_node = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_pos_node &amp;&amp; p_pos_node-&gt;data.index &lt; new_data.index) &#123; p_pre_node = p_pos_node; p_pos_node = p_pre_node-&gt;p_next; &#125; // if (NULL == p_pos_node) &#123; // p_pre_node-&gt;p_next = p_new_node; // &#125; else &#123; // p_pre_node-&gt;p_next = p_new_node; // p_new_node-&gt;p_next = p_pos_node; // &#125; p_pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = p_pos_node; p_sqlist-&gt;sql_size++; &#125; void DeleteNode(LPSQLIST p_sqlist, int index) &#123; LPNODE p_pre_node = p_sqlist-&gt;p_head_node; LPNODE p_pos_node = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_pos_node &amp;&amp; p_pos_node-&gt;data.index != index) &#123; p_pre_node = p_pos_node; p_pos_node = p_pos_node-&gt;p_next; &#125; if (NULL == p_pos_node) &#123; printf(&quot;未找到数据&quot;); return; &#125; else &#123; p_pre_node-&gt;p_next = p_pos_node-&gt;p_next; free(p_pos_node); p_pos_node = NULL; p_sqlist-&gt;sql_size--; &#125; &#125; 测试数据: LPSQLIST p_sqlist = CreateSqList(); struct Data array[4] = &#123;3, &quot;小红&quot;, 18, 1, &quot;小明&quot;, 14, 0, &quot;雨墨&quot;, 18, 2, &quot;小asd&quot;, 4&#125;; for (int i = 0; i &lt; 4; ++i) &#123; InsertData(p_sqlist, array[i]); &#125; PrintSqList(p_sqlist); printf(&quot;删除序号为3的结点:\\n&quot;); DeleteNode(p_sqlist, 3); PrintSqList(p_sqlist);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-合并,反转,有序链表(list)","slug":"数据结构-合并,反转,有序链表(list)","date":"2022-06-29T02:40:49.000Z","updated":"2022-09-04T08:09:22.146Z","comments":true,"path":"2022/06/29/数据结构-合并,反转,有序链表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%90%88%E5%B9%B6,%E5%8F%8D%E8%BD%AC,%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 注意:阅读本篇博客前请先学会”基础单链表”找两个链表中的相同元素组成第三个链表如何合并: 遍历两个链表,找到相同元素 调用一种插入方式即可 插入方式 void InsertNode(struct Node* p_list, int new_data) &#123; struct Node* p_new_node = CreateNewNode(new_data); p_new_node-&gt;p_next = p_list-&gt;p_next; p_list-&gt;p_next = p_new_node; &#125; 取交集,将两个链表中的相同元素合并为第三个链表 void Intersection(struct Node* p_list_one, struct Node* p_list_two, struct Node* p_list_three) &#123; for (struct Node* p_first = p_list_one-&gt;p_next; NULL != p_first; p_first = p_first-&gt;p_next) &#123; for (struct Node* p_second = p_list_two-&gt;p_next; NULL != p_second; p_second = p_second-&gt;p_next) &#123; if (p_first-&gt;data == p_second-&gt;data) &#123; InsertNode(p_list_three, p_second-&gt;data); &#125; &#125; &#125; &#125; 反转链表 第一种方法: 创建一个临时链表 遍历当前链表,将结点逆序插入到临时链表中 释放原有链表内存 指向新链表 代码如下: //释放链表 void FreeList(struct Node** p_list) &#123; if (NULL == p_list) &#123; return; &#125; struct Node* p_next_node = NULL; while (NULL != *p_list) &#123; p_next_node = (*p_list)-&gt;p_next; free(*p_list); *p_list = p_next_node; &#125; &#125; //反转链表第一种方法 void ReverseFirstWay(struct Node** p_list) &#123; struct Node* p_tmp_list = CreateList(); struct Node* p_move = (*p_list)-&gt;p_next; while (NULL != p_move) &#123; InsertNode(p_tmp_list, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; //释放原有的内存 FreeList(p_list); *p_list = p_tmp_list; //指向新的链表 &#125; 第二种方法(节省空间) 思路: 将每一个结点的p_next指针反转 第一个结点指向最后一个结点 实现: 第一个结点的前驱结点用空表示(p_pre_node &#x3D;&#x3D; NULL) 第一个结点的p_next指针指向前驱结点,而前驱结点是NULL,导致下一个结点就找不到了 所以在更改当前结点的指向之前应当先保存下一个结点(p_next_node &#x3D; p_cur_node-&gt;p_next;) 后面的结点也要做以上相同的事情 前驱结点变成当前结点 当前结点变成下一个结点 表头指向最后一个结点 实现代码如下: void ReverseSecondWay(struct Node** p_list) &#123; struct Node* p_pre_node = NULL; //前驱结点 struct Node* p_cur_node = (*p_list)-&gt;p_next; //当前结点 struct Node* p_next_node = (*p_list)-&gt;p_next; //当前结点的下一个结点 while (NULL != p_cur_node) &#123; p_next_node = p_cur_node-&gt;p_next; //保存下一个结点 p_cur_node-&gt;p_next = p_pre_node; //当前结点的p_next指针指向前驱结点 p_pre_node = p_cur_node; //前驱结点变成当前结点 p_cur_node = p_next_node; //当前结点变成下一个结点 &#125; (*p_list)-&gt;p_next = p_pre_node; //表头指向最后一个结点 &#125; 有序链表 再插入结点时让链表有序,这个比较简单,看一眼就可以了 /* @author: KaiPeng_Sun @Time: 2022年7月11日18:22:13 @brief: 有序链表 @message: 代码的上一行为所写注释 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct data &#123; int index; //构建序号 int data; //数据 &#125;; struct Node &#123; struct data my_data; struct Node* p_next; &#125;; //创建有头链表 struct Node* CreateList() &#123; struct Node* p_list = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_list) &#123; return NULL; &#125; //初始化头结点 p_list-&gt;p_next = NULL; return p_list; &#125; //创建结点 struct Node* CreateNewNode(struct data my_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化结点数据 p_new_node-&gt;my_data = my_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void InsertOrderList(struct Node* p_list, struct data my_data) &#123; struct Node* p_new_node = CreateNewNode(my_data); struct Node* pre_node = p_list; //前驱结点 struct Node* cur_node = p_list-&gt;p_next; //当前结点 //升序 while (NULL != cur_node &amp;&amp; cur_node-&gt;my_data.index &lt; my_data.index) &#123; pre_node = cur_node; cur_node = pre_node-&gt;p_next; &#125; if (NULL == cur_node) &#123; pre_node-&gt;p_next = p_new_node; &#125; else &#123; pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = cur_node; &#125; &#125; void PrintList(struct Node* p_list) &#123; struct Node* p_move = p_list-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d,数据:%d\\n&quot;, p_move-&gt;my_data.index, p_move-&gt;my_data.data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char* argv[]) &#123; //五对数据,两个两个是一对 struct data array[5] = &#123;2, 1, 5, 3, 6, 8, 7, 10, 11, 0&#125;; struct Node* p_list = CreateList(); for (int i = 0; i &lt; 5; ++i) &#123; InsertOrderList(p_list, array[i]); &#125; PrintList(p_list); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-双向链表(list)","slug":"数据结构-双向链表(list)","date":"2022-06-28T02:34:06.000Z","updated":"2022-09-04T08:09:17.241Z","comments":true,"path":"2022/06/28/数据结构-双向链表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 双向链表本篇博客中变量采用如下命名方式://结点类型,单一个体 typedef struct Node &#123; int data; struct Node* p_left; //指向左面的结点 struct Node* p_right; //指向右面的结点 &#125; NODE, *LPNODE; //链表类型 typedef struct List &#123; LPNODE p_head_node; //头结点 LPNODE p_tail_node; //尾结点 int size; //当前链表中结点个数 &#125; LIST, *LPLIST; 熟悉的套路:创建结点,创建链表//创建结点 LPNODE CreateNode(int new_data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_left = NULL; p_new_node-&gt;p_right = NULL; return p_new_node; &#125; //创建链表 LPLIST CreateList() &#123; LPLIST p_new_list = (LPLIST)malloc(sizeof(LIST)); if (NULL == p_new_list) &#123; return NULL; &#125; p_new_list-&gt;size = 0; p_new_list-&gt;p_head_node = NULL; p_new_list-&gt;p_tail_node = NULL; return p_new_list; &#125; 表头法插入,在有头结点前插入新节点 先判断链表中结点个数是否为空,为空则直接将头&#x2F;尾结点赋为新节点 链表不为空: 新节点的新节点的右指针指向头结点 头结点的左指针指向新结点 头结点变为新结点 结点个数+1 实现代码如下: void InsertNewNodeByHead(int new_data, LPLIST p_list) &#123; LPNODE p_new_node = CreateNode(new_data); if (p_list-&gt;size == 0) &#123; //链表为空 p_list-&gt;p_tail_node = p_new_node; // p_list-&gt;p_head_node = p_new_node; &#125; else &#123; p_new_node-&gt;p_right = p_list-&gt;p_head_node; p_list-&gt;p_head_node-&gt;p_left = p_new_node; // p_list-&gt;p_head_node = p_new_node; &#125; p_list-&gt;p_head_node = p_new_node; //头结点变成新结点 p_list-&gt;size++; &#125; 表尾法插入,在尾结点后插入新结点 和表头法插入大同小异 void InsertNewNodeByTail(int new_data, LPLIST p_list) &#123; LPNODE p_new_node = CreateNode(new_data); if (p_list-&gt;size == 0) &#123; p_list-&gt;p_head_node = p_new_node; // p_list-&gt;p_tail_node = p_new_node; &#125; else &#123; p_new_node-&gt;p_left = p_list-&gt;p_tail_node; p_list-&gt;p_tail_node-&gt;p_right = p_new_node; // p_list-&gt;p_tail_node = p_new_node; &#125; p_list-&gt;p_tail_node = p_new_node; p_list-&gt;size++; &#125; 指定位置插入 和单链表的指定位置插入类似 也是采用双结点遍历整个链表,因为两个结点能确定另一个结点 插入的方式: 前驱结点的右指针指向新结点 新结点的左指针指向前驱结点 新结点的右指针指向当前结点 当前结点的左指针指向新结点 结点个数+1 void InsertByPosData(LPLIST p_list, int new_data, int pos_data) &#123; LPNODE pos_front = NULL; LPNODE pos_node = p_list-&gt;p_head_node; //遍历寻找指定结点 while (NULL != pos_node &amp;&amp; pos_node-&gt;data != pos_data) &#123; pos_front = pos_node; pos_node = pos_front-&gt;p_right; &#125; if (NULL == pos_node) &#123; printf(&quot;未找到指定结点&quot;); return; &#125; else &#123; //表头法插入 if (NULL == pos_front) &#123; InsertNewNodeByHead(new_data, p_list); &#125; else &#123; //指定结点插入 LPNODE p_new_node = CreateNode(new_data); pos_front-&gt;p_right = p_new_node; p_new_node-&gt;p_left = pos_front; p_new_node-&gt;p_right = pos_node; pos_node-&gt;p_left = p_new_node; p_list-&gt;size++; &#125; &#125; &#125; 遍历双向链表(看一眼就行了,和单链表遍历一个道理) 顺序遍历 void OrderPrintList(LPLIST p_list) &#123; LPNODE p_move = p_list-&gt;p_head_node; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_right; &#125; putchar(&#39;\\n&#39;); &#125; 逆序遍历 void ReverseOrderPrintList(LPLIST p_list) &#123; LPNODE p_move = p_list-&gt;p_tail_node; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_left; &#125; putchar(&#39;\\n&#39;); &#125; 双向循环链表 这里我就写了一个表尾法插入,有时间在写别的,其实都大同小异 注意:不需要找表尾,表尾就是默认头结点的p_left指针所指向的位置 也就是说,我们用头结点来描述尾结点 如何插入: 头结点的左指针的结点的右指针指向新结点 新结点的左指针指向头结点的左指针指向的结点 新结点的右指针指向头结点 头结点的左指针指向新结点 void InsertNewNodeByTail(LPNODE p_head_node, int new_data) &#123; LPNODE p_new_node = CreateNode(new_data); //换了一种方式表示表尾,用表头的左指针表示表尾 // p_head_node-&gt;p_left-&gt;p_right = p_new_node //也就是说表尾-&gt;p_right = p_new_node; p_head_node-&gt;p_left-&gt;p_right = p_new_node; p_new_node-&gt;p_left = p_head_node-&gt;p_left; // p_new_node-&gt;p_left = p_head_node-&gt;p_left // p_new_node-&gt;p_left等价于表尾 p_new_node-&gt;p_right = p_head_node; p_head_node-&gt;p_left = p_new_node; &#125; 遍历双向循环链表 因为是环形的,所以不能用老规矩(NULL结束遍历) 只需要遍历一圈,再走到头结点结束遍历即可 顺序遍历 void OrderPrintList(LPNODE p_head_node) &#123; //因为是环形的,所以不能用老规矩(NULL结束遍历) //只需要遍历一圈,再走到头结点结束遍历即可 LPNODE p_move = p_head_node-&gt;p_right; while (p_head_node != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_right; &#125; putchar(&#39;\\n&#39;); &#125; 逆序遍历 void ReverseOrderPrintList(LPNODE p_head_node) &#123; LPNODE p_move = p_head_node-&gt;p_left; while (p_head_node != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_left; &#125; putchar(&#39;\\n&#39;); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-基础单链表(list)","slug":"数据结构-基础单链表(list)","date":"2022-06-27T12:54:15.000Z","updated":"2022-09-03T00:14:19.271Z","comments":true,"path":"2022/06/27/数据结构-基础单链表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E5%8D%95%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 博客中所有关于链表的代码命名方式如下//结点类型 struct Node &#123; int data; struct Node* p_next; //指向下一个结点的结构体指针 &#125;; int new_data; //插入的新数据 struct Node* p_pre_node; //前驱结点 struct Node* p_cur_node; //当前结点 struct Node* p_new_node; //新节点 struct Node* p_move; //移动结构体指针,用于遍历链表 struct Node* p_list; //链表 struct Node** p_list; //链表 初识链表: //创建三个结点 struct Node node1 = &#123;1, NULL&#125;; struct Node node2 = &#123;2, NULL&#125;; struct Node node3 = &#123;3, NULL&#125;; //将结点连接在一起,形成链表 node1.p_next = &amp;node2; node2.p_next = &amp;node3; //遍历链表 struct Node* p_move = &amp;node1; printf(&quot;第一个节点数据:%d\\n&quot;, p_move-&gt;data); printf(&quot;第二个节点数据:%d\\n&quot;, p_move-&gt;p_next-&gt;data); printf(&quot;第三个节点数据:%d\\n&quot;, p_move-&gt;p_next-&gt;p_next-&gt;data); //上面不太方便，用循环来做 while (p_move != NULL) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; 链式结构基础操作 创建表头 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct data &#123; int index; //构建序号 int data; //数据 &#125;; struct Node &#123; struct data my_data; struct Node* p_next; &#125;; //创建有头链表 struct Node* CreateList() &#123; struct Node* p_list = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_list) &#123; return NULL; &#125; //初始化头结点 p_list-&gt;p_next = NULL; return p_list; &#125; //创建结点 struct Node* CreateNewNode(struct data my_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化结点数据 p_new_node-&gt;my_data = my_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void InsertOrderList(struct Node* p_list, struct data my_data) &#123; struct Node* p_new_node = CreateNewNode(my_data); struct Node* pre_node = p_list; //前驱结点 struct Node* cur_node = p_list-&gt;p_next; //当前结点 //升序 while (NULL != cur_node &amp;&amp; cur_node-&gt;my_data.index &lt; my_data.index) &#123; pre_node = cur_node; cur_node = pre_node-&gt;p_next; &#125; if (NULL == cur_node) &#123; pre_node-&gt;p_next = p_new_node; &#125; else &#123; pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = cur_node; &#125; &#125; void PrintList(struct Node* p_list) &#123; struct Node* p_move = p_list-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d,数据:%d\\n&quot;, p_move-&gt;my_data.index, p_move-&gt;my_data.data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char* argv[]) &#123; //五对数据,两个两个是一对 struct data array[5] = &#123;2, 1, 5, 3, 6, 8, 7, 10, 11, 0&#125;; struct Node* p_list = CreateList(); for (int i = 0; i &lt; 5; ++i) &#123; InsertOrderList(p_list, array[i]); &#125; PrintList(p_list); return 0; &#125; 创建新节点 有头和无头的区别就在于头结点的data有没有存放数据罢了 //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(int new_data) &#123; struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == new_node) &#123; return NULL; &#125; //初始化新结点 new_node-&gt;data = new_data; new_node-&gt;p_next = NULL; return new_node; &#125; 遍历链表 void PrintList(struct Node* p_head_node) &#123; //定义移动指针,因为头结点不存储数据,所以直接指向头结点的下一个结点 struct Node* p_move = p_head_node-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; 在头结点的前驱位置(头结点前面)插入新结点 新结点的p_next指针指向头结点 新结果点赋值给头结点 void InsertNewNodeByHead(struct Node** p_head, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = *p_head; *p_head = p_new_node; &#125; 在头结点与下一个结点之间插入新结点 新节点的p_next指针指向头结点的p_next指针(换句话说就是新结点的p_next指针指向头结点的下一个结点) 头结点的p_next指针指向新结点 注意:这种插入方式会导致插入结点的顺序与遍历结点的顺序相反 void InsertNewNodeByHead(struct Node* p_head_node, int new_data) &#123; //调用生成新结点函数 struct Node* p_new_node = CreateNewNode(new_data); //表头法插入 p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; &#125; 在尾结点后插入新结点 遍历找到尾结点 尾结点的p_next指针指向新结点 void InsertNewNodeByTail(struct Node* p_head_node, int new_data) &#123; struct Node* p_new_node = CreateNewNode(new_data); struct Node* p_tail_node = p_head_node; //找到尾结点 while (NULL != p_tail_node-&gt;p_next) &#123; p_tail_node = p_tail_node-&gt;p_next; &#125; //表尾法插入 p_tail_node-&gt;p_next = p_new_node; &#125; 指定位置插入(以数据作为参照),数据指data 遍历找到data(这里以第一次出现data终止遍历) 前驱结点的p_next指针指向新结点 新结点的p_next指针指向当前结点 void InsertByDataValue(struct Node* p_head_node, int data_value, int new_data) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; // 注意:条件不能交换(短路现象) // p_p_cur_node == NULL,NULL-&gt;data // 判断是否为所寻找的数据的前提是p_p_cur_node!=NULL while (p_cur_node != NULL &amp;&amp; p_cur_node-&gt;data != data_value) &#123; // p_p_pre_node = p_p_pre_node-&gt;p_next; // p_p_cur_node = p_p_cur_node-&gt;p_next; // 下面的写法更能够体现相邻的特色 p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; //分析结果 if (NULL == p_cur_node) &#123; printf(&quot;没有找到指定结点,无法插入\\n&quot;); &#125; else &#123; struct Node* new_node = CreateNewNode(new_data); p_pre_node-&gt;p_next = new_node; new_node-&gt;p_next = p_cur_node; &#125; &#125; 指定位置插入(以第几个结点作为参照) 注意: 若传入函数的下标为4,则是在3的位置插入 遍历找到指定位置 前驱结点的p_next指针指向新结点 新结点的p_next指针指向当前结点 void InsertByNodeIndex(struct Node* p_head_node, int node_index, int new_data) &#123; if (node_index &lt; 0) &#123; printf(&quot;序号有问题,无法插入\\n&quot;); return; &#125; //因为是不存在第0个元素的 int count = 1; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; while (p_cur_node != NULL &amp;&amp; count &lt; node_index) &#123; p_pre_node = p_cur_node; p_cur_node = p_cur_node-&gt;p_next; ++count; &#125; if (NULL == p_cur_node) &#123; printf(&quot;序号有问题,无法插入\\n&quot;); &#125; else &#123; struct Node* new_node = CreateNewNode(new_data); p_pre_node-&gt;p_next = new_node; new_node-&gt;p_next = p_cur_node; &#125; &#125; 删除头结点(实质是删除头结点的下一个结点) 头结点的p_next指针指向下一个结点的p_next指针 释放结点内存 结点置为空 void DeleteByHead(struct Node* p_head_node) &#123; struct Node* p_next_node = p_head_node-&gt;p_next; //防御性编程 if (NULL == p_head_node || NULL == p_next_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; else &#123; p_head_node-&gt;p_next = p_next_node-&gt;p_next; free(p_next_node); p_next_node = NULL; &#125; &#125; 删除尾结点 遍历找到尾结点 前驱结点的p_next指向空 释放尾结点内存 结点置为空 void DeleteByTail(struct Node* p_head_node) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_tail_node = p_head_node-&gt;p_next; if (NULL == p_head_node || p_tail_node == NULL) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; while (NULL != p_tail_node-&gt;p_next) &#123; p_pre_node = p_tail_node; p_tail_node = p_pre_node-&gt;p_next; &#125; //将尾结点置为空 p_pre_node-&gt;p_next = NULL; free(p_tail_node); p_tail_node = NULL; &#125; 通过data删除指定位置结点 遍历找到data 前驱结点的p_next指针指向当前结点的p_next指针 释放当前结点 结点置为空 void DeleteByNodeIndex(struct Node* p_head_node, int data_value) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; if (NULL == p_head_node || NULL == p_cur_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; while (NULL != p_cur_node &amp;&amp; p_cur_node-&gt;data != data_value) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (NULL == p_cur_node) &#123; printf(&quot;未找到指定结点\\n&quot;); &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; free(p_cur_node); p_cur_node = NULL; &#125; &#125; 寻找结点 遍历链表 返回struct Node* 类型结点 struct Node* SearchNode(struct Node* p_head_node, int data_value) &#123; struct Node* p_move = p_head_node-&gt;p_next; while (NULL != p_move &amp;&amp; p_move-&gt;data != data_value) &#123; p_move = p_move-&gt;p_next; &#125; return p_move; &#125; 删除所有相同的结点 void DeleteAllSameNode(struct Node* p_head_node, int data_value) &#123; while (NULL != SearchNode(p_head_node, data_value)) &#123; DeleteByNodeIndex(p_head_node, data_value); &#125; &#125; 销毁链表 传入二级指针 *p_head_node就代表一个结点 结点置为空 void DestoryList(struct Node** p_head_node) &#123; while (NULL != (*p_head_node)-&gt;p_next) &#123; DeleteByHead(*p_head_node); &#125; free(*p_head_node); *p_head_node = NULL; &#125; 没经过优化的版本(C风格)#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define IS_LIST 0 struct Node &#123; int data; struct Node* p_next; &#125;; #if IS_LIST struct List &#123; struct Node* p_root; &#125;; #endif #if IS_LIST void InitList(struct List* p_list); #endif struct Node* CreateNode(int new_data); #if IS_LIST void AppendNode(struct List* p_list, int new_data); #else void AppendNode(struct Node** p_head_node, int new_data); #endif #if IS_LIST void PrintList(struct List* p_list); #else void PrintList(struct Node* p_head); #endif #if IS_LIST #else void InsertNewNodeByHead(struct Node** p_head, int new_data); #endif #if IS_LIST //中间插入 void InsertPosNode(struct List* p_list, int pos, int new_data); #else void InsertPosNode(struct Node** head, int pos, int new_data); #endif void DeletePosNode(struct Node** p_head, int pos); void DeleteHeadNode(struct Node** p_head); int main(int argc, char** argv) &#123; #if IS_LIST struct List list; InitList(&amp;list); for (int i = 0; i &lt; 10; ++i) &#123; AppendNode(&amp;list, i); &#125; PrintList(&amp;list); #else struct Node* p_head = NULL; for (int i = 0; i &lt; 10; ++i) &#123; InsertNewNodeByHead(&amp;p_head, i); PrintList(p_head); &#125; InsertPosNode(&amp;p_head, 2, 666); PrintList(p_head); #endif return 0; &#125; #if IS_LIST void InitList(struct List* p_list) &#123; p_list-&gt;p_root = NULL; &#125; #endif struct Node* CreateNode(int new_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; #if IS_LIST void AppendNode(struct List* p_list, int new_data) &#123; if (NULL == p_list) &#123; return; &#125; struct Node* p_new_node = CreateNode(new_data); if (NULL == p_new_node) &#123; return; &#125; if (p_list-&gt;p_root) &#123; struct Node* p_tmp = p_list-&gt;p_root; while (NULL != p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new_node; &#125; else &#123; p_list-&gt;p_root = p_new_node; &#125; &#125; #else void AppendNode(struct Node** p_head_node, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); if (NULL == p_new_node) &#123; return; &#125; if (*p_head_node) &#123; struct Node* p_tmp = *p_head_node; while (NULL != p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new_node; &#125; else &#123; *p_head_node = p_new_node; &#125; &#125; #endif #if IS_LIST void PrintList(struct List* p_list) &#123; struct Node* p_tmp = p_list-&gt;p_root; printf(&quot;list: &quot;); while (p_tmp) &#123; printf(&quot;%d &quot;, p_tmp-&gt;data); p_tmp = p_tmp-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; #else void PrintList(struct Node* p_head) &#123; struct Node* p_tmp = p_head; printf(&quot;list: &quot;); while (p_tmp) &#123; printf(&quot;%d &quot;, p_tmp-&gt;data); p_tmp = p_tmp-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; #endif #if IS_LIST #else void InsertNewNodeByHead(struct Node** p_head, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = *p_head; *p_head = p_new_node; &#125; #endif //从head链表中找到pos结点并返回,找不到返回NULL struct Node* FindPos(struct Node* p_head_node, int pos) &#123; if (NULL == p_head_node) &#123; return NULL; &#125; struct Node* p_tmp = p_head_node; for (int i = 0; i &lt; pos; ++i) &#123; if (NULL == p_tmp) &#123; return NULL; &#125; p_tmp = p_tmp-&gt;p_next; &#125; return p_tmp; &#125; #if IS_LIST //中间插入 void InsertPosNode(struct List* p_list, int pos, int new_data) &#123;&#125; #else void InsertPosNode(struct Node** head, int pos, int new_data) &#123; if (NULL == *head) &#123; return; &#125; if (NULL == *head || 0 == pos) &#123; AppendNode(head, new_data); &#125; //这里我写的是以数组下标为基准插入,所以pos - 1 struct Node* p_tmp = FindPos(*head, pos - 1); struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = p_tmp-&gt;p_next; p_tmp-&gt;p_next = p_new_node; &#125; #endif //删除链表中第一个节点 void DeleteHeadNode(struct Node** p_head) &#123; if (NULL == p_head) &#123; return; &#125; //临时存储要删的节点 struct Node* p_del = *p_head; //*head 的下一个节点要成为新的头节点 *p_head = (*p_head)-&gt;p_next; //释放内存 free(p_del); &#125; //删除链表中第pos个节点 void DeletePosNode(struct Node** p_head, int pos) &#123; if (NULL == p_head || pos &lt; 0) &#123; return; &#125; if (0 == pos) &#123; DeleteHeadNode(p_head); return; &#125; //临时存储pos节点地址 struct Node* p_del = FindPos(*p_head, pos); if (NULL == p_del) &#123; return; &#125; //先找到pos-1节点 struct Node* p_del_prev = FindPos(*p_head, pos - 1); if (NULL == p_del_prev) &#123; return; &#125; // pos-1节点的next指针指向pos的下一个节点 p_del_prev-&gt;p_next = p_del-&gt;p_next; //释放pos节点内存 free(p_del); &#125; 没经过优化的版本(C++风格)#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyList &#123; private: struct Node &#123; T data; Node* p_next; Node() &#123;&#125; Node(const T&amp; data) &#123; this-&gt;data = data; p_next = nullptr; &#125; &#125;; Node* p_head; public: MyList() &#123; p_head = NULL; &#125; void AppendNode(const T&amp; new_data); //尾插 void AddNode(const T&amp; new_data); //头插 void InsertNode(int pos, int new_data); //中间插 void Traver(); //遍历 void DeletePosNode(int pos); //删除特定结点 void DeleteHeadNode(); //删除头结点 private: Node* _FindPos(int pos); &#125;; template &lt;class T&gt; void MyList&lt;T&gt;::AppendNode(const T&amp; new_data) &#123; Node* p_new = new Node(new_data); Node* p_tmp = p_head; if (p_tmp) &#123; while (p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new; &#125; else &#123; p_head = p_new; &#125; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::AddNode(const T&amp; new_data) &#123; Node* p_new = new Node(new_data); p_new-&gt;p_next = p_head; p_head = p_new; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::InsertNode(int pos, int new_data) &#123; if (pos &lt; 0) &#123; return; &#125; if (nullptr == p_head || 0 == pos) &#123; AddNode(new_data); &#125; Node* p_new = new Node(new_data); Node* p_prev = _FindPos(pos); p_new-&gt;p_next = p_prev-&gt;p_next; p_prev-&gt;p_next = p_new; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::Traver() &#123; Node* p_tmp = p_head; cout &lt;&lt; &quot;list: &quot;; while (p_tmp) &#123; cout &lt;&lt; p_tmp-&gt;data &lt;&lt; &quot; &quot;; p_tmp = p_tmp-&gt;p_next; &#125; cout &lt;&lt; &#39;\\n&#39;; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::DeletePosNode(int pos) &#123; if (nullptr == p_head || pos &lt; 0) &#123; return; &#125; if (0 == pos) &#123; DeleteHeadNode(); return; &#125; Node* p_del_prev = _FindPos(pos - 1); if (nullptr == p_del_prev) &#123; return; &#125; Node* p_del = _FindPos(pos); if (nullptr == p_del) &#123; return; &#125; p_del_prev-&gt;p_next = p_del-&gt;p_next; delete p_del; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::DeleteHeadNode() &#123; if (nullptr == p_head) &#123; return; &#125; Node* p_del = p_head; p_head = p_del-&gt;p_next; delete p_del; &#125; template &lt;class T&gt; typename MyList&lt;T&gt;::Node* MyList&lt;T&gt;::_FindPos(int pos) &#123; Node* p_pos = p_head; for (int i = 0; i &lt; pos; ++i) &#123; if (nullptr == p_pos) &#123; return nullptr; &#125; else &#123; p_pos = p_pos-&gt;p_next; &#125; &#125; return p_pos; &#125; int main(int argc, char** argv) &#123; MyList&lt;int&gt; list; for (int i = 0; i &lt; 10; ++i) &#123; list.AppendNode(i); list.Traver(); &#125; list.InsertNode(5, 666); list.Traver(); list.DeleteHeadNode(); list.Traver(); list.DeletePosNode(5); list.Traver(); return 0; &#125; 双向循环链表(C++风格)具体请查看”双向链表”这篇博客#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyList &#123; private: struct Node &#123; T data; Node* p_next; //指向下一个结点 Node* p_prev; //指向前一个结点 Node() &#123;&#125; Node(const T&amp; data) &#123; this-&gt;data = data; p_prev = p_next = nullptr; &#125; &#125;; Node* p_head; Node* p_tail; public: MyList() &#123; p_tail = p_head = NULL; &#125; void AppendNode(const T&amp; new_data); void Traver(); private: Node* _FindPos(int pos); &#125;; template &lt;class T&gt; void MyList&lt;T&gt;::AppendNode(const T&amp; new_data) &#123; // 1 创建新结点 Node* p_new = new Node(new_data); if (p_tail) &#123; //不是空链表 //新结点连接到尾结点后 p_tail-&gt;p_next = p_new; p_new-&gt;p_prev = p_tail; //更新p_tail p_tail = p_new; //维持循环双链表结构 p_tail-&gt;p_next = p_head; p_head-&gt;p_prev = p_tail; &#125; else &#123; //空链表 p_head = p_tail = p_new; &#125; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::Traver() &#123; Node* p_tmp = p_head; cout &lt;&lt; &quot;list:&quot;; if (p_head == NULL) &#123; cout &lt;&lt; &quot;链表为空&quot; &lt;&lt; endl; return; &#125; if (p_head == p_tail) &#123; cout &lt;&lt; p_head-&gt;data &lt;&lt; endl; return; &#125; while (p_tmp != p_tail) &#123; cout &lt;&lt; p_tmp-&gt;data &lt;&lt; &quot; &quot;; p_tmp = p_tmp-&gt;p_next; &#125; cout &lt;&lt; p_tail-&gt;data &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MyList&lt;int&gt; list; for (int i = 0; i &lt; 10; ++i) &#123; list.AppendNode(i); list.Traver(); &#125; return 0; &#125; 基础链式结构的应用#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //美女类型 struct MM &#123; char name[20]; int age; int num; &#125;; //结点类型 struct Node &#123; // int data; struct MM data; struct Node* p_next; &#125;; //创建表头 struct Node* CreateHeadNode(); //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(struct MM data); //遍历链表 void PrintList(struct Node* p_head_node); //表头法插入 void InsertNewNodeByHead(struct Node* p_head_node, struct MM data); //通过data删除指定位置结点 void DeleteByName(struct Node* p_head_node, const char* p_mm_name); //寻找相同的结点 struct Node* SearchNode(struct Node* p_head_node, const char* p_mm_name); //菜单 void Menu(); //录入信息 void InsertMMData(struct Node* p_head_node); //查找信息 void SearchMMData(struct Node* p_head_node); //修改信息 void ModifyMMData(struct Node* p_head_node); //删除信息 void DeleteMMData(struct Node* p_head_node); //冒泡排序 void BubbleSort(struct Node* p_head_node); //选项 void KeyDown(struct Node* p_list); int main(int argc, char* argv[]) &#123; struct Node* p_list = CreateHeadNode(); while (1) &#123; Menu(); KeyDown(p_list); system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; return 0; &#125; //创建表头 struct Node* CreateHeadNode() &#123; struct Node* p_head_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_head_node) &#123; return NULL; &#125; //这里我写的是有头链表,表头不存储数据,所以不需要将data进行初始化 p_head_node-&gt;p_next = NULL; return p_head_node; &#125; //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(struct MM data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化新结点 p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //遍历链表 void PrintList(struct Node* p_head_node) &#123; //定义移动指针,因为头结点不存储数据,所以直接指向头结点的下一个结点 struct Node* p_move = p_head_node-&gt;p_next; printf(&quot;姓名\\t年龄\\t编号\\n&quot;); while (NULL != p_move) &#123; printf(&quot;%s\\t%d\\t%d\\n&quot;, p_move-&gt;data.name, p_move-&gt;data.age, p_move-&gt;data.num); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; //表头法插入 void InsertNewNodeByHead(struct Node* p_head_node, struct MM data) &#123; //调用生成新结点函数 struct Node* p_new_node = CreateNewNode(data); //表头法插入 p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; &#125; //通过data删除指定位置结点 void DeleteByName(struct Node* p_head_node, const char* p_mm_name) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; if (NULL == p_head_node || NULL == p_cur_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; // while (NULL != p_cur_node &amp;&amp; p_cur_node-&gt;data != data_value) &#123; // p_pre_node = p_cur_node; // p_cur_node = p_pre_node-&gt;p_next; // &#125; //相同返回0, while (NULL != p_cur_node &amp;&amp; strcmp(p_cur_node-&gt;data.name, p_mm_name)) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (NULL == p_cur_node) &#123; printf(&quot;未找到指定结点\\n&quot;); &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; free(p_cur_node); p_cur_node = NULL; &#125; &#125; //寻找相同的结点 struct Node* SearchNode(struct Node* p_head_node, const char* p_mm_name) &#123; struct Node* p_move = p_head_node-&gt;p_next; // while (NULL != p_move &amp;&amp; p_move-&gt;data != data_value) &#123; // p_move = p_move-&gt;p_next; // &#125; while (NULL != p_move &amp;&amp; strcmp(p_move-&gt;data.name, p_mm_name)) &#123; p_move = p_move-&gt;p_next; &#125; return p_move; &#125; void Menu() &#123; printf(&quot;-----------【MM管理系统】-------------\\n&quot;); printf(&quot;\\t\\t0.退出功能\\n&quot;); printf(&quot;\\t\\t1.录入信息\\n&quot;); printf(&quot;\\t\\t2.浏览信息\\n&quot;); printf(&quot;\\t\\t3.查找信息\\n&quot;); printf(&quot;\\t\\t4.修改信息\\n&quot;); printf(&quot;\\t\\t5.删除信息\\n&quot;); printf(&quot;\\t\\t6.排序显示\\n&quot;); printf(&quot;-------------------------------------\\n&quot;); printf(&quot;请输入(0-6):&quot;); &#125; //录入美女信息 void InsertMMData(struct Node* p_head_node) &#123; struct MM mm; printf(&quot;输入美女信息:&quot;); scanf(&quot;%s%d%d&quot;, mm.name, &amp;mm.age, &amp;mm.num); InsertNewNodeByHead(p_head_node, mm); &#125; void SearchMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入查找美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); struct Node* p_result = SearchNode(p_head_node, mm_name); if (NULL == p_result) &#123; printf(&quot;未找到指定位置\\n&quot;); &#125; else &#123; printf(&quot;姓名\\t年龄\\t编号\\n&quot;); printf(&quot;%s\\t%d\\t%d\\n&quot;, p_result-&gt;data.name, p_result-&gt;data.age, p_result-&gt;data.num); &#125; &#125; void ModifyMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入修改美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); struct Node* p_result = SearchNode(p_head_node, mm_name); if (NULL == p_result) &#123; printf(&quot;未找到指定位置\\n&quot;); &#125; else &#123; printf(&quot;重新输入美女的信息:&quot;); scanf(&quot;%s%d%d&quot;, p_result-&gt;data.name, &amp;p_result-&gt;data.age, &amp;p_result-&gt;data.num); printf(&quot;修改成功\\n&quot;); &#125; &#125; void DeleteMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入删除美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); DeleteByName(p_head_node, mm_name); &#125; void BubbleSort(struct Node* p_head_node) &#123; for (struct Node* p = p_head_node-&gt;p_next; p != NULL; p = p-&gt;p_next) &#123; for (struct Node* q = p_head_node-&gt;p_next; q != NULL; q = q-&gt;p_next) &#123; //按照年龄方式升序 if (q-&gt;p_next != NULL &amp;&amp; q-&gt;data.age &gt; q-&gt;p_next-&gt;data.age) &#123; struct MM tmp = q-&gt;data; q-&gt;data = q-&gt;p_next-&gt;data; q-&gt;p_next-&gt;data = tmp; &#125; &#125; &#125; PrintList(p_head_node); &#125; void KeyDown(struct Node* p_list) &#123; struct MM mm; int options = 0; scanf(&quot;%d&quot;, &amp;options); switch (options) &#123; case 0: printf(&quot;----退出----\\n&quot;); exit(0); break; case 1: printf(&quot;----录入----\\n&quot;); InsertMMData(p_list); break; case 2: printf(&quot;----浏览----\\n&quot;); PrintList(p_list); break; case 3: printf(&quot;----查找----\\n&quot;); SearchMMData(p_list); break; case 4: printf(&quot;----修改----\\n&quot;); ModifyMMData(p_list); break; case 5: printf(&quot;----删除----\\n&quot;); DeleteMMData(p_list); break; case 6: printf(&quot;-----排序----\\n&quot;); BubbleSort(p_list); break; default: printf(&quot;----error----\\n&quot;); break; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++可变参数模板","slug":"C++可变参数模板","date":"2022-06-26T10:15:05.000Z","updated":"2022-09-18T02:35:51.596Z","comments":true,"path":"2022/06/26/C++可变参数模板/","link":"","permalink":"http://goskp.github.io/2022/06/26/C++%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++折叠参数可变参数函数模板#include &lt;initializer_list&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tuple&gt; using namespace std; /* 参数包： class ...Args 参数包展开： 1.递归方式展开参数包 2.采用列表的方式展开参数包 */ //递归终止条件 template &lt;class _Ty&gt; void print(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; template &lt;class _Ty, class... Args&gt; void print(_Ty head, Args... args) //&#123;1,&quot;string&quot;,1.3&#125; &#123; cout &lt;&lt; head &lt;&lt; &quot; &quot;; //头部 print(args...); //参数包中的参数 &#123;&quot;string&quot;,1.3&#125; // args... 抽一个参数出来充当head //当参数包中只有一个参数时候，不满足调用自身的条件 &#125; //采用列表的方式 template &lt;class _Ty&gt; void printData(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125; template &lt;class... Args&gt; void printArgs(Args... args) &#123; initializer_list&lt;int&gt;&#123;(printData(args), 0)...&#125;; cout &lt;&lt; endl; &#125; // printf函数 void my_printf(const char* str) &#123; while (*str) &#123; cout &lt;&lt; *str &lt;&lt; endl; &#125; &#125; template &lt;class _Ty, class... Args&gt; void my_printf(const char* str, _Ty value, Args... args) &#123; //%d %c while (*str) &#123; if (*str == &#39;%&#39; &amp;&amp; (*++str) != &#39;%&#39;) &#123; //格式控制字符时候，参数包解析 cout &lt;&lt; value; my_printf(*str ? ++str : str, args...); return; &#125; cout &lt;&lt; *str++; //原样字符，直接打印 &#125; &#125; int main(int argc, char** argv) &#123; print(&quot;string&quot;, 1.3, 43, 554, &quot;string&quot;, 1.44); print(&quot;string&quot;, 1.3); printArgs(&quot;string&quot;, 1.3, 43, 554, &quot;string&quot;, 1.44); printArgs(&quot;string&quot;, 1.3); my_printf(&quot;整数:%d,字符:%c,整数:%d,字符:%c&quot;, 123, &#39;A&#39;, 123, &#39;A&#39;); return 0; &#125; 可变参数模板类#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; #include &lt;tuple&gt; using namespace std; // No.1 采用继承+模板特化的方式展开参数包 template &lt;class... Args&gt; class Test; //递归终止，特化模板 template &lt;&gt; class Test&lt;&gt; &#123;&#125;; template &lt;class _Ty, class... Args&gt; class Test&lt;_Ty, Args...&gt; : public Test&lt;Args...&gt; &#123; public: Test() &#123;&#125; //构造函数做参数包展开 Test(_Ty data, Args... args) : data(data), Test&lt;Args...&gt;(args...) &#123;&#125; //&#123;int,double,string&#125; Test&lt;int&gt; //&#123;double,string&#125; Test&lt;double&gt; //&#123;string&#125; Test&lt;string&gt; //访问数据 _Ty&amp; GetData() &#123; return data; &#125; Test&lt;Args...&gt;&amp; GetObject() &#123; return *this; &#125; protected: _Ty data; &#125;; void testFirst() &#123; Test&lt;int, double, string&gt; test(1, 1.11, &quot;string&quot;); // Test&lt;int, double, string, float &gt; test2(1, 1.11, &quot;string&quot;,1.1f); cout &lt;&lt; test.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetObject().GetObject().GetData() &lt;&lt; endl; Test&lt;string, int, int, string&gt; student(&quot;baby&quot;, 18, 1001, &quot;18508444345&quot;); cout &lt;&lt; student.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetObject().GetObject().GetData() &lt;&lt; endl; &#125; // No.2 递归方式展开 template &lt;class... Args&gt; class Tup; //终止使用的特化模板 template &lt;&gt; class Tup&lt;&gt; &#123;&#125;; template &lt;class _Ty, class... Args&gt; class Tup&lt;_Ty, Args...&gt; &#123; public: Tup() &#123;&#125; //参数包展开 Tup(_Ty data, Args... args) : data(data), args(args...) &#123;&#125; //数据访问 _Ty&amp; GetData() &#123; return data; &#125; Tup&lt;Args...&gt;&amp; GetArgs() &#123; return args; &#125; protected: _Ty data; Tup&lt;Args...&gt; args; &#125;; void testSecond() &#123; Tup&lt;int, double, string&gt; test(1, 1.11, &quot;string&quot;); // Test&lt;int, double, string, float &gt; test2(1, 1.11, &quot;string&quot;,1.1f); cout &lt;&lt; test.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetArgs().GetArgs().GetData() &lt;&lt; endl; Tup&lt;string, int, int, string&gt; student(&quot;baby&quot;, 18, 1001, &quot;18508444345&quot;); cout &lt;&lt; student.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetArgs().GetArgs().GetData() &lt;&lt; endl; &#125; //统一接口 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; void print(int (*Func)(int, int), int a, int b) &#123; //接口 cout &lt;&lt; Func(a, b) &lt;&lt; endl; &#125; int getValue(int a) &#123; return a; &#125; void print(int (*Func)(int), int a) &#123; //接口 cout &lt;&lt; Func(a) &lt;&lt; endl; &#125; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;sdfsd&quot; &lt;&lt; endl; &#125; operator int() &#123; return age; &#125; protected: int age; string name; &#125;; void testMM() &#123; MM mm(&quot;小芳&quot;, 19); int value = mm; //类的对象隐式转换 cout &lt;&lt; value &lt;&lt; endl; MM* pmm = new MM(&quot;ds&quot;, 19); auto func = &amp;MM::print; (pmm-&gt;*func)(); &#125; template &lt;class _Ty, class _TyF, class... Args&gt; class InterFace &#123; public: InterFace(_Ty* data, _TyF (_Ty::*func)(Args...)) : data(data), func(func) &#123;&#125; //重载 _TyF operator()(Args... args) &#123; return (data-&gt;*func)((args)...); &#125; protected: _Ty* data; //_Ty 类类型 _TyF (_Ty::*func)(Args...); //类中成员函数指针 &#125;; //统一创建接口 template &lt;class _Ty, class _TyF, class... Args&gt; InterFace&lt;_Ty, _TyF, Args...&gt; createObject(_Ty* data, _TyF (_Ty::*func)(Args...)) &#123; return InterFace&lt;_Ty, _TyF, Args...&gt;(data, func); &#125; struct Data &#123; void Func1(int i) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; void Func2(int i, int j) &#123; cout &lt;&lt; i + j &lt;&lt; endl; &#125; void Func3(int i, int j, int k) &#123; cout &lt;&lt; i * j * k &lt;&lt; endl; &#125; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; &#125;; void testInterFace() &#123; Data data; auto Func1 = createObject(&amp;data, &amp;Data::Func1); Func1(1); auto Func2 = createObject(&amp;data, &amp;Data::Func2); Func2(2, 3); auto Func3 = createObject(&amp;data, &amp;Data::Func3); Func3(2, 3, 4); auto Func4 = createObject(&amp;data, &amp;Data::Max); cout &lt;&lt; Func4(2, 3) &lt;&lt; endl; &#125; void print1(int a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; void print2(int a, int b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testFirst(); tuple&lt;int, string&gt; tup; testSecond(); testInterFace(); //多线程库 thread t1(print1, 1); t1.join(); thread t2(print2, 2, 3); t2.join(); return 0; &#125; C++随机数,比较鸡肋,直接用C语言的吧#include &lt;array&gt; #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;random&gt; #include &lt;vector&gt; using namespace std; void testSeed() &#123; // NO.1 种子管理 seed_seq seed = &#123;1, 3, 4, 5, 6, 7, 8&#125;; cout &lt;&lt; &quot;size:&quot; &lt;&lt; seed.size() &lt;&lt; endl; array&lt;int, 7&gt; data; seed.param(data.begin()); //把种子拿出赋值 for (auto v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; // array&lt;int,7&gt; vec; //使用内部算法填充所提供序列的元素 // seed.generate(vec.begin(), vec.end()); ////for_each(vec.begin(), vec.end(), [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;); // for (auto v : vec) //&#123; // cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; // &#125; // cout &lt;&lt; endl; &#125; void RandValue() &#123; // 1.基操 //随机引擎--&gt;就是一个算法 //线性同余： x=(x*a+c)%m; //梅森旋转 default_random_engine e; //设置随机数种子 e.seed(chrono::high_resolution_clock::now().time_since_epoch().count()); //等同: e.seed((size_t)time(nullptr)); for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;随机数:&quot; &lt;&lt; e() % 10 &lt;&lt; endl; //控制范围和C语言一样，用区域方式 &#125; // 2.分布方式 uniform_int_distribution&lt;int&gt; duration(1, 6); cout &lt;&lt; &quot;uniform:&quot; &lt;&lt; duration(e) &lt;&lt; endl; //随机数范围在1-6之间 auto randFunc = bind(duration, e); cout &lt;&lt; &quot;1:&quot; &lt;&lt; randFunc() &lt;&lt; endl; cout &lt;&lt; &quot;2:&quot; &lt;&lt; randFunc() &lt;&lt; endl; cout &lt;&lt; &quot;3:&quot; &lt;&lt; randFunc() &lt;&lt; endl; // 3.其他引擎 // x=(x*a+c)%m; linear_congruential_engine&lt;unsigned int, 2, 4, 8&gt; ee; ee.seed((size_t)time(nullptr)); cout &lt;&lt; &quot;线性同余:&quot; &lt;&lt; ee() &lt;&lt; endl; //梅森旋转 mersenne_twister_engine&lt;size_t, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1&gt; eeee; //一般用直接用下面写法 mt19937_64 eeeee; cout &lt;&lt; &quot;梅森:&quot; &lt;&lt; eeeee() &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testSeed(); RandValue(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++正则表达式","slug":"C++正则表达式","date":"2022-06-24T09:10:54.000Z","updated":"2022-09-18T02:35:34.861Z","comments":true,"path":"2022/06/24/C++正则表达式/","link":"","permalink":"http://goskp.github.io/2022/06/24/C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++正则库正则指的是一种规则，用来匹配，捕获，替换字符串(字符串处理方案) 特殊含义元字符^: 以字符作为字符串开的头, ^ 表示单个字符 $:以字符结尾 ，\\$表示单个字符 ():分组 &#121;&#100;&#112;&#97;&#x6a;&#106;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109; \\b: 字符串的边界 .: 除了\\n意外的任意一个字符 |:a|b a或者b [abc]: abc任意一个字符 [^abc]: abc之外的任意一个字符 [a-z]:任意一个小写字母 \\w: 任意字母数字下划线 [(0-9)(a-z)(A-Z)(_)] \\W: 字母数字下划线之外的字符 \\d: 任意一个数字 \\D:数字之外的任意一个字符 \\s: 空白符 量词元字符*:0次或者多次 [a-z]* {0,} +:1次或者多次 {1,} ?:0次或者1次 {0,1} {n}: 出现n次 {n,}: 至少出现n次 {n,m}: 至少有n到m个之间的字符 注意的问题: C&#x2F;C++中带\\的元字符一定改为\\\\ #include &lt;iostream&gt; #include &lt;regex&gt; #include &lt;string&gt; using namespace std; // No.1 匹配 void testMatch() &#123; // 1.1 先构造正则对象 // 1.2 调用 regex_match 返回true匹配，返回false不匹配 #if 0 while (1) &#123; string userName; cin &gt;&gt; userName; regex reg(&quot;^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$&quot;); bool result = regex_match(userName, reg); if (result == true) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; &#125; #endif //正则匹配一定完全匹配 string str = &quot;ILoveyou1314&quot;; regex reg(&quot;[a-z0-9]+&quot;); if (regex_match(str, reg)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; regex reg2(&quot;[a-z0-9]+&quot;, regex_constants::icase); //忽略大小写 if (regex_match(str, reg2)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; regex reg3(&quot;ILoveyou[0-9]+&quot;); if (regex_match(str, reg3)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; &#125; // No.2 截取 void testGetString() &#123; string str = &quot;ILoveyou1314IMiss520you999dsdsd999sds23234&quot;; // regex_search(string str,smatch result,regex reg); smatch result; //只要找到就结束 bool flag = regex_search(str, result, regex(&quot;\\\\d+&quot;)); if (flag) &#123; cout &lt;&lt; &quot;size:&quot; &lt;&lt; result.size() &lt;&lt; endl; for (int i = 0; i &lt; result.size(); i++) &#123; cout &lt;&lt; result.str() &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;前缀:&quot; &lt;&lt; result.prefix() &lt;&lt; endl; cout &lt;&lt; &quot;后缀:&quot; &lt;&lt; result.suffix() &lt;&lt; endl; &#125; //捕获所有满足的条件字符串 // sregex_iterator regex reg(&quot;\\\\d+&quot;); //得到满足条件 sregex_iterator pos(str.begin(), str.end(), reg); sregex_iterator end; //无参构造是结束流 while (pos != end) &#123; cout &lt;&lt; pos-&gt;str() &lt;&lt; &quot;\\t&quot;; pos++; &#125; cout &lt;&lt; endl; str = &quot;10,12,32,,,34,,34,34,6566,67,,67&quot;; // 0: 表示匹配 //-1:不匹配 regex reg2(&quot;,&quot;); sregex_token_iterator tpos(str.begin(), str.end(), reg2, -1); sregex_token_iterator tend; while (tpos != tend) &#123; cout &lt;&lt; tpos-&gt;str() &lt;&lt; &quot; &quot;; tpos++; &#125; cout &lt;&lt; endl; &#125; // No.3 替换 void testReplace() &#123; string str = &quot;ILoveyou******IMiss*******y*****o***u&quot;; regex reg(&quot;\\\\*+&quot;); // regex_replace(string str,regex regx,string content) //返回值是处理后的字符串 cout &lt;&lt; &quot;888:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;) &lt;&lt; endl; //控制替换 cout &lt;&lt; &quot;only one:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_first_only) &lt;&lt; endl; cout &lt;&lt; &quot;no copy:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_no_copy) &lt;&lt; endl; cout &lt;&lt; &quot;sed:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_sed) &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // testMatch(); // testGetString(); testReplace(); return 0; &#125; C++日期时间库using nanoseconds = duration&lt;long long, nano&gt;; //纳秒 using microseconds = duration&lt;long long, micro&gt;; //微妙 using milliseconds = duration&lt;long long, milli&gt;; //毫秒 using seconds = duration&lt;long long&gt;; //秒 using minutes = duration&lt;int, ratio&lt;60&gt;&gt;; //分钟 using hours = duration&lt;int, ratio&lt;3600&gt;&gt;; //小时 #include &lt;chrono&gt; #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; int main(int argc, char** argv) &#123; chrono::seconds one(1); // C++延时函数 thread //延时1秒钟 this_thread::sleep_for(chrono::seconds(1)); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1s); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1000ms); cout &lt;&lt; &quot;延时1000毫秒&quot; &lt;&lt; endl; return 0; &#125; 时钟 system_clock:系统时钟 steady_clock: 计时 high_resoulution_clock: 高精度时钟 时间点 time_point:时间点 from_time_t: time_t 的时间转换为time_point to_time_t: time_piont 转换为time_t #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; void GetTime() &#123; //获取当前系统时间 chrono::system_clock::time_point curTime = chrono::system_clock::now(); //用的时候: auto curTime=chrono::system_clock::now(); time_t tm_t = chrono::system_clock::to_time_t(curTime); cout &lt;&lt; &quot;日期:&quot; &lt;&lt; ctime(&amp;tm_t) &lt;&lt; endl; //格式化输出时间 tm* pCurTime = localtime(&amp;tm_t); cout &lt;&lt; put_time(pCurTime, &quot;%F %X&quot;) &lt;&lt; endl; cout &lt;&lt; &quot;时间戳:&quot; &lt;&lt; curTime.time_since_epoch().count() &lt;&lt; endl; &#125; void CountTime() &#123; chrono::steady_clock::time_point start = chrono::steady_clock::now(); cout &lt;&lt; &quot;start:&quot; &lt;&lt; endl; for (int i = 0; i &lt; 1000; i++) &#123; // cout &lt;&lt; &quot;运行中...&quot; &lt;&lt; endl; &#125; chrono::steady_clock::time_point end = chrono::steady_clock::now(); // auto dt = end - start; //纳秒 chrono::duration&lt;double, ratio&lt;1, 1000&gt;&gt; dt = end - start; cout &lt;&lt; &quot;耗时&quot; &lt;&lt; dt.count() &lt;&lt; &quot;s&quot; &lt;&lt; endl; &#125; void HightClock() &#123; auto start = chrono::high_resolution_clock::now(); cout &lt;&lt; &quot;start:&quot; &lt;&lt; endl; for (int i = 0; i &lt; 1000; i++) &#123; // cout &lt;&lt; &quot;运行中...&quot; &lt;&lt; endl; &#125; auto end = chrono::high_resolution_clock::now(); // auto dt = end - start; //纳秒 chrono::duration&lt;double, ratio&lt;1, 1000&gt;&gt; dt = end - start; cout &lt;&lt; &quot;耗时&quot; &lt;&lt; dt.count() &lt;&lt; &quot;s&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; #if 0 chrono::seconds one(1); //C++延时函数 thread //延时1秒钟 this_thread::sleep_for(chrono::seconds(1)); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1s); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1000ms); cout &lt;&lt; &quot;延时1000毫秒&quot; &lt;&lt; endl; #endif GetTime(); CountTime(); HightClock(); return 0; &#125; C+文件目录库C++17标准才有的东西，C++文件目录库分为三部分 file_status类: 文件状态 path类: 处理目录 directory_entry类： 访问遍历目录 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;string&gt; using namespace std; void TestPath() &#123; error_code temp; filesystem::create_directory(&quot;xxx&quot;, temp); //创建一个目录(文件夹) filesystem::create_directories(&quot;a/b&quot;); //创建多级目录 cout &lt;&lt; temp.message() &lt;&lt; endl; filesystem::create_directory(&quot;xxx/bbb&quot;); //创建一个目录(文件夹) // filesystem::path url(&quot;my_box&quot;); //构建一个path filesystem::path url = filesystem::current_path(); cout &lt;&lt; &quot;当前路径:&quot; &lt;&lt; url &lt;&lt; endl; cout &lt;&lt; &quot;当前路径:&quot; &lt;&lt; url.string() &lt;&lt; endl; cout &lt;&lt; &quot;根目录:&quot; &lt;&lt; url.root_directory() &lt;&lt; endl; cout &lt;&lt; &quot;相对路径:&quot; &lt;&lt; url.relative_path() &lt;&lt; endl; cout &lt;&lt; &quot;根名：&quot; &lt;&lt; url.root_name() &lt;&lt; endl; cout &lt;&lt; &quot;根路径:&quot; &lt;&lt; url.root_path() &lt;&lt; endl; &#125; void DemoStatus(filesystem::file_status object) &#123; switch (object.type()) &#123; case filesystem::file_type::regular: cout &lt;&lt; &quot;磁盘文件&quot; &lt;&lt; endl; break; case filesystem::file_type::directory: cout &lt;&lt; &quot;目录文件&quot; &lt;&lt; endl; break; case filesystem::file_type::not_found: cout &lt;&lt; &quot;目录不存在&quot; &lt;&lt; endl; break; case filesystem::file_type::unknown: cout &lt;&lt; &quot;无法识别文件&quot; &lt;&lt; endl; break; &#125; &#125; void TestStatus() &#123; filesystem::create_directory(&quot;fileBox&quot;); DemoStatus(filesystem::status(&quot;fileBox&quot;)); fstream file(&quot;fileBox/file&quot;, ios::out | ios::trunc); DemoStatus(filesystem::status(&quot;fileBox/file&quot;)); &#125; // directory_entry // directory_iterator // 1.遍历当前目录下所有文件夹(一层) void tarverseDirectory() &#123; filesystem::path url(&quot;./test&quot;); if (!filesystem::exists(url)) &#123; cout &lt;&lt; &quot;目录不存在&quot; &lt;&lt; endl; return; &#125; filesystem::directory_iterator list(url); for (auto v : list) &#123; cout &lt;&lt; v.path().filename() &lt;&lt; endl; &#125; &#125; // 2.遍历文件夹中的所有文件(一层) void travserDirectoryAllFile() &#123; filesystem::path url(&quot;./test&quot;); set&lt;string&gt; dirset; for (filesystem::directory_iterator end, begin(url); begin != end; ++begin) &#123; if (!filesystem::is_directory(begin-&gt;path())) &#123; dirset.insert(begin-&gt;path().filename().string()); &#125; &#125; for (auto v : dirset) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; // 3.所有文件夹中的文件 void traverseAllDirectoryAllFile() &#123; filesystem::path url(&quot;./test&quot;); multiset&lt;string&gt; dirset; for (filesystem::recursive_directory_iterator end, begin(url); begin != end; ++begin) &#123; if (!filesystem::is_directory(begin-&gt;path())) &#123; dirset.insert(begin-&gt;path().filename().string()); &#125; &#125; for (auto v : dirset) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; remove_all(url / &quot;b&quot;); //删除当前url下面b文件夹 &#125; // remove_all int main(int argc, char** argv) &#123; TestPath(); TestStatus(); tarverseDirectory(); travserDirectoryAllFile(); traverseAllDirectoryAllFile(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++智能指针","slug":"C++智能指针","date":"2022-06-21T11:06:51.000Z","updated":"2022-09-18T02:35:33.024Z","comments":true,"path":"2022/06/21/C++智能指针/","link":"","permalink":"http://goskp.github.io/2022/06/21/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++智能指针智能指针本质是一个类的对象，使用的时候不会创建这个类指针，只会使用这个类的对象 智能指针原理是通过对象的死亡会自动调用析构函数这个功能去实现 构造函数: 管理new的对象 析构函数: 析构new的对象 C++共享型智能指针 允许拷贝构造 允许多个智能指针对象管理同一段内存 // shared_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构过程&quot; &lt;&lt; endl; &#125; protected: string name; int age; &#125;; class Boy &#123; public: Boy() &#123; cout &lt;&lt; &quot;Boy&quot; &lt;&lt; endl; &#125; ~Boy() &#123; cout &lt;&lt; &quot;~Boy&quot; &lt;&lt; endl; &#125; &#125;; void printData(shared_ptr&lt;MM&gt; mm) &#123; mm-&gt;print(); &#125; auto returnPtr() &#123; shared_ptr&lt;MM&gt; mm(new MM(&quot;小芳&quot;, 18)); return mm; &#125; void FreeFile(FILE*&amp; fp) &#123; cout &lt;&lt; &quot;关闭文件成功&quot; &lt;&lt; endl; fclose(fp); &#125; void test_shared_ptr() &#123; // 1.管理基本数据 shared_ptr&lt;int&gt; intData(new int(100)); if (!intData) &#123; cout &lt;&lt; &quot;初始化之智能指针失败!&quot; &lt;&lt; endl; return; &#125; cout &lt;&lt; *intData &lt;&lt; endl; //获取管理对象地址 // int* x = intData.get(); // cout &lt;&lt; *x &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; intData.use_count() &lt;&lt; endl; shared_ptr&lt;int&gt; p2(intData); cout &lt;&lt; &quot;size:&quot; &lt;&lt; intData.use_count() &lt;&lt; endl; // swap // reset // make_shared函数的参数由构造函数决定 // 2.管理自定义类型 shared_ptr&lt;string&gt; str = make_shared&lt;string&gt;(&quot;ILoveyou&quot;); cout &lt;&lt; *str &lt;&lt; endl; &#123; shared_ptr&lt;MM&gt; mm(new MM(&quot;张三&quot;, 19)); mm-&gt;print(); mm.reset(new MM(&quot;小芳&quot;, 18)); mm-&gt;print(); shared_ptr&lt;MM&gt; mm2 = make_shared&lt;MM&gt;(&quot;小芳&quot;, 20); mm2-&gt;print(); &#125; // 3.智能指针常用场景 shared_ptr&lt;MM&gt; temp(new MM(&quot;亲爱的&quot;, 28)); printData(temp); printData(returnPtr()); // 4.特殊释放形式的内存，需要自己手动写删除器 // C语言文件指针 &#123; shared_ptr&lt;FILE&gt; pf(fopen(&quot;1.txt&quot;, &quot;w+&quot;), FreeFile); &#125; &#123; shared_ptr&lt;Boy&gt; p(new Boy[10], [](Boy*&amp; p) &#123; delete[] p; &#125;); &#125; &#123; shared_ptr&lt;int&gt; pint(new int(999)); int* pp = pint.get(); *pp = 666; cout &lt;&lt; *pint &lt;&lt; endl; // delete pp; //不能直接释放，会导致二次析构问题 // cout &lt;&lt; *pint &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; test_shared_ptr(); return 0; &#125; C++弱引用型智能指针 weak_ptr 是弱引用指针，不会累计计数 weak_ptr不能直接管理对象，只能shared_ptr或者weak_ptr构造而来 目的是为了解决shared_ptr循环引用的时候内存未释放问题 不可以使用* 或者-&gt;访问对象，只能通过lock函数访问shared_ptr对象，再去访问数据 // weak_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class B; class A &#123; public: A() &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A&quot; &lt;&lt; endl; &#125; // shared_ptr&lt;B&gt; b; weak_ptr&lt;B&gt; b; &#125;; class B &#123; public: B() &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B&quot; &lt;&lt; endl; &#125; // shared_ptr&lt;A&gt; a; weak_ptr&lt;A&gt; a; &#125;; void test_weak_ptr() &#123; &#123; shared_ptr&lt;A&gt; ao = make_shared&lt;A&gt;(); shared_ptr&lt;B&gt; bo = make_shared&lt;B&gt;(); cout &lt;&lt; ao.use_count() &lt;&lt; endl; cout &lt;&lt; bo.use_count() &lt;&lt; endl; ao-&gt;b = bo; bo-&gt;a = ao; cout &lt;&lt; ao.use_count() &lt;&lt; endl; cout &lt;&lt; bo.use_count() &lt;&lt; endl; &#125; &#123; shared_ptr&lt;int&gt; s(new int(999)); cout &lt;&lt; &quot;count:&quot; &lt;&lt; s.use_count() &lt;&lt; endl; weak_ptr&lt;int&gt; w(s); cout &lt;&lt; &quot;count:&quot; &lt;&lt; w.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;count:&quot; &lt;&lt; s.use_count() &lt;&lt; endl; cout &lt;&lt; *w.lock() &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; // test_shared_ptr(); test_weak_ptr(); return 0; &#125; C++独享型智能指针 禁止拷贝和赋值(通过删除拷贝构造函数和赋值重载) 可以通过转交所有权的方式让一个指针去管理对象 move函数移交所有权限 内置reset函数结合release函数去移交所有权限 // unique_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构过程&quot; &lt;&lt; endl; &#125; protected: string name; int age; &#125;; class Boy &#123; public: Boy() &#123; cout &lt;&lt; &quot;Boy&quot; &lt;&lt; endl; &#125; ~Boy() &#123; cout &lt;&lt; &quot;~Boy&quot; &lt;&lt; endl; &#125; &#125;; void test_unique_ptr() &#123; unique_ptr&lt;int&gt; ptr(new int(999)); cout &lt;&lt; *ptr &lt;&lt; endl; // unique_ptr&lt;int&gt; ptr2(ptr); //转交所有权 unique_ptr&lt;int&gt; ptr2; ptr2 = move(ptr); // cout &lt;&lt; *ptr &lt;&lt; endl; //没有值了 cout &lt;&lt; *ptr2 &lt;&lt; endl; unique_ptr&lt;int&gt; ptr3; ptr3.reset(ptr2.release()); cout &lt;&lt; *ptr3 &lt;&lt; endl; auto p = ptr3.get(); // delete p; //导致二次析构问题 &#123; unique_ptr&lt;MM&gt; pMM(new MM(&quot;小美&quot;, 19)); pMM-&gt;print(); // unique_ptr&lt;管理对象类型,删除器函数指针类型&gt; using FUNC = void (*)(Boy*&amp;); unique_ptr&lt;Boy, FUNC&gt; pBoy(new Boy[3], [](Boy*&amp; pBoy) &#123; delete[] pBoy; &#125;); //不能用auto // unique_ptr&lt;Boy, auto&gt; pBoy2(new Boy[3], [](Boy*&amp; pBoy) &#123;delete[] // pBoy; &#125;); &#125; &#125; int main(int argc, char** argv) &#123; // test_shared_ptr(); // test_weak_ptr(); test_unique_ptr(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库算法篇(拷贝,算数,排列组合,堆)","slug":"C++标准模板库算法篇(拷贝,算数,排列组合,堆)","date":"2022-06-17T06:01:01.000Z","updated":"2022-09-18T02:36:07.826Z","comments":true,"path":"2022/06/17/C++标准模板库算法篇(拷贝,算数,排列组合,堆)/","link":"","permalink":"http://goskp.github.io/2022/06/17/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%97%E6%B3%95%E7%AF%87(%E6%8B%B7%E8%B4%9D,%E7%AE%97%E6%95%B0,%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88,%E5%A0%86)/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 拷贝和修改类算法 copy: 区间拷贝 copy_backward: 逆向拷贝 remove:删除 remove_copy: 删除另存 remove_if:条件删除 remove_copy_if:条件删除结果另存 replace: 修改 replace _copy: 修改结果另存 replace_if:条件替换 replace_copy_if:条件替换 ，结果另存 iter_swap:迭代器交换 swap:容器交换 swap_ranges: 区间交换 unique: 去重操作 unique_copy: 去重结果另存 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; //打印辅助函数 template &lt;class _Ty&gt; void print(string info, _Ty data) &#123; cout &lt;&lt; info &lt;&lt; &quot;: &quot;; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // copy: 区间拷贝 array&lt;int, 4&gt; arrayData = &#123;1, 3, 7, 9&#125;; vector&lt;int&gt; vecData(arrayData.size()); copy(arrayData.begin(), arrayData.end(), vecData.begin()); print(&quot;copy&quot;, vecData); // copy_backward : 逆向拷贝 vector&lt;int&gt; rvec(arrayData.size()); copy_backward(arrayData.begin(), arrayData.end(), rvec.end()); print(&quot;copy_backward&quot;, rvec); // remove : 删除 vector&lt;int&gt;::iterator rs = remove(vecData.begin(), vecData.end(), 3); print(&quot;remove&quot;, vecData); //数组的伪删除 vecData.pop_back(); //真正的删除 print(&quot;remove&quot;, vecData); // remove_copy : 删除另存 vector&lt;int&gt; result(vecData.size() - 1); remove_copy(vecData.begin(), vecData.end(), result.begin(), 7); print(&quot;remove_copy&quot;, result); // remove_if : 条件删除 vector&lt;int&gt; test = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; auto it = remove_if(test.begin(), test.end(), [](int&amp; data) &#123; return data % 2 == 0; &#125;); print(&quot;remove_if&quot;, test); // remove_copy_if : 条件删除结果另存 vector&lt;int&gt; test2 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; result.resize(5); remove_copy_if(test2.begin(), test2.end(), result.begin(), [](int&amp; data) &#123; return data % 2 == 0; &#125;); print(&quot;remove_copy_if&quot;, result); // replace : 修改 replace(result.begin(), result.end(), 1, 999); print(&quot;replace&quot;, result); // replace _copy : 修改结果另存 vector&lt;int&gt; newTest(result.size()); replace_copy(result.begin(), result.end(), newTest.begin(), 999, 888); print(&quot;replace_copy&quot;, newTest); // replace_if : 条件替换 replace_if( newTest.begin(), newTest.end(), [](int&amp; data) &#123; return data % 2 == 1; &#125;, 888); print(&quot;replace_if&quot;, newTest); // replace_copy_if : 条件替换 ，结果另存 vector&lt;int&gt; result2(newTest.size()); replace_copy_if( newTest.begin(), newTest.end(), result2.begin(), [](int&amp; data) &#123; return data == 888; &#125;, 666); print(&quot;replace_copy_if&quot;, result2); // iter_swap : 迭代器交换 list&lt;int&gt; listData = &#123;1, 2, 3, 4, 5&#125;; list&lt;int&gt;::iterator itList = listData.end(); advance(itList, -1); iter_swap(listData.begin(), itList); print(&quot;iter_swap&quot;, listData); // swap : 容器交换 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5, 6, 8, 9&#125;; vector&lt;int&gt; second = &#123;9, 99, 999&#125;; swap(first, second); print(&quot;first&quot;, first); print(&quot;second&quot;, second); // swap_ranges : 区间交换 swap_ranges(first.begin(), first.begin() + 2, second.begin()); print(&quot;first&quot;, first); print(&quot;second&quot;, second); // unique : 去重操作 list&lt;int&gt; data = &#123;1, 1, 2, 2, 3, 3, 3, 4, 4, 4&#125;; unique(data.begin(), data.end()); print(&quot;unique&quot;, data); // unique_copy : 去重结果另存 vector&lt;int&gt; data2 = &#123;1, 1, 2, 2, 3, 3, 3, 4, 4, 4&#125;; vector&lt;int&gt; result3(4); std::unique_copy(data2.begin(), data2.end(), result3.begin()); print(&quot;unique_copy&quot;, result3); return 0; &#125; 关系类算法 equal ：比较算法 includes：是不是包含关系 lexicographical_compare: 比较序列 max: 最大值 max_element min:最小值 min_element mismatch: 查找第一次不同的地方 #include &lt;algorithm&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // equal ：比较算法 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; second = &#123;1, 4, 2, 3, 4&#125;; cout &lt;&lt; boolalpha &lt;&lt; equal(first.begin(), first.end(), second.begin()) &lt;&lt; endl; // includes：是不是包含关系 有序基础之上 vector&lt;int&gt; third = &#123;1, 2, 3&#125;; cout &lt;&lt; includes(first.begin(), first.end(), third.begin(), third.end()) &lt;&lt; endl; // lexicographical_compare: 比较序列 //第一个序列小于第二个序列，返回true，反之返回fasle(字符比较) cout &lt;&lt; lexicographical_compare(first.begin(), first.end(), second.begin(), second.end()) &lt;&lt; endl; // max : 最大值 max_element cout &lt;&lt; std::max(1, 2) &lt;&lt; endl; cout &lt;&lt; *max_element(second.begin(), second.end()) &lt;&lt; endl; // min : 最小值 min_element cout &lt;&lt; std::min(1, 2) &lt;&lt; endl; cout &lt;&lt; *min_element(second.begin(), second.end()) &lt;&lt; endl; // mismatch : 查找第一次不同的地方 // pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt; // result=mismatch(first.begin(), first.end(), second.begin(), // second.end()); auto result = mismatch(first.begin(), first.end(), second.begin(), second.end()); cout &lt;&lt; &quot;first:&quot; &lt;&lt; *result.first &lt;&lt; endl; cout &lt;&lt; &quot;second:&quot; &lt;&lt; *result.second &lt;&lt; endl; return 0; &#125; 算术类算法 accumulate：求和算法 partial_sum: 逐步求和 iner_product:求积 adjacent_difference:求差 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;numeric&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // accumulate：求和算法 vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; int sum = 0; sum = accumulate(vec.begin(), vec.end(), 0); cout &lt;&lt; &quot;sum:&quot; &lt;&lt; sum &lt;&lt; endl; // partial_sum: 逐步求和 vector&lt;int&gt; result(vec.size()); partial_sum(vec.begin(), vec.end(), result.begin()); copy(result.begin(), result.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // iner_product : 求积 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; second = &#123;5, 4, 3, 2, 1&#125;; cout &lt;&lt; inner_product(first.begin(), first.end(), second.begin(), 0) &lt;&lt; endl; // adjacent_difference : 求差 vector&lt;int&gt; testData = &#123;8, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; cout &lt;&lt; &quot;求差:&quot;; adjacent_difference(testData.begin(), testData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; return 0; &#125; 排列组合算法 next_premutation: 下一个序列 prev_premutation: 上一个序列 //假设:已有序列&#123;a,b,c&#125; 并且 a&lt;b&lt;c 例如&#123;1,2,3&#125; //下一个序列: &#123;a ,c, b&#125; &#123;1,3,2&#125;就是&#123;1,2,3&#125;下一个序列 //反之: &#123;a,c,b&#125; 上一个序列就是&#123;a,b,c&#125; &#123;1,3,2&#125; 上一个序列是&#123;1,2,3&#125; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; vector&lt;int&gt; data = &#123;1, 2, 3, 4&#125;; int index = 0; cout &lt;&lt; &quot;升序:&quot; &lt;&lt; endl; do &#123; cout &lt;&lt; &quot;第 &quot; &lt;&lt; index + 1 &lt;&lt; &quot; 组合:&quot;; copy(data.begin(), data.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; index++; &#125; while (next_permutation(data.begin(), data.end())); vector&lt;int&gt; test = &#123;1, 2, 3, 4&#125;; reverse(test.begin(), test.end()); cout &lt;&lt; &quot;降序:&quot; &lt;&lt; endl; index = 0; do &#123; cout &lt;&lt; &quot;第 &quot; &lt;&lt; index + 1 &lt;&lt; &quot; 组合:&quot;; copy(test.begin(), test.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; index++; &#125; while (prev_permutation(test.begin(), test.end())); return 0; &#125; 生成异变算法 for_each: 遍历 fill:填充 fill_n: 前n个元素用value填充 generate: 填充 generate_n: 填充n个元素 transform : 一元操作 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // for_each: 遍历 vector&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7&#125;; for_each(data.begin(), data.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; for_each(data.begin(), data.end(), [](int&amp; data) &#123; data *= 2; &#125;); for_each(data.begin(), data.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // fill : 填充 vector&lt;int&gt; vec(3); fill(vec.begin(), vec.end(), 666); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // fill_n : 前n个元素用value填充 fill(vec.begin(), vec.begin() + 2, 888); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // generate : 填充 generate(vec.begin(), vec.end(), []() &#123; return 999; &#125;); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // generate_n : 填充n个元素 generate_n(vec.begin(), 2, []() &#123; return 222; &#125;); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // transform : 一元操作 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;int&gt; second(first.size()); transform(first.begin(), first.end(), second.begin(), [](int data) &#123; return -data; &#125;); for (auto&amp; v : second) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 堆算法 make_heap: 创建堆 push_heap: 入堆 pop_heap: 出堆 (单纯把元素放到容器后面，手动调用相应的尾部删除函数) sort_heap:堆排序 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; //默认形式大顶堆 vector&lt;int&gt; data = &#123;4, 2, 1, 0, 8&#125;; make_heap(data.begin(), data.end()); make_heap(data.begin(), data.end(), less&lt;int&gt;()); //和默认方式一样是大顶堆 for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //从小到大 sort_heap(data.begin(), data.end(), less&lt;int&gt;()); //需要和创建的准则一致 for_each(data.begin(), data.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; //小顶堆 vector&lt;int&gt; test = &#123;4, 2, 1, 0, 8&#125;; make_heap(test.begin(), test.end(), greater&lt;int&gt;()); for_each(test.begin(), test.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; sort_heap(test.begin(), test.end(), greater&lt;int&gt;()); //需要和创建的准则一致 for_each(test.begin(), test.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; vector&lt;int&gt; vec; make_heap(vec.begin(), vec.end()); vec.push_back(1); push_heap(vec.begin(), vec.end()); //调整数据位置 vec.push_back(5); push_heap(vec.begin(), vec.end()); vec.push_back(4); push_heap(vec.begin(), vec.end()); vec.push_back(0); push_heap(vec.begin(), vec.end()); vec.push_back(8); push_heap(vec.begin(), vec.end()); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; while (!vec.empty()) &#123; pop_heap(vec.begin(), vec.end()); //调整数据 cout &lt;&lt; vec.back() &lt;&lt; &quot; &quot;; vec.pop_back(); make_heap(vec.begin(), vec.end()); &#125; cout &lt;&lt; endl; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库算法篇(查找,排序,集合)","slug":"C++标准模板库算法篇(查找,排序,集合)","date":"2022-06-13T07:56:33.000Z","updated":"2022-09-18T02:36:09.553Z","comments":true,"path":"2022/06/13/C++标准模板库算法篇(查找,排序,集合)/","link":"","permalink":"http://goskp.github.io/2022/06/13/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%97%E6%B3%95%E7%AF%87(%E6%9F%A5%E6%89%BE,%E6%8E%92%E5%BA%8F,%E9%9B%86%E5%90%88)/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 查找算法基本查找 find: 区间查找 find_if: 条件查找 find_first_of: 查找区间第一次出现值 adjacent_find:查找第一次重复的值 search: 子序列查找 search_n: 子序列查找出现的次数 统计查找 count：区间统计 count_if: 条件统计 equal: 比较 有序查找 binary_search: 二分查找 upper_bound: 查找最后一个大于查找值 lower_bound: 大于等于查找值 eqaul_range：区间比较 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM(string name = &quot;&quot;, int score = 0) : name(name), score(score) &#123;&#125; int getScore() const &#123; return score; &#125; private: string name; int score; &#125;; class System &#123; public: void insertData(const MM&amp; mm) &#123; mmData.push_back(mm); &#125; int getOK() &#123; return count_if(mmData.begin(), mmData.end(), [](const MM&amp; mm) &#123; return mm.getScore() &gt;= 60; &#125;); &#125; int getNo() &#123; return count_if(mmData.begin(), mmData.end(), [](const MM&amp; mm) &#123; return mm.getScore() &lt; 60; &#125;); &#125; private: vector&lt;MM&gt; mmData; &#125;; void testUserData() &#123; System* p = new System; p-&gt;insertData(MM(&quot;name1&quot;, 59)); p-&gt;insertData(MM(&quot;name2&quot;, 92)); p-&gt;insertData(MM(&quot;name3&quot;, 88)); p-&gt;insertData(MM(&quot;name4&quot;, 54)); p-&gt;insertData(MM(&quot;name5&quot;, 25)); cout &lt;&lt; &quot;及格人数:&quot; &lt;&lt; p-&gt;getOK() &lt;&lt; endl; cout &lt;&lt; &quot;不及格人数:&quot; &lt;&lt; p-&gt;getNo() &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; int array[10] = &#123;1, 3, 5, 7, 9, 2, 4, 6, 8, 10&#125;; vector&lt;int&gt; testData; testData.assign(array, array + 10); // 1.区间查找 auto it = find(testData.begin(), testData.end(), 3); if (it != testData.end()) cout &lt;&lt; *it &lt;&lt; endl; // 2.条件查找 it = find_if(testData.begin(), testData.end(), [](int data) &#123; return data &gt; 8; &#125;); cout &lt;&lt; *it &lt;&lt; endl; // 3.查找第一次出现的 int temp[] = &#123;15, 10, 6&#125;; cout &lt;&lt; *find_first_of(testData.begin(), testData.end(), temp, temp + 3) &lt;&lt; endl; // 4.查找第一次重复的元素 vector&lt;int&gt; value = &#123;1, 2, 3, 3, 2, 4, 4, 9, 9, 5, 5, 9, 9, 9&#125;; cout &lt;&lt; *adjacent_find(value.begin(), value.end()) &lt;&lt; endl; // 5.区间查找 vector&lt;int&gt; num = &#123;1, 2, 3&#125;; cout &lt;&lt; *search(value.begin(), value.end(), num.begin(), num.end()) &lt;&lt; endl; string str = &#123;&quot;ILoveyouIMissyou&quot;&#125;; string str2 = &#123;&quot;you&quot;&#125;; cout &lt;&lt; *search(str.begin(), str.end(), str2.begin(), str2.end()) &lt;&lt; endl; // 6.查找出现次数 cout &lt;&lt; *search_n(value.begin(), value.end(), 3, 9) &lt;&lt; endl; // 7.统计出现次数 cout &lt;&lt; count(value.begin(), value.end(), 2) &lt;&lt; endl; // 8.条件统计出现次数 cout &lt;&lt; count_if(value.begin(), value.end(), [](int i) &#123; return i &gt;= 6; &#125;) &lt;&lt; endl; // 9.相等比较 cout &lt;&lt; boolalpha &lt;&lt; equal(value.begin(), value.end(), num.begin(), num.end()) &lt;&lt; endl; // 10.二分查找 vector&lt;int&gt; order = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; cout &lt;&lt; boolalpha &lt;&lt; binary_search(order.begin(), order.end(), 5) &lt;&lt; endl; // 11.大于查找 cout &lt;&lt; *upper_bound(order.begin(), order.end(), 7) &lt;&lt; endl; // 12.大于等于 cout &lt;&lt; *lower_bound(order.begin(), order.end(), 7) &lt;&lt; endl; // 13. 大于等于的综合体: first:等于的值，second存大于值 cout &lt;&lt; *equal_range(order.begin(), order.end(), 7).second &lt;&lt; endl; cout &lt;&lt; *equal_range(order.begin(), order.end(), 7).first &lt;&lt; endl; testUserData(); return 0; &#125; 排序和通用算法 sort：排序 stable_sort: 保持相对顺序的排序 merge:归并排序，不会改变原容器数据 inplace_merge: 归并排序，直接作用在原容器上 nth_element:关键字排序 partition: 分类处理 (按特定条件把数据分为两堆) stable_partion: 保持数据相对顺序，分类处理 partial_sort:局部排序 partial_sort_copy: 局部排序结果放到新容器中 random_shuffle: 乱序算法 reverse: 逆序 reverse_copy: 逆序结果另存 rotate: 移动元素到末位 rotate_copy: 移位后的结果另存 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // 1.基本排序 vector&lt;int&gt; vec = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; sort(vec.begin(), vec.end()); sort(vec.begin(), vec.end(), less&lt;int&gt;&#123;&#125;); copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; sort(vec.begin(), vec.end(), greater&lt;int&gt;&#123;&#125;); copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // list有内置的sort算法，不能直接用sort算法 list&lt;int&gt; mylist = &#123;1, 2, 3, 4, 9, 8&#125;; mylist.sort(); copy(mylist.begin(), mylist.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 2.保持相对顺序的排序 vector&lt;double&gt; dNum = &#123;1.11, 2.22, 3.33, 4.44, 1.11, 1.10, 4.6, 4.5&#125;; stable_sort(dNum.begin(), dNum.end(), [](double a, double b) &#123; return int(a) &lt; int(b); &#125;); copy(dNum.begin(), dNum.end(), ostream_iterator&lt;double&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 3.归并排序 vector&lt;int&gt; order = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; vector&lt;int&gt; result(order.size()); merge(order.begin(), order.begin() + 5, order.begin() + 5, order.end(), result.begin()); copy(result.begin(), result.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 4.改变原容器的归并 inplace_merge(order.begin(), order.begin() + 5, order.end()); copy(order.begin(), order.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 5.关键字排序 vector&lt;int&gt; element = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; nth_element(element.begin(), element.begin() + 2, element.end()); copy(element.begin(), element.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 6.分类处理 vector&lt;int&gt; pData = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; partition(pData.begin(), pData.end(), [](int data) &#123; return data &lt; 6; &#125;); copy(pData.begin(), pData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 7.保持相对顺序分类处理 vector&lt;double&gt; dNum2 = &#123;1.11, 2.22, 3.33, 4.44, 1.11, 1.10, 4.6, 4.5&#125;; stable_partition(dNum2.begin(), dNum2.end(), [](double a) &#123; return int(a) &lt; 2; &#125;); copy(dNum2.begin(), dNum2.end(), ostream_iterator&lt;double&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 8.局部排序 按元素大小顺序，选取有序的放在前面 vector&lt;int&gt; testData = &#123;19, 23, 65, 77, 45, 34&#125;; partial_sort(testData.begin(), testData.begin() + 3, testData.end()); copy(testData.begin(), testData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 9.局部排序结果另存 vector&lt;int&gt; pResult(3); partial_sort_copy(testData.begin(), testData.begin() + 3, pResult.begin(), pResult.end()); copy(pResult.begin(), pResult.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 10.乱序算法 srand((unsigned int)time(nullptr)); string str = &quot;ABCDEFG&quot;; random_shuffle(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl; // 11.反转 str = &quot;ILoveyou&quot;; reverse(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl; // 12.反转另存 string strResult; strResult.resize(str.size()); reverse_copy(str.begin(), str.end(), strResult.begin()); cout &lt;&lt; strResult &lt;&lt; endl; // 13.移动元素到末位 string testStr = &quot;ILoveyou&quot;; rotate(testStr.begin(), testStr.begin() + 4, testStr.end()); cout &lt;&lt; testStr &lt;&lt; endl; // 14.移位另存 string rotateStr; rotateStr.resize(testStr.size()); rotate_copy(testStr.begin(), testStr.begin() + 4, testStr.end(), rotateStr.begin()); cout &lt;&lt; rotateStr &lt;&lt; endl; return 0; &#125; 集合类算法 set_union: 并集 set_intersetction: 交集 set_difference: 差集 set_symmetric_difference: 对称差集 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; vector&lt;int&gt; one = &#123;1, 2, 3, 7, 8&#125;; vector&lt;int&gt; two = &#123;4, 5, 6, 7, 8&#125;; // 1.并集 set_union(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 2.交集 set_intersection(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 3.求差集 set_difference(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 4.对称差集 (并集减去交集) set_symmetric_difference(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之迭代器","slug":"C++标准模板库之迭代器","date":"2022-06-09T08:47:20.000Z","updated":"2022-09-21T12:49:23.186Z","comments":true,"path":"2022/06/09/C++标准模板库之迭代器/","link":"","permalink":"http://goskp.github.io/2022/06/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 迭代器迭代器就是类中类，通过类中类的对象去访问数据(模仿指针行为) STL之迭代器定义的方式分类 正向迭代器 容器名::iterator it begin() end() 反向迭代器 容器名::reverse_iterator it rbegin() rend() 常正向迭代器 容器名::const _iterator it cbegin() cend() 常反向迭代器 容器名::const _reverse_iterator it crbegin() crend() 功能方式分类 正向迭代器 双向迭代器 随机访问迭代器 STL容器迭代器类型 容器名 迭代器类型 array 随机访问 vector 随机访问 deque 随机访问 list 双向 set&#x2F;multiset 双向 map&#x2F;multimap 双向 stack&#x2F;queue&#x2F;priority_queue 不支持迭代器 迭代器辅助函数 advance(iterator it,n): it+n; distance(iterator begin,iterator end): end一定在begin后面 iter_swap(iteartor first,iterator second); 流型迭代器 输出流型迭代器 ostream_iterator&lt;_Ty&gt; object(ostream&amp; object); ostream_iterator&lt;_Ty&gt; object(ostream&amp; object,char* str); object&#x3D;value; &#x2F;&#x2F;等效 cout&lt;&lt;value; 输入流型迭代器 istream_iterator&lt;_Ty&gt; object; &#x2F;&#x2F;EOF_OF_STREAM 输入的数据和要求的不同，产生错误流 istream_iterator&lt;_Ty&gt; object(istream&amp; object); *object &#x2F;&#x2F;等效做cin&gt;&gt;操作 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;Algorithm&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; vector&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;int&gt;::iterator it = data.begin(); vector&lt;int&gt;::reverse_iterator rit = data.rbegin(); vector&lt;int&gt;::const_iterator cit = data.cbegin(); vector&lt;int&gt;::const_reverse_iterator crit = data.crbegin(); // begin可以表示第一个元素，end不表示最后元素 // cout &lt;&lt; *data.end() &lt;&lt; endl; //越界访问 cout &lt;&lt; *data.begin() &lt;&lt; endl; cout &lt;&lt; *data.rbegin() &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; distance(data.begin(), data.end()) &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; data.size() &lt;&lt; endl; cout &lt;&lt; &quot;distance:&quot; &lt;&lt; find(data.begin(), data.end(), 5) - data.begin() &lt;&lt; endl; iter_swap(data.begin(), data.end() - 1); for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; ostream_iterator&lt;int&gt; outIterator(cout); outIterator = 1234; // copy(src,end,dst); vector&lt;int&gt; dst(data.size()); copy(data.begin(), data.end(), dst.begin()); cout &lt;&lt; endl &lt;&lt; &quot;copy函数结合流型迭代器去做数据打印&quot; &lt;&lt; endl; copy(dst.begin(), dst.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl &lt;&lt; &quot;输入流型迭代器做数据输入:&quot; &lt;&lt; endl; vector&lt;int&gt; inputData; istream_iterator&lt;int&gt; EOS; istream_iterator&lt;int&gt; inputIter(cin); while (inputIter != EOS) &#123; inputData.push_back(*inputIter); ++inputIter; &#125; cout &lt;&lt; &quot;输入数据:&quot; &lt;&lt; endl; for (auto&amp; v : inputData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; STL之仿函数仿函数： 仿函数是让类名模仿函数调用的行为(函数调用:函数名(参数)) 仿函数： 类名(参数) 使用 仿函数实质是重载()运算符 仿函数一般是作为排序准则，或者比较准则 #include &lt;functional&gt; #include &lt;iostream&gt; using namespace std; class Sum &#123; public: int operator()(const int&amp; a, const int&amp; b) const &#123; return a + b; &#125; &#125;; template &lt;class _Ty, class _Pr&gt; void printSum(_Ty a, _Ty b, _Pr Pr) &#123; cout &lt;&lt; Pr(a, b) &lt;&lt; endl; &#125; void testFunctional() &#123; //仿函数的调用方式 Sum object; cout &lt;&lt; object(1, 2) &lt;&lt; endl; //重载隐式调用形态 cout &lt;&lt; object.operator()(1, 2) &lt;&lt; endl; //重载的显示调用形态 cout &lt;&lt; Sum()(1, 2) &lt;&lt; endl; //匿名对象调用 printSum(1, 2, Sum()); &#125; int main(int argc, char** argv) &#123; testFunctional(); return 0; &#125; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;set&gt; using namespace std; class Sum &#123; public: int operator()(const int&amp; a, const int&amp; b) const &#123; return a + b; &#125; &#125;; template &lt;class _Ty, class _Pr&gt; void printSum(_Ty a, _Ty b, _Pr Pr) &#123; cout &lt;&lt; Pr(a, b) &lt;&lt; endl; &#125; void testFunctional() &#123; //仿函数的调用方式 Sum object; cout &lt;&lt; object(1, 2) &lt;&lt; endl; //重载隐式调用形态 cout &lt;&lt; object.operator()(1, 2) &lt;&lt; endl; //重载的显示调用形态 cout &lt;&lt; Sum()(1, 2) &lt;&lt; endl; //匿名对象调用 printSum(1, 2, Sum()); &#125; void testCppFunctional() &#123; cout &lt;&lt; plus&lt;int&gt;()(1, 2) &lt;&lt; endl; cout &lt;&lt; minus&lt;int&gt;()(1, 2) &lt;&lt; endl; set&lt;int, greater&lt;int&gt;&gt; sData = &#123;1, 2, 3, 4, 5, 6&#125;; /* //set map priority_queue sort算法 greater: &gt; less: &lt; less_equal: &lt;= not_equal_to: != equal_to :== */ //逻辑与 cout &lt;&lt; logical_and&lt;int&gt;()(1, 2) &lt;&lt; endl; //位与 cout &lt;&lt; bit_and&lt;int&gt;()(1, 2) &lt;&lt; endl; cout &lt;&lt; (1 | 2) &lt;&lt; endl; copy(sData.begin(), sData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); // set&lt;int, greater_equal&lt;int&gt;&gt; sData2 = &#123; 1,2,3,4,4,5,5,6 &#125;; // copy(sData2.begin(), sData2.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); &#125; int main(int argc, char** argv) &#123; testFunctional(); testCppFunctional(); return 0; &#125; Lambda表达式//完整组成 [捕获方式](参数列表) mutable exception -&gt;函数返回值类型&#123;函数体;&#125; //1.使用的时候直接用auto类型推断类型接受Lambda表达式的返回值 //2.使用的时候，除了捕获方式和函数之外的所有东西都可以省略 [捕获方式]&#123;函数体;&#125; //捕获方式: 指的Lambda函数体使用之外的变量的方式 []: 不捕获任何东西 [=]:用值的方式 [&amp;]:引用的方式 [this]:成员函数 [&amp;value]: value用引用的方式 [=,&amp;value]: valu用引用方式，其他变量用值的方式 Lambda基本操作 用Lambda表达式调用函数 Lambda缺省写法 Lambda捕获方式的区别 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; class Test &#123; public: void print() &#123; cout &lt;&lt; &quot;result:&quot; &lt;&lt; [this]() -&gt; int &#123; return this-&gt;age++; &#125;() &lt;&lt; endl; cout &lt;&lt; &quot;result:&quot; &lt;&lt; this-&gt;age++ &lt;&lt; endl; &#125; int&amp; GetAge() &#123; return age; &#125;; private: string name = &quot;默认&quot;; int age = 19; &#125;; void modifyTest(Test&amp; test) &#123; test.GetAge()++; &#125; void print(int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125; int main(int argc, char** argv) &#123; int a = 1; int b = 2; cout &lt;&lt; Max(a, b) &lt;&lt; endl; auto func = [](int a, int b) mutable noexcept -&gt; int &#123; return a &gt; b ? a : b; &#125;; cout &lt;&lt; func(a, b) &lt;&lt; endl; //一步到位 cout &lt;&lt; [](int a, int b) mutable noexcept -&gt; int &#123; return a &gt; b ? a : b; &#125;(a, b) &lt;&lt; endl; //缺省版本 cout &lt;&lt; [](int a, int b) &#123; return a &gt; b ? a : b; &#125;(a, b) &lt;&lt; endl; auto func2 = [=] &#123; return a &gt; b ? a : b; &#125;; //这个函数指针调用，结果永远都是一样的，不因为值的改变而改变 cout &lt;&lt; func2() &lt;&lt; endl; //捕获方式的区别 b = 4; cout &lt;&lt; func2() &lt;&lt; endl; auto func3 = [&amp;] &#123; return a &gt; b ? a : b; &#125;; cout &lt;&lt; func3() &lt;&lt; endl; // 4 b = 5; cout &lt;&lt; func3() &lt;&lt; endl; // 5 // Lambda用在以函数指针充当函数参数的地方 // for_each()算法 vector&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; for_each(data.begin(), data.end(), print); cout &lt;&lt; endl; for_each(data.begin(), data.end(), [](int data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; cout &lt;&lt; *find_if(data.begin(), data.end(), [](int data) &#123; return data == 5; &#125;) &lt;&lt; endl; for_each(data.begin(), data.end(), [](int&amp; data) &#123; data *= data; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; return 0; &#125; 函数包装器函数包装器可以把函数指针封装一个对象，让对象去充当函数名的功能 包装普通函数 包装类的静态函数 包装仿函数 包装转换成指针对象 //基本创建语法 // function&lt;函数返回值类型(参数类型)&gt; 对象名(函数指针) #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; using FUNC = void (*)(int, int); class Test &#123; public: static void print(int a, int b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125; void operator()(const string&amp; str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; operator FUNC() &#123; return print; &#125; &#125;; int main(int argc, char** argv) &#123; // 1.包装普通函数 function&lt;int(int, int)&gt; FuncMax(Max); cout &lt;&lt; FuncMax(1, 2) &lt;&lt; endl; // 2.包装静态成员函数 function&lt;void(int, int)&gt; sFunc = &amp;Test::print; sFunc(1, 2); // 3.包装仿函数 Test test; function&lt;void(const string&amp;)&gt; Func = test; Func(&quot;仿函数&quot;); test(&quot;仿函数&quot;); // 4.包装隐式转换的对象 Test object; function&lt;void(int, int)&gt; funO = object; funO(2, 3); return 0; &#125; 函数适配器函数适配就是让函数指针调用时候函数后绑定特定参数，从而让函数指针存在多种调用形态 bind函数基本用法 绑定普通函数 绑定类中成员函数指针 仿函数的绑定 结合包装器去使用 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; class Test &#123; public: void printTest(int a, int b, int c) &#123; cout &lt;&lt; a + b + c &lt;&lt; endl; &#125; &#125;; void print(int a, double b, string c) &#123; cout &lt;&lt; &quot;函数是适配器和包装器结合&quot; &lt;&lt; endl; &#125; void testBind() &#123; //正常包装 function&lt;void(int, double, string)&gt; func1 = print; func1(1, 1.1, &quot;普通函数&quot;); //正常适配 function&lt;void(int, double)&gt; func2 = bind(print, std::placeholders::_1, std::placeholders::_2, &quot;正常适配&quot;); func2(1, 1.1); //调整参数顺序 function&lt;void(double, int)&gt; func3 = bind(print, std::placeholders::_2, std::placeholders::_1, &quot;调整参数顺序&quot;); func3(1.11, 1); // print(double,string,int) function&lt;void(string, int, double)&gt; func4 = bind(print, std::placeholders::_2, std::placeholders::_3, std::placeholders::_1); func4(&quot;调整所有参数&quot;, 4, 4.11); &#125; int main(int argc, char** argv) &#123; // 1.绑定普通函数 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; // std::placeholders::_1占位符 auto pMax1 = bind(Max, std::placeholders::_1, 100); // b=100; cout &lt;&lt; pMax1(1) &lt;&lt; endl; auto pMax2 = bind(Max, 10, 20); cout &lt;&lt; pMax2() &lt;&lt; endl; cout &lt;&lt; pMax2(12, 34) &lt;&lt; endl; //参数一旦被绑定，调用传参就没意义 // 2.绑定类中的成员函数指针 //多线程中 Test test; auto testFunc = &amp;Test::printTest; (test.*testFunc)(1, 2, 3); auto func = bind(&amp;Test::printTest, &amp;test, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); func(1, 2, 3); // 3.一些算法中 // count_if vector&lt;int&gt; data = &#123;10, 20, 80, 40, 70, 54&#125;; int count = count_if(data.begin(), data.end(), [](int value) &#123; return value &lt; 60; &#125;); cout &lt;&lt; &quot;不及格人数:&quot; &lt;&lt; count &lt;&lt; endl; // less&lt;int&gt; cout &lt;&lt; &quot;不及格人数: &quot; &lt;&lt; count_if(data.begin(), data.end(), bind(less&lt;int&gt;(), std::placeholders::_1, 60)) &lt;&lt; endl; // 4.结合函数包装器使用 testBind(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之initalizer_list与set与map","slug":"C++标准模板库之initalizer_list与set与map","date":"2022-06-04T08:41:40.000Z","updated":"2022-10-12T01:26:15.940Z","comments":true,"path":"2022/06/04/C++标准模板库之initalizer_list与set与map/","link":"","permalink":"http://goskp.github.io/2022/06/04/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Binitalizer_list%E4%B8%8Eset%E4%B8%8Emap/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 STL之initializer_listinitializer_list是列表数据，用{}括起来的数据 #include &lt;initializer_list&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; MM(string name) : name(name), age(0) &#123;&#125; protected: string name; int age; &#125;; template &lt;class _Ty&gt; class my_vector &#123; public: my_vector(int size) : curSize(0) &#123; mem = new _Ty[size]; &#125; my_vector(const initializer_list&lt;_Ty&gt;&amp; data) : my_vector(data.size()) &#123; for (auto&amp; v : data) &#123; mem[curSize++] = v; &#125; &#125; void print() &#123; for (int i = 0; i &lt; curSize; i++) &#123; cout &lt;&lt; mem[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; protected: _Ty* mem; int curSize; &#125;; int sum(initializer_list&lt;int&gt; data) &#123; int count = 0; for (auto&amp; v : data) &#123; count += v; &#125; return count; &#125; int main(int argc, char** argv) &#123; initializer_list&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; MM mm = &#123;&quot;美女&quot;&#125;; vector&lt;int&gt; vec1 = &#123;1, 2, 3, 4&#125;; vector&lt;int&gt; vec2 = &#123;1, 2, 3&#125;; my_vector&lt;int&gt; my_vec1 = &#123;1, 2, 3, 4&#125;; my_vector&lt;int&gt; my_vec2 = &#123;1, 2&#125;; my_vec1.print(); my_vec2.print(); cout &lt;&lt; sum(&#123;1, 2&#125;) &lt;&lt; endl; cout &lt;&lt; sum(&#123;1, 2, 3, 4&#125;) &lt;&lt; endl; cout &lt;&lt; sum(&#123;1, 2, 3, 4, 5, 6&#125;) &lt;&lt; endl; return 0; &#125; STL之setset叫做集合的意思，set特性有以下两点: 有序性:默认情况是从小到大排序 唯一性:相同的值 只保留一个 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; string GetName() const &#123; return name; &#125; int GetAge() const &#123; return age; &#125; private: string name; int age; &#125;; //仿函数 struct CompareByName &#123; bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetName() &lt; object2.GetName(); &#125; &#125;; struct CompareByAge &#123; bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; &#125;; int main(int argc, char* argv[]) &#123; set&lt;int&gt; sData = &#123;00, 00, 00, 99, 99, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; for (auto&amp; v : sData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (set&lt;int&gt;::iterator it = sData.begin(); it != sData.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; sData.size() &lt;&lt; endl; sData.insert(511); cout &lt;&lt; &quot;size&quot; &lt;&lt; sData.size() &lt;&lt; endl; for (auto&amp; v : sData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; sData.erase(find(sData.begin(), sData.end(), 5)); cout &lt;&lt; &quot;size:&quot; &lt;&lt; sData.size() &lt;&lt; endl; multiset&lt;int&gt; mulData = &#123;0, 1, 2, 3, 4, 5, 6, 7, 231, 2, 0000, 0&#125;; for (auto&amp; v : mulData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //默认从小到大 set&lt;int, less&lt;int&gt;&gt; lSet; set&lt;int, greater&lt;int&gt;&gt; gSet = &#123;1, 2, 3, 4, 5, 6, 7&#125;; for (auto&amp; v : gSet) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; set&lt;MM, CompareByName&gt; mmData; mmData.insert(MM(&quot;name1&quot;, 18)); mmData.insert(MM(&quot;name2&quot;, 21)); mmData.insert(MM(&quot;name3&quot;, 111)); for (auto&amp; v : mmData) &#123; cout &lt;&lt; v.GetName() &lt;&lt; &quot; &quot; &lt;&lt; v.GetAge() &lt;&lt; endl; &#125; cout &lt;&lt; endl; set&lt;MM, CompareByAge&gt; mmData2; mmData2.insert(MM(&quot;name1&quot;, 18)); mmData2.insert(MM(&quot;name2&quot;, 21)); mmData2.insert(MM(&quot;name3&quot;, 111)); for (auto&amp; v : mmData2) &#123; cout &lt;&lt; v.GetName() &lt;&lt; &quot; &quot; &lt;&lt; v.GetAge() &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; STL之mapmap叫做映射，y&#x3D;x，所谓的映射 就是一种对应关系，数组是下标对应数据的一种关系 map存储的数据是数对类型:pair类型 有序性: 默认按照first从小到大排序 唯一性:first 唯一 #include &lt;Algorithm&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; using namespace std; // template &lt;class _Ty1,class _Ty2&gt; // bool constexpr operator==(const pair&lt;_Ty1, _Ty2&gt;&amp; object, const _Ty1&amp; value) //&#123; // return object.first == value; // &#125; bool Compare(const pair&lt;int, string&gt;&amp; object) &#123; return object.first == 3; &#125; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; string GetName() const &#123; return name; &#125; int GetAge() const &#123; return age; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot; &quot; &lt;&lt; object.age; return out; &#125; protected: string name; int age; &#125;; struct CompareAge &#123; bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; &#125;; class Score &#123; public: Score() &#123;&#125; Score(int math, int english, int py) : math(math), english(english), py(py) &#123;&#125; int GetMath() const &#123; return math; &#125; int GetEnglish() const &#123; return english; &#125; int GetPy() const &#123; return py; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Score&amp; object) &#123; out &lt;&lt; object.math &lt;&lt; &quot; &quot; &lt;&lt; object.english &lt;&lt; &quot; &quot; &lt;&lt; object.py; return out; &#125; private: int math; int english; int py; &#125;; void testUserData() &#123; map&lt;MM, Score, CompareAge&gt; mmData; //底层用树实现 mmData[MM(&quot;小芳&quot;, 18)] = Score(98, 99, 100); mmData[MM(&quot;小妹&quot;, 20)] = Score(99, 99, 100); mmData[MM(&quot;小喵&quot;, 17)] = Score(100, 100, 100); for (auto&amp; v : mmData) &#123; // cout &lt;&lt; v.first.GetName() &lt;&lt; &quot; &quot; &lt;&lt; v.first.GetAge() &lt;&lt; &quot; &quot; // &lt;&lt; v.second.GetMath() &lt;&lt; &quot; &quot; &lt;&lt; v.second.GetEnglish() &lt;&lt; &quot; &quot; &lt;&lt; // v.second.GetPy() &lt;&lt; endl; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; //了解一下，复杂嵌套 map&lt;map&lt;MM, Score&gt;, map&lt;MM, Score&gt;&gt; mData; &#125; void testNewMap() &#123; unordered_map&lt;int, string&gt; hashMap; //底层是hash结构 //无序，可以避免重复 hashMap[1] = string(&quot;IMissyou&quot;); hashMap[-1] = string(&quot;ILoveyou&quot;); hashMap[-1] = string(&quot;ILoveyou&quot;); for (auto&amp; v : hashMap) &#123; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; &#125; int main(int argc, char* argv[]) &#123; //单映射 map&lt;int, string&gt; mData; pair&lt;int, string&gt; temp = &#123;1, &quot;Love&quot;&#125;; cout &lt;&lt; temp.first &lt;&lt; &quot; &quot; &lt;&lt; temp.second &lt;&lt; endl; mData[0] = string(&quot;IMissyou&quot;); mData[-100] = string(&quot;I&quot;); mData.insert(temp); mData.insert(pair&lt;int, string&gt;(3, &quot;无名对象&quot;)); mData.insert(make_pair&lt;int, string&gt;(5, &quot;第三方函数&quot;)); mData.insert(pair&lt;int, string&gt;(3, &quot;重复处理&quot;)); //插入失败 for (auto&amp; v : mData) &#123; cout &lt;&lt; v.first &lt;&lt; &quot;:&quot; &lt;&lt; v.second &lt;&lt; endl; &#125; mData.erase(find_if(mData.begin(), mData.end(), Compare)); cout &lt;&lt; &quot;迭代器遍历....&quot; &lt;&lt; endl; for (map&lt;int, string&gt;::iterator it = mData.begin(); it != mData.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; //多重映射 //有序性 //不支持下表法插入 cout &lt;&lt; &quot;多重映射.......&quot; &lt;&lt; endl; multimap&lt;string, string&gt; strData; // strData[string(&quot;ds&quot;)] = string(&quot;ddsfd&quot;); strData.insert(pair&lt;string, string&gt;(&quot;A&quot;, &quot;我很帅&quot;)); strData.insert(make_pair&lt;string, string&gt;(&quot;B&quot;, &quot;你很帅&quot;)); strData.insert(pair&lt;string, string&gt;(&quot;A&quot;, &quot;我很帅&quot;)); strData.insert(make_pair&lt;string, string&gt;(&quot;B&quot;, &quot;你很帅&quot;)); for (auto&amp; v : strData) &#123; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; //从大到小 cout &lt;&lt; &quot;传入比较准则:&quot; &lt;&lt; endl; map&lt;int, string, greater&lt;int&gt;&gt; testData; testData[1] = &quot;sdfds&quot;; testData[-1] = &quot;dfssdfsdf&quot;; testData[23] = &quot;sdfsdfsd&quot;; for (auto&amp; v : testData) &#123; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; //操作自定义类型数据 testUserData(); testNewMap(); return 0; &#125; STL之tuple#include &lt;Algorithm&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; using namespace std; void testCreate() &#123; tuple&lt;string, int, double, double, double&gt; mmData = &#123;&quot;小芳&quot;, 18, 100.0, 100.0, 100.0&#125;; tuple&lt;string, int&gt; mm = &#123;&quot;小芳&quot;, 29&#125;; tuple&lt;string, int&gt; mm2 = make_tuple(&quot;小丽&quot;, 30); tuple&lt;string, string&gt; mm3 = forward_as_tuple(&quot;小妹&quot;, &quot;很美&quot;); tuple&lt;string&gt; str[4]; &#125; void visitedData() &#123; tuple&lt;string, int, int&gt; tup = &#123;&quot;MM&quot;, 18, 1001&#125;; // get方法获取 cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; &quot; &quot; &lt;&lt; get&lt;1&gt;(tup) &lt;&lt; &quot; &quot; &lt;&lt; get&lt;2&gt;(tup) &lt;&lt; endl; string name; int age; int num; tie(name, age, num) = tup; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; //忽略数据访问方式 tie(name, ignore, ignore) = tup; cout &lt;&lt; name &lt;&lt; endl; &#125; // tuple其他操作 void testCatTuple() &#123; tuple&lt;string, string&gt; student = &#123;&quot;小美&quot;, &quot;艺术学院&quot;&#125;; tuple&lt;int, int&gt; info = &#123;18, 1001&#125;; auto mmInfo = tuple_cat(student, info); string name; string college; int age; int num; tie(name, college, age, num) = mmInfo; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; college &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testCreate(); visitedData(); testCatTuple(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之list与stack与queue","slug":"C++标准模板库之list与stack与queue","date":"2022-05-30T04:35:09.000Z","updated":"2022-09-18T02:35:58.129Z","comments":true,"path":"2022/05/30/C++标准模板库之list与stack与queue/","link":"","permalink":"http://goskp.github.io/2022/05/30/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Blist%E4%B8%8Estack%E4%B8%8Equeue/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 STL之list#include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; private: string name; int age; int num; &#125;; int main(int argc, char** argv) &#123; //创建过程 list&lt;int&gt; iList; list&lt;string&gt; sList; list&lt;MM&gt; mmData; //插入删除遍历查找排序 for (int i = 0; i &lt; 3; i++) &#123; iList.push_back(i); //尾插法 iList.push_front(i); //头插法 &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iList.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; iList.empty() &lt;&lt; endl; iList.sort(); //不影响容器中元素的打印方式 for (auto&amp; v : iList) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; iList.reverse(); list&lt;int&gt;::iterator it; for (it = iList.begin(); it != iList.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //一边删除一边打印 while (!iList.empty()) &#123; cout &lt;&lt; iList.front() &lt;&lt; &quot; &quot;; //获取头元素 iList.pop_front(); //删除头部元素 &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iList.size() &lt;&lt; endl; //指定位置插入 sList.push_back(&quot;ILove&quot;); sList.push_back(&quot;you&quot;); sList.insert(find(sList.begin(), sList.end(), &quot;you&quot;), &quot;IMissyou&quot;); for (auto&amp; v : sList) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; sList.erase(find(sList.begin(), sList.end(), &quot;IMissyou&quot;)); for (auto&amp; v : sList) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 操作自定义类型#include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; &quot;\\t&quot; &lt;&lt; object.num; return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object) &#123; in &gt;&gt; object.name &gt;&gt; object.age &gt;&gt; object.num; return in; &#125; bool operator==(string name) const &#123; return this-&gt;name == name; &#125; // bool operator==(int age) const //&#123; // return this-&gt;age == age; // &#125; string GetName() const &#123; return name; &#125; // bool operator&lt;(const MM&amp; object) const //&#123; // return this-&gt;age &lt; object.age; // &#125; int GetAge() const &#123; return age; &#125; private: string name; int age; int num; &#125;; bool compareByAge(const MM&amp; object1, const MM&amp; object2) &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; bool compareByName(const MM&amp; object1, const MM&amp; object2) &#123; return object1.GetName() &lt; object2.GetName(); &#125; class MMSystem &#123; public: void Menu() &#123; cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t0.退出系统&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t1.录入数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t2.浏览数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t3.查找数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t4.修改数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t5.删除数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t6.排序显示&quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入你的选择(0-6):&quot;; &#125; void KeyDown() &#123; int userKey = 0; cin &gt;&gt; userKey; switch (userKey) &#123; case 0: exit(0); break; case 1: InsertData(); break; case 2: PrintData(); break; case 3: SearchData(); break; case 4: ModifyData(); break; case 5: DeleteData(); break; case 6: // mmData.sort(compareByAge); mmData.sort(compareByName); PrintData(); break; default: break; &#125; &#125; void InsertData() &#123; MM mm; cout &lt;&lt; &quot;请输入美女基本信息:&quot;; cin &gt;&gt; mm; mmData.push_back(mm); &#125; void PrintData() &#123; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;编号&quot; &lt;&lt; endl; for (auto&amp; v : mmData) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; void SearchData() &#123; string name; cout &lt;&lt; &quot;请输入查找的姓名:&quot;; cin &gt;&gt; name; list&lt;MM&gt;::iterator result = find(mmData.begin(), mmData.end(), name); if (result == mmData.end()) &#123; cout &lt;&lt; &quot;未找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *result &lt;&lt; endl; &#125; &#125; void ModifyData() &#123; string name; cout &lt;&lt; &quot;请输入修改的姓名:&quot;; cin &gt;&gt; name; list&lt;MM&gt;::iterator result = find(mmData.begin(), mmData.end(), name); if (result == mmData.end()) &#123; cout &lt;&lt; &quot;未找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;请输入新的信息:&quot; &lt;&lt; endl; cin &gt;&gt; *result; &#125; &#125; void DeleteData() &#123; string name; cout &lt;&lt; &quot;请输入删除的姓名:&quot;; cin &gt;&gt; name; // list&lt;MM&gt;::iterator result = find(mmData.begin(), mmData.end(), name); // if (result == mmData.end()) //&#123; // cout &lt;&lt; &quot;未找到指定位置&quot; &lt;&lt; endl; // &#125; // else //&#123; // mmData.erase(result); // &#125; list&lt;MM&gt;::iterator it; for (it = mmData.begin(); it != mmData.end();) &#123; if (it-&gt;GetName() == name) &#123; it = mmData.erase( it); //一定要这样的处理，删除后，当前it无效，不能做++运算 &#125; else &#123; it++; &#125; &#125; &#125; private: list&lt;MM&gt; mmData; &#125;; int main(int argc, char** argv) &#123; MMSystem* p = new MMSystem; while (1) &#123; p-&gt;Menu(); p-&gt;KeyDown(); system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; return 0; &#125; STL之stack栈的存储顺序是固定顺序: FILO 栈是不存在迭代器的 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main(int argc, char** argv) &#123; //后来居上的感觉 stack&lt;int&gt; istack; for (int i = 0; i &lt; 3; i++) &#123; istack.push(i); &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; istack.size() &lt;&lt; endl; while (!istack.empty()) &#123; cout &lt;&lt; istack.top() &lt;&lt; &quot; &quot;; //获取栈顶元素 istack.pop(); //出栈 &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; istack.size() &lt;&lt; endl; //悔棋，推箱子退步，寻路 //栈解决简单问题 //求进制 stack&lt;int&gt; binary; int num = 999; cout &lt;&lt; num &lt;&lt; &quot;的二进制是:&quot;; while (num) &#123; binary.push(num % 2); num /= 2; &#125; while (!binary.empty()) &#123; cout &lt;&lt; binary.top(); binary.pop(); &#125; cout &lt;&lt; endl; stack&lt;char&gt; hexData; num = 999; cout &lt;&lt; num &lt;&lt; &quot;的十六进制是:&quot;; while (num) &#123; if (num % 16 &lt; 10) &#123; hexData.push(num % 16 + &#39;0&#39;); &#125; else &#123; hexData.push(num % 16 - 10 + &#39;A&#39;); &#125; num /= 16; &#125; while (!hexData.empty()) &#123; cout &lt;&lt; hexData.top(); hexData.pop(); &#125; cout &lt;&lt; endl; return 0; &#125; STL之queue队列的存取顺序也是特定，普通队列先进先出，优先队列按照优先权出队 queue#include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main(int argc, char** argv) &#123; queue&lt;int&gt; iQue; for (int i = 0; i &lt; 3; i++) &#123; iQue.push(i); &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iQue.size() &lt;&lt; endl; cout &lt;&lt; &quot;back:&quot; &lt;&lt; iQue.back() &lt;&lt; endl; while (!iQue.empty()) &#123; cout &lt;&lt; iQue.front() &lt;&lt; &quot; &quot;; iQue.pop(); &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iQue.size() &lt;&lt; endl; return 0; &#125; deque#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; deque&lt;string&gt; queData; queData.push_back(&quot;尾部&quot;); queData.push_front(&quot;头部&quot;); while (!queData.empty()) &#123; cout &lt;&lt; queData.front(); queData.pop_front(); &#125; cout &lt;&lt; endl; deque&lt;string&gt; str; str.push_back(&quot;ILoveyou&quot;); str.push_front(&quot;IMissyou&quot;); while (!str.empty()) &#123; cout &lt;&lt; str.back(); str.pop_back(); &#125; cout &lt;&lt; endl; return 0; &#125; priority_queue#include &lt;ctime&gt; #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; string GetName() const &#123; return name; &#125; int GetAge() const &#123; return age; &#125; bool operator&lt;(const MM&amp; object) const &#123; return this-&gt;age &lt; object.age; &#125; private: string name; int age; &#125;; //仿函数 class CompareByName &#123; public: bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetName() &lt; object2.GetName(); &#125; &#125;; class CompareByAge &#123; public: bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; &#125;; int main(int argc, char** argv) &#123; //优先队列 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; lessQueue; priority_queue&lt;int, vector&lt;int&gt;&gt; lessQue; //和上面是等效的 srand((unsigned int)time(nullptr)); for (int i = 0; i &lt; 10; i++) &#123; lessQue.push(rand() % 100); &#125; while (!lessQue.empty()) &#123; cout &lt;&lt; lessQue.top() &lt;&lt; &quot; &quot;; lessQue.pop(); &#125; cout &lt;&lt; endl; //从小到大 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; greaterQue; for (int i = 0; i &lt; 10; i++) &#123; greaterQue.push(rand() % 100); &#125; while (!greaterQue.empty()) &#123; cout &lt;&lt; greaterQue.top() &lt;&lt; &quot; &quot;; greaterQue.pop(); &#125; priority_queue&lt;MM, vector&lt;MM&gt;, less&lt;MM&gt;&gt; mmData; mmData.push(MM(&quot;baby&quot;, 19)); mmData.push(MM(&quot;anni&quot;, 28)); mmData.push(MM(&quot;sanshui&quot;, 21)); cout &lt;&lt; endl; while (!mmData.empty()) &#123; cout &lt;&lt; mmData.top().GetName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mmData.top().GetAge() &lt;&lt; endl; mmData.pop(); &#125; priority_queue&lt;MM, vector&lt;MM&gt;, CompareByName&gt; mmData1; mmData1.push(MM(&quot;baby&quot;, 19)); mmData1.push(MM(&quot;anni&quot;, 28)); mmData1.push(MM(&quot;sanshui&quot;, 21)); cout &lt;&lt; endl; while (!mmData1.empty()) &#123; cout &lt;&lt; mmData1.top().GetName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mmData1.top().GetAge() &lt;&lt; endl; mmData1.pop(); &#125; priority_queue&lt;MM, vector&lt;MM&gt;, CompareByAge&gt; mmData2; mmData2.push(MM(&quot;baby&quot;, 19)); mmData2.push(MM(&quot;anni&quot;, 28)); mmData2.push(MM(&quot;sanshui&quot;, 21)); cout &lt;&lt; endl; while (!mmData2.empty()) &#123; cout &lt;&lt; mmData2.top().GetName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mmData2.top().GetAge() &lt;&lt; endl; mmData2.pop(); &#125; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之array与vector","slug":"C++标准模板库之array与vector","date":"2022-05-27T06:16:07.000Z","updated":"2022-09-18T02:36:04.289Z","comments":true,"path":"2022/05/27/C++标准模板库之array与vector/","link":"","permalink":"http://goskp.github.io/2022/05/27/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Barray%E4%B8%8Evector/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 STL之arary array就是定长数组，任何类型定长数组 /* array 创建对象的两种方式, 常对象,和指针 size(),back(),front()方法 下标: at(i) 正向,逆向,迭代器遍历方法 */ #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char* argv[]) &#123; int inum[3] = &#123;1, 2, 3&#125;; //定长数组 array&lt;int, 3&gt; number = &#123;1, 2, 3&#125;; array&lt;string, 3&gt;* p_str = new array&lt;string, 3&gt;; (*p_str)[0] = &quot;string1&quot;; (*p_str)[1] = &quot;string2&quot;; (*p_str)[2] = &quot;sdfasf&quot;; cout &lt;&lt; &quot;size:&quot; &lt;&lt; number.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; number.empty() &lt;&lt; endl; for (int i = 0; i &lt; number.size(); i++) &#123; cout &lt;&lt; number[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; number.back() &lt;&lt; endl; cout &lt;&lt; number.front() &lt;&lt; endl; for (int i = 0; i &lt; number.size(); i++) &#123; cout &lt;&lt; number.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; p_str-&gt;size(); i++) &#123; cout &lt;&lt; p_str-&gt;at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //正向 array&lt;int, 3&gt;::iterator it = number.begin(); for (; it != number.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //反向 array&lt;int, 3&gt;::reverse_iterator rit = number.rbegin(); for (; rit != number.rend(); rit++) &#123; cout &lt;&lt; *rit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;第一个元素:&quot; &lt;&lt; *number.begin() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素:&quot; &lt;&lt; *number.rbegin() &lt;&lt; endl; // cout &lt;&lt; &quot;end:&quot; &lt;&lt; *number.end() &lt;&lt; endl; 任何end都不能取值运算 delete p_str; return 0; &#125; STL之vector vector是动态数组 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // No.1 不带长度的构建方式 //不能直接用下标方式去操作 vector&lt;int&gt; num; // num[0] = 1; 中断 vector&lt;int&gt; number = &#123;1, 2, 3&#125;; // number[3] = 333; 中断 超过原来长度 // No.2 带长度的构造方式,在长度范围内可以直接下标法访问 vector&lt;string&gt; str(3); // 3代表数组长度 str[0] = &quot;sdfsd&quot;; str[1] = &quot;sdfsdfsd&quot;; str[2] = &quot;sdfsdfsdsd&quot;; // str[3] = &quot;sdfsdfsdfsd&quot;; //中断 // No.3 带自动增长功能是在成员函数中完成 // push_back(T data); str.push_back(&quot;sdfsdfsd&quot;); num.push_back(12); vector&lt;int&gt; test(3); test.push_back(999); for (auto&amp; v : test) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt;::iterator it; for (it = test.begin(); it != test.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt;::reverse_iterator rit; for (rit = test.rbegin(); rit != test.rend(); rit++) &#123; cout &lt;&lt; *rit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //成员函数 cout &lt;&lt; &quot;第一个元素:&quot; &lt;&lt; test.front() &lt;&lt; &quot;\\t&quot; &lt;&lt; *test.begin() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个二元素:&quot; &lt;&lt; test.back() &lt;&lt; &quot;\\t&quot; &lt;&lt; *test.rbegin() &lt;&lt; &quot;\\t&quot; &lt;&lt; *(test.end() - 1) &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素:&quot; &lt;&lt; test.at(test.size() - 1) &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; test.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; test.empty() &lt;&lt; endl; return 0; &#125; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; //如果想要构建一个无参array MM(string name, int age) : name(name), age(age) &#123;&#125; void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; private: string name; int age; &#125;; void initArray(array&lt;MM, 3&gt;&amp; mmData) &#123; mmData[0] = MM(&quot;name1&quot;, 18); mmData[1] = MM(&quot;name2&quot;, 29); mmData[2] = MM(&quot;name3&quot;, 38); &#125; void printMM(array&lt;MM, 3&gt; mmData) &#123; for (auto&amp; v : mmData) &#123; v.printData(); &#125; &#125; void testArray() &#123; array&lt;MM, 3&gt; mmData; initArray(mmData); printMM(mmData); for (int i = 0; i &lt; mmData.size(); i++) &#123; mmData[i].printData(); &#125; &#125; void printVector(vector&lt;MM&gt; mmData) &#123; for (auto&amp; v : mmData) &#123; // cout &lt;&lt; v &lt;&lt; &quot; &quot;; v.printData(); &#125; &#125; void testVector() &#123; vector&lt;MM&gt; mmData; mmData.push_back(MM(&quot;name1&quot;, 23)); mmData.push_back(MM(&quot;name2&quot;, 25)); mmData.push_back(MM(&quot;name3&quot;, 45)); printVector(mmData); &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;array:&quot; &lt;&lt; endl; testArray(); cout &lt;&lt; &quot;vector:&quot; &lt;&lt; endl; testVector(); return 0; &#125; 互相嵌套#include &lt;time.h&gt; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; void testArray() &#123; array&lt;array&lt;int, 4&gt;, 3&gt; data; //三乘四二维数组 for (int i = 0; i &lt; data.size(); i++) &#123; for (int j = 0; j &lt; data[i].size(); j++) &#123; data[i][j] = j + i * data.size(); //随便赋值的 cout &lt;&lt; data[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; array&lt;array&lt;array&lt;int, 4&gt;, 4&gt;, 4&gt;; //三维数组 &#125; void testVector() &#123; vector&lt;vector&lt;int&gt;&gt; data; //不等长的二维数组 for (int i = 0; i &lt; 3; i++) &#123; int length = rand() % 5 + 1; vector&lt;int&gt; temp; for (int j = 0; j &lt; length; j++) &#123; temp.push_back(j); &#125; data.push_back(temp); &#125; for (int i = 0; i &lt; data.size(); i++) &#123; for (int j = 0; j &lt; data[i].size(); j++) &#123; cout &lt;&lt; data[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; void testArrayVector() &#123; array&lt;vector&lt;int&gt;, 3&gt; test1; test1[0] = vector&lt;int&gt;&#123;1, 2, 3&#125;; test1[1] = vector&lt;int&gt;&#123;1, 2, 3, 4, 5&#125;; test1[2] = vector&lt;int&gt;&#123;1&#125;; for (int i = 0; i &lt; test1.size(); i++) &#123; for (int j = 0; j &lt; test1[i].size(); j++) &#123; cout &lt;&lt; test1[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; vector&lt;array&lt;int, 3&gt;&gt; test2; test2.push_back(array&lt;int, 3&gt;&#123;1, 2, 3&#125;); test2.push_back(array&lt;int, 3&gt;&#123;3, 3, 3&#125;); test2.push_back(array&lt;int, 3&gt;&#123;4, 4, 4&#125;); for (int i = 0; i &lt; test2.size(); i++) &#123; for (int j = 0; j &lt; test2[i].size(); j++) &#123; cout &lt;&lt; test2[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; srand((unsigned int)time(nullptr)); cout &lt;&lt; &quot;array嵌套:&quot; &lt;&lt; endl; testArray(); cout &lt;&lt; &quot;vector嵌套:&quot; &lt;&lt; endl; testVector(); cout &lt;&lt; &quot;array与vector嵌套:&quot; &lt;&lt; endl; testArrayVector(); return 0; &#125; 嵌套模板#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; struct MMInfo &#123; string name; int age; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MMInfo&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MMInfo&amp; object) &#123; in &gt;&gt; object.name &gt;&gt; object.age; return in; &#125; struct Score &#123; int math; int english; int py; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const Score&amp; object) &#123; out &lt;&lt; object.math &lt;&lt; &quot;\\t&quot; &lt;&lt; object.english &lt;&lt; &quot;\\t&quot; &lt;&lt; object.py; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, Score&amp; object) &#123; in &gt;&gt; object.math &gt;&gt; object.english &gt;&gt; object.py; return in; &#125; struct Sum &#123; MMInfo info; Score score; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const Sum&amp; object) &#123; out &lt;&lt; object.info &lt;&lt; &quot;\\t&quot; &lt;&lt; object.score; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, Sum&amp; object) &#123; in &gt;&gt; object.info &gt;&gt; object.score; return in; &#125; template &lt;class _Ty&gt; class MM &#123; public: void insertData(_Ty data) &#123; this-&gt;data.push_back(data); &#125; void printData() &#123; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; private: vector&lt;_Ty&gt; data; &#125;; int main(int argc, char** argv) &#123; //管理基本信息 MM&lt;MMInfo&gt; mm; MMInfo temp; cout &lt;&lt; &quot;请输入美女信息:&quot;; cin &gt;&gt; temp; mm.insertData(temp); mm.printData(); //管理分数 MM&lt;Score&gt; mmScore; Score score; cout &lt;&lt; &quot;输入美女分数:&quot;; cin &gt;&gt; score; mmScore.insertData(score); mmScore.printData(); //管理分数和基本信息 MM&lt;Sum&gt; sum; Sum tempSum; cin &gt;&gt; tempSum; sum.insertData(tempSum); sum.printData(); return 0; &#125; 自制array#include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class _Ty, size_t _size&gt; class my_array &#123; public: _Ty&amp; operator[](int index) &#123; return elem[index]; &#125; _Ty at(int index) &#123; return elem[index]; &#125; int size() const &#123; return _size; &#125; bool empty() const &#123; return _size == 0; &#125; _Ty back() &#123; return elem[_size - 1]; &#125; _Ty front() &#123; return elem[0]; &#125; _Ty* begin() &#123; return elem; &#125; _Ty* end() &#123; return elem + _size; &#125; class iterator &#123; public: void operator=(_Ty* pmove) &#123; this-&gt;pmove = pmove; &#125; _Ty operator*() &#123; return pmove[0]; &#125; bool operator!=(_Ty* pmove) &#123; return this-&gt;pmove != pmove; &#125; void operator++() &#123; this-&gt;pmove++; &#125; private: _Ty* pmove; &#125;; private: _Ty elem[_size]; &#125;; int main(int argc, char** argv) &#123; my_array&lt;int, 3&gt; data; data[0] = 1; data[1] = 2; data[2] = 3; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; my_array&lt;int, 3&gt;::iterator it; for (it = data.begin(); it != data.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; data.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; data.empty() &lt;&lt; endl; array&lt;int, 4&gt; stl_array; cout &lt;&lt; &quot;size:&quot; &lt;&lt; stl_array.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; stl_array.empty() &lt;&lt; endl; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++模板","slug":"C++模板","date":"2022-05-26T00:32:18.000Z","updated":"2022-09-18T02:35:46.461Z","comments":true,"path":"2022/05/26/C++模板/","link":"","permalink":"http://goskp.github.io/2022/05/26/C++%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++模板什么是模板模板编程也可以叫做泛型编程，忽略数据类型的一种编程方式 //求最值问题 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; double Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; string Max(string a, string b) &#123; return a &gt; b ? a : b; &#125; //引入模板编程 template &lt;typename type&gt; //告诉编译器，下面会用到一个未知类型叫做type type Max(type a, type b) &#123; return a &gt; b ? a : b; &#125; 模板代码 #include &lt;iostream&gt; using namespace std; template &lt;typename type&gt; type Max(type a, type b) &#123; return a &gt; b ? a : b; &#125; // typename 可以用class 替换 template &lt;class T&gt; void print(T data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; //隐式调用 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; cout &lt;&lt; Max(1.1, 2.2) &lt;&lt; endl; // string 和char* 有区别 cout &lt;&lt; Max(string(&quot;1ILoveyou&quot;), string(&quot;2IMissyou&quot;)) &lt;&lt; endl; //显示调用 &lt;&gt;传类型的参数 cout &lt;&lt; Max&lt;int&gt;(1, 2) &lt;&lt; endl; // type=int a=1 b=2 cout &lt;&lt; Max&lt;string&gt;(string(&quot;1&quot;), string(&quot;2&quot;)) &lt;&lt; endl; cout &lt;&lt; Max&lt;double&gt;(1.2, 1.3) &lt;&lt; endl; return 0; &#125; 函数模板函数模板重载问题 函数模板和普通函数 函数模板和函数模板 #include &lt;iostream&gt; using namespace std; // No.1 模板与普通函数 int Max(int a, int b) &#123; cout &lt;&lt; &quot;普通函数...&quot; &lt;&lt; endl; return a &gt; b ? a : b; &#125; template &lt;class T&gt; T Max(T a, T b) &#123; cout &lt;&lt; &quot;模板&quot; &lt;&lt; endl; return a &gt; b ? a : b; &#125; // No.2 模板与模板 template &lt;class type1, class type2, class type3&gt; void print(type1 one, type2 two, type3 three) &#123; cout &lt;&lt; &quot;三只&quot; &lt;&lt; endl; &#125; template &lt;class type1, class type2&gt; // type1=int type2=double void print(type1 one, type1 two, type2 tow) &#123; // int int double cout &lt;&lt; &quot;两只&quot; &lt;&lt; endl; &#125; template &lt;class type&gt; void print(type one, type two, type three) &#123; cout &lt;&lt; &quot;一只&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; Max&lt;int&gt;(1, 2) &lt;&lt; endl; //显式调用，百分百调用模板 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; //优先调用类型确定的函数 cout &lt;&lt; &quot;显示调用&quot; &lt;&lt; endl; print&lt;int, double, string&gt;(1, 1.1, string(&quot;23&quot;)); print&lt;int, double&gt;(1, 1, 1.22); print&lt;int&gt;(1, 2, 3); cout &lt;&lt; &quot;隐式调用&quot; &lt;&lt; endl; print(1, 1, 2); //需要传参越少先调用 print(1, 1, string(&quot;sdsd&quot;)); print(1, 1.11, string(&quot;sdsd&quot;)); //只有一种选择 return 0; &#125; 类成员函数是函数模板//这种不叫做模板类型 class MM &#123; public: template &lt;class T&gt; void print(T data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; MM mm; mm.print(1); mm.print&lt;string&gt;(&quot;string&quot;); return 0; &#125; 函数模板缺省函数模板缺省和函数参数的缺省是一样的规则 //函数模板缺省 template &lt;class type1,class type2=string&gt; void printData(type1 one, type2 two) &#123; cout &lt;&lt; one &lt;&lt; endl; cout &lt;&lt; two &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; printData&lt;int, double&gt;(1, 1.22); printData&lt;int&gt;(1, string(&quot;dsfsdf&quot;)); return 0; &#125; 函数模板传常量//函数模板传常量 template &lt;class T,size_t size&gt; void printArray(T* array) &#123; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; int num[3] = &#123; 1,2,3 &#125;; printArray&lt;int, 3&gt;(num); //下面代码报错 //int length = 3; //printArray&lt;int, length&gt;(num); string str[4] = &#123; &quot;sdds&quot;,&quot;sd&quot;,&quot;sdsd&quot; ,&quot;sdds&quot;&#125;; printArray&lt;string, 4&gt;(str); return 0; &#125; 类模板 类模板不是一个完整类型，所以任何用到类名的地方都需要用类名&lt;未知类型&gt;的方式使用 怎么去使用类模板，类模板必须采用显式调用方式 类模板在多文件中不能分开写 可以写在.hpp文件中(声明和实现都在一起) #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; template &lt;class type1, class type2&gt; struct my_pair &#123; type1 first; //键 type2 second; //值 my_pair(type1 first, type2 second) : first(first), second(second) &#123;&#125; my_pair() = default; &#125;; template &lt;class type1, class type2&gt; my_pair&lt;type1, type2&gt; my_make_pair(type1 one, type2 two) &#123; return my_pair&lt;type1, type2&gt;(one, two); &#125; template &lt;class type1, class type2&gt; class Test &#123; public: Test(type1 one, type2 two) : one(one), two(two) &#123;&#125; void printTest(); protected: type1 one; type2 two; &#125;; template &lt;class type1, class type2&gt; void Test&lt;type1, type2&gt;::printTest() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; endl; &#125; template &lt;class type1, class type2&gt; class Data : public Test&lt;type1, type2&gt; &#123; public: Data(type1 one, type2 two) : Test&lt;type1, type2&gt;(one, two) &#123;&#125; protected: &#125;; int main(int argc, char** argv) &#123; my_pair&lt;int, int&gt; pairData = &#123;1, 2&#125;; cout &lt;&lt; pairData.first &lt;&lt; &quot; &quot; &lt;&lt; pairData.second &lt;&lt; endl; my_pair&lt;int, string&gt;* p = new my_pair&lt;int, string&gt;; p-&gt;first = 12; p-&gt;second = &quot;sdsd&quot;; cout &lt;&lt; p-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;second &lt;&lt; endl; Data&lt;int, int&gt; data(1, 2); data.printTest(); //标准库中的pair类型 pair&lt;int, string&gt; pD(1, &quot;ILoveyou&quot;); cout &lt;&lt; pD.first &lt;&lt; &quot; &quot; &lt;&lt; pD.second &lt;&lt; endl; pair&lt;int, string&gt; testData = make_pair&lt;int, string&gt;(1, &quot;sdfsdf&quot;); my_pair&lt;int, string&gt; my_testData = my_make_pair&lt;int, string&gt;(1, &quot;sdfsdf&quot;); return 0; &#125; 类模板特化问题 局部特化 完全特化 特化的目的是为了适应不同数据的不同处理 #include &lt;iostream&gt; using namespace std; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; (one + two + three) &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; //局部特化 //两个数据,打印两数之差 template &lt;class _Ty1, class _Ty2&gt; class Data&lt;_Ty1, _Ty1, _Ty2&gt; &#123; public: Data(_Ty1 one, _Ty2 two) : one(one), two(two) &#123;&#125; void printData() &#123; cout &lt;&lt; (one - two) &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; &#125;; //只有一个数据,打印数据 template &lt;class _Ty1&gt; class Data&lt;_Ty1, _Ty1, _Ty1&gt; &#123; public: Data(_Ty1 one) : one(one) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; endl; &#125; private: _Ty1 one; &#125;; //完全特化 template &lt;&gt; class Data&lt;string, string, string&gt; &#123; public: Data(string one, string two, string three) : one(one), two(two), three(three) &#123;&#125; void printData(); private: string one; string two; string three; &#125;; void Data&lt;string, string, string&gt;::printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; Data&lt;int, int, int&gt; data1(1); data1.printData(); Data&lt;int, int, double&gt; data2(2, 1); data2.printData(); Data&lt;int, double, float&gt; data3(1, 1.1, 1.2f); data3.printData(); Data&lt;string, string, string&gt; data4(&quot;dsd&quot;, &quot;sdfd&quot;, &quot;sdfdsf&quot;); data4.printData(); return 0; &#125; 模板操作自定义类型 模板操作自定义关键点在于重载 #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() = default; MM(string name, int age) : name(name), age(age) &#123;&#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot; &quot; &lt;&lt; object.age; return out; &#125; private: string name; int age; &#125;; template &lt;class _Ty&gt; void printData(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: //_Ty1=MM, _Ty2=int, _Ty3=int Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; int main(int argc, char** argv) &#123; printData(1); printData(&quot;string&quot;); MM mm = &#123;&quot;小芳&quot;, 18&#125;; printData(mm); Data&lt;MM, int, int&gt; data(MM(&quot;小芳&quot;, 18), 98, 99); data.printData(); Data&lt;MM, MM, MM&gt; mmData(MM(&quot;小芳&quot;, 18), MM(&quot;小芳&quot;, 18), MM(&quot;小芳&quot;, 18)); mmData.printData(); return 0; &#125; 模板嵌套模板 (类型是由类名&lt;类型&gt;表示一个类型） #include &lt;iostream&gt; using namespace std; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Data&lt;_Ty1, _Ty2, _Ty3&gt;&amp; object) &#123; out &lt;&lt; object.one &lt;&lt; &quot; &quot; &lt;&lt; object.two &lt;&lt; &quot; &quot; &lt;&lt; object.three; return out; &#125; protected: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; template &lt;class _Ty1, class _Ty2&gt; class Info &#123; public: Info(_Ty1 one, _Ty2 two) : one(one), two(two) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; endl; &#125; // template &lt;class _Ty1, class _Ty2&gt; 类中实现不需要修饰了，会出现重定义问题 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Info&lt;_Ty1, _Ty2&gt;&amp; object) &#123; out &lt;&lt; object.one &lt;&lt; &quot; &quot; &lt;&lt; object.two &lt;&lt; &quot; &quot;; return out; &#125; protected: _Ty1 one; _Ty2 two; &#125;; template &lt;class _Ty1&gt; class Student &#123; public: Student(_Ty1 one) : one(one) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; endl; &#125; protected: _Ty1 one; &#125;; int main(int argc, char** argv) &#123; Data&lt;int, int, int&gt; data(1, 1, 1); // Data&lt;int, int, int&gt; Info&lt;int, int&gt; info(1, 2); // Info&lt;int, int&gt; Info&lt;Data&lt;int, int, int&gt;, Data&lt;string, string, string&gt;&gt; test1( Data&lt;int, int, int&gt;(1, 1, 1), Data&lt;string, string, string&gt;(&quot;ds&quot;, &quot;sd&quot;, &quot;sds&quot;)); //起别名 using type1 = Data&lt;int, int, int&gt;; using type2 = Data&lt;string, string, string&gt;; //别名版本 Info&lt;type1, type2&gt; test2(type1(1, 1, 1), type2(&quot;ds&quot;, &quot;sd&quot;, &quot;sds&quot;)); Data&lt;Info&lt;int, string&gt;, Info&lt;string, string&gt;, Info&lt;int, double&gt;&gt; test3( Info&lt;int, string&gt;(1, &quot;sd&quot;), Info&lt;string, string&gt;(&quot;sdds&quot;, &quot;dsds&quot;), Info&lt;int, double&gt;(1, 1.11)); test1.printData(); test2.printData(); test3.printData(); Student&lt;Data&lt;Info&lt;int, int&gt;, Info&lt;int, string&gt;, Info&lt;string, string&gt;&gt;&gt; stu( Data&lt;Info&lt;int, int&gt;, Info&lt;int, string&gt;, Info&lt;string, string&gt;&gt;( Info&lt;int, int&gt;(1, 1), Info&lt;int, string&gt;(1, &quot;sdsd&quot;), Info&lt;string, string&gt;(&quot;sds&quot;, &quot;sdsd&quot;))); stu.printData(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++异常处理","slug":"C++异常处理","date":"2022-05-25T08:26:04.000Z","updated":"2022-09-18T02:35:39.979Z","comments":true,"path":"2022/05/25/C++异常处理/","link":"","permalink":"http://goskp.github.io/2022/05/25/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++异常处理异常处理基操抛出异常: throw 抛出的东西一定一个值 **检查异常:**try **捕获处理异常:**catch 注意： try和catch必须一起出现，并且各自的{}不能省略 #include &lt;iostream&gt; using namespace std; int Div(int a, int b) &#123; //正常写程序 有问题立刻处理 // if (b == 0) //&#123; // cout &lt;&lt; &quot;除数不能为0&quot; &lt;&lt; endl; // return 0; //&#125; if (b == 0) &#123; throw 0; &#125; return a / b; &#125; int main(int argc, char** argv) &#123; // Div(1, 0); //调用abort函数终止程序 try &#123; cout &lt;&lt; &quot;测试.....1&quot; &lt;&lt; endl; Div(1, 0); cout &lt;&lt; &quot;测试.....2&quot; &lt;&lt; endl; &#125; catch (double) &#123; //捕获int类型异常 cout &lt;&lt; &quot;double:除数不能为零&quot; &lt;&lt; endl; &#125; catch (int) &#123; cout &lt;&lt; &quot;int:除数不能为零&quot; &lt;&lt; endl; &#125; // error C2312: “int”: 由“int”在行 28 上捕获 // catch (int) //&#123; // cout &lt;&lt; &quot;int:除数不能为零&quot; &lt;&lt; endl; //&#125; return 0; &#125; 没有异常int Max(int a, int b) throw() &#123; return a &gt; b ? a : b; &#125; //新标准 int Sum(int a, int b) noexcept &#123; return a + b; &#125; 异常处理的传参操作#include &lt;iostream&gt; using namespace std; void printArray(int array[], int arrayNum) &#123; if (arrayNum &lt; 1) &#123; throw 1; &#125; cout &lt;&lt; &quot;正常长度，假装打印....&quot; &lt;&lt; endl; &#125; void searchArray(int array[], int arrayNum) &#123; if (arrayNum &lt; 1) &#123; throw 2; &#125; cout &lt;&lt; &quot;正常长度，假装查找....&quot; &lt;&lt; endl; &#125; void deleteArray(int array[], int arrayNum) &#123; if (arrayNum &lt; 1) &#123; throw 3; &#125; cout &lt;&lt; &quot;正常长度，假装删除....&quot; &lt;&lt; endl; &#125; int Div(int a, int b) &#123; if (b == 0) &#123; throw string(&quot;除数不能为零&quot;); &#125; return a / b; &#125; //抛出自己类对象:自定义异常类 class stackEmpty &#123; public: stackEmpty(string strInfo) : strinfo(strInfo) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;error:&quot; &lt;&lt; strinfo &lt;&lt; endl; &#125; private: string strinfo; &#125;; //假装入栈 void push(int a) &#123; if (a == 0) &#123; throw stackEmpty(&quot;栈为空&quot;); &#125; cout &lt;&lt; a &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; try &#123; int array[3] = &#123;1, 2, 3&#125;; printArray(array, 3); searchArray(array, -1); deleteArray(array, 2); &#125; catch (int value) &#123; // int value=抛出的值 switch (value) &#123; case 1: cout &lt;&lt; &quot;打印异常&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;查找异常&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;删除异常&quot; &lt;&lt; endl; break; &#125; &#125; try &#123; cout &lt;&lt; Div(2, 1) &lt;&lt; endl; cout &lt;&lt; Div(2, 0) &lt;&lt; endl; &#125; catch (string&amp; object) &#123; cout &lt;&lt; object &lt;&lt; endl; &#125; //... 表示可以捕获任何异常 try &#123; cout &lt;&lt; Div(2, 0) &lt;&lt; endl; &#125; catch (...) &#123; //删减符 cout &lt;&lt; &quot;引发异常&quot; &lt;&lt; endl; &#125; try &#123; push(1233); push(0); &#125; catch (stackEmpty&amp; object) &#123; object.print(); &#125; return 0; &#125; 标准库中的异常exception类组成: what方法 用来返回异常信息的字符串 #include &lt;exception&gt; #include &lt;iostream&gt; using namespace std; class Error : public exception &#123; public: // virtual char const* what() const //&#123; // return &quot;Error&quot;; // &#125; Error() : exception(&quot;Error&quot;) &#123;&#125; private: &#125;; void printTest() &#123; throw Error(); &#125; int main(int argc, char** argv) &#123; try &#123; printTest(); &#125; catch (Error&amp; object) &#123; cout &lt;&lt; object.what() &lt;&lt; endl; &#125; return 0; &#125; 引发ball_alloc异常#include &lt;exception&gt; #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; int array[3] = &#123;1, 2, 3&#125;; try &#123; while (1) &#123; int* p = new int[1024 * 1024]; &#125; &#125; catch (bad_alloc&amp; object) &#123; cout &lt;&lt; object.what() &lt;&lt; endl; &#125; return 0; &#125; 感觉有点鸡肋,不写了…我不太理解这个异常处理","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++IO流","slug":"C++IO流","date":"2022-05-24T08:11:36.000Z","updated":"2022-09-18T02:35:30.877Z","comments":true,"path":"2022/05/24/C++IO流/","link":"","permalink":"http://goskp.github.io/2022/05/24/C++IO%E6%B5%81/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++IO流流的概念流就是若干字节组成字节序列，流操作从一个到另一个移动的过程 流中的内容:二进制数据 ASCII码 流类体系C++中用类实现所有流类操作 标准的输入输出流 C++格式控制 字符流 文件流 #include &lt;iostream&gt; //istream ostream #include &lt;fstream&gt; //ifstream ofstream #include &lt;strstream&gt; //istringstream using namespace std; int main(int argc, char** argv) &#123; fstream out; ifstream iin; return 0; &#125; 标准输入输出流 对象 类型 作用 cin 标准输入 从键盘读取，可以重定向 cout 标准输出 输出到控制台，可以重定向 cerr 标准错误输出 输出到控制台，不可以重定向 clog 标准错误输出 输出到控制台，可重定向 #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;标准输出&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; return 0; &#125; 字符和字符串输入 cout成员函数 put() : 输出一个字符 write(): 输出字符串 cin成员函数 get()：输入一个字符 getline: 输入一个字符串 #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;标准输出&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; //字符输入 cout &lt;&lt; &quot;字符输入:&quot; &lt;&lt; endl; int userKey = cin.get(); cout.put(userKey); char str[10] = &#123; &quot;&quot; &#125;; cout &lt;&lt; &quot;字符串输入:&quot; &lt;&lt; endl; while (getchar() != &#39;\\n&#39;); cin.getline(str, 10); //10个长度包含\\0 cout &lt;&lt; str &lt;&lt; endl; cout.write(str, 10); return 0; &#125; C++格式控制 包含头文件: iomanip 通过对象的形式，一种通过成员的函数形式 对象形式 实际含义 setbase(n) 设置多少进制输出整数(参数是8和16) setw(n) 设置输出数据宽度(默认对齐是右对齐，不足补空格) setiosflags(ios::left) 设置对齐方式: ios::left ,ios::right setprecition(n) 单纯使用是控制有效位数，如果控制小数位数结合fixed setfill(n) 填充字符 #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int main(int argc, char** argv) &#123; //进制输出 cout &lt;&lt; setbase(16) &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; setbase(8) &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt;showbase&lt;&lt; hex &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; dec &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; noshowbase&lt;&lt;oct &lt;&lt; 32 &lt;&lt; endl; //cout &lt;&lt; setbase(2) &lt;&lt; 32 &lt;&lt; endl; //无效 //默认右对齐 cout &lt;&lt; setw(10) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(10) &lt;&lt; &quot;年龄&quot; &lt;&lt; setw(10) &lt;&lt; &quot;编号&quot; &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; &quot;小芳&quot; &lt;&lt; setw(10) &lt;&lt; 17 &lt;&lt; setw(10) &lt;&lt; 119911 &lt;&lt; endl; cout &lt;&lt; setiosflags(ios::left); cout &lt;&lt; setw(10) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(10) &lt;&lt; &quot;年龄&quot; &lt;&lt; setw(10) &lt;&lt; &quot;编号&quot; &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; &quot;小芳&quot; &lt;&lt; setw(10) &lt;&lt; 17 &lt;&lt; setw(10) &lt;&lt; 119911 &lt;&lt; endl; cout &lt;&lt; setprecision(4) &lt;&lt; 300.12345 &lt;&lt; endl; //直接用控制的是有效位数 cout &lt;&lt; fixed&lt;&lt;setprecision(4) &lt;&lt; 300.12349 &lt;&lt; endl; //小数位数 cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; 300.12345 &lt;&lt; endl; //所有的格式控制存在成员函数的调用形式 cout.width(8); cout &lt;&lt; &quot;姓名&quot;; cout.width(8); cout &lt;&lt; 1 &lt;&lt; endl; cout.precision(4); //取消上述格式 cout &lt;&lt;resetiosflags &lt;&lt;300.333 &lt;&lt; endl; bool num = 1; cout &lt;&lt; boolalpha &lt;&lt; num &lt;&lt; endl; //true和false形式输出bool类型 return 0; &#125; 字符流 包含头文件： sstream istringstream ostringstream stringstream 一般处理字符流的时候用的是stringstream类型的对象 获取字符流中的stirng string str(); &#x2F;&#x2F;获取string void str(const string&amp; str) &#x2F;&#x2F;重置流对象中字符串 字符流做什么 数据类型的转换 数据的分割 #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; stringstream stream(&quot;ILoveyou&quot;); cout &lt;&lt; stream.str() &lt;&lt; endl; char str[20] = &quot;&quot;; stream &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; stream.str(&quot;&quot;); //清除 //数据类型转换 //整数转字符串,字符串转数字 string num = to_string(123); cout &lt;&lt; num &lt;&lt; endl; int inumber = 12123; char result[20] = &#123; &quot;&quot; &#125;; stringstream buf(result); buf &lt;&lt; inumber; buf &gt;&gt; result; cout &lt;&lt; result &lt;&lt; endl; stringstream strNum(&quot;12345435&quot;); int dataNum = 0; strNum &gt;&gt; dataNum; cout &lt;&lt; dataNum &lt;&lt; endl; //数据切割(流中默认空格作为单一数据的间隔) stringstream ip(&quot;ip: 192.168.1.1&quot;); char strip[20] = &#123; &quot;&quot; &#125;; ip &gt;&gt; strip; //ip: 拿出来 int ipNum[4]; char userKey; ip &gt;&gt; ipNum[0]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[1]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[2]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[3]; for (int i = 0; i &lt; 4; i++) &#123; cout &lt;&lt; ipNum[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; //注意点： 流在做转换的，必须调用clear清除处理 buf.clear(); buf &lt;&lt; inumber; buf &gt;&gt; result; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; 文件操作流 包含头文件: fstream ofstream: 打开文件只能写操作 ifstream: 打开文件只读操作 一般大家创建一个fstream对象，可读可写 打开文件 构造的方式,带参数构造函数：const char* URL,ios::openmode mode 成员函数方式: void open(const char* URL,ios::openmode mode) 判断文件打开是否成功 !is_open()函数判断是否打开成功 ,!is_open()是1的打开失败 !文件对象 .!对象是1打开失败 读写方式 作用 ios::in 读的方式打开文件 ios::out 写的方式打开文件 ios::app 追加写文件 ios::ate 打开已有文件，指针在文件末位 ios::trunc 文件不存在具有创建方式 ios::binary 二进制打开，默认打开方式ASCII码 ios::nocreate 不创建 ios::noreplace 不替换 组合方式: 用位或, 可读可写: ios::in|ios::out 关闭文件 close关闭文件 文件读写 直接采用&gt;&gt; &lt;&lt;符号进行读写 采用成员函数读写：read函数和write成员函数 文件指针移动 ifstream文件指针 ifstream&amp; seekg(long int pos); ifstream&amp; seekg(long int pos,ios_base::seekdir begin); ofstream文件指针 ofstream&amp; seekp(long int pos); ofstream&amp; seekp(long int pos,ios_base::seekdir begin); begin: ios::beg 开始位置 ios::cur 当前位置 ios::end 结束位置 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; //采用&gt;&gt; &lt;&lt; void saveFile(string fileName) &#123; fstream file(fileName, ios::in | ios::out | ios::app); if (!file) &#123; cout &lt;&lt; &quot;打开文件失败!&quot; &lt;&lt; endl; return; &#125; file &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; file.close(); &#125; void readFile(string fileName) &#123; fstream file(fileName, ios::in); if (!file) &#123; cout &lt;&lt; &quot;打开文件失败!&quot; &lt;&lt; endl; return; &#125; while (true) &#123; MM temp; file &gt;&gt; temp.name &gt;&gt; temp.age &gt;&gt; temp.num; if (file.eof()) &#123; break; &#125; temp.print(); &#125; file.close(); &#125; protected: string name; int age; int num; &#125;; void asciiRWFile(string readFile, string writeFile) &#123; //流的方式 //字符或者字符串的 fstream read(readFile, ios::in); fstream write(writeFile, ios::out); while (!read.eof()) &#123; char userkey = read.get(); // getline() write.put(userkey); // write()函数 &#125; read.close(); write.close(); &#125; //二进制读写 void binaryRWFile(string readFile, string writeFile) &#123; fstream r(readFile, ios::in | ios::binary); fstream w(writeFile, ios::out | ios::binary); while (!r.eof()) &#123; char str[1024] = &#123;&quot;&quot;&#125;; //缓冲区 r.read(str, 1024); w.write(str, strlen(str)); //长度写多少就写入文件多少 &#125; r.close(); w.close(); &#125; //文件指针移动 int getSize(string fileName) &#123; fstream read(fileName, ios::in | ios::binary); read.seekg(0, ios::end); int size = read.tellg(); read.close(); return size; &#125; int main(int argc, char** argv) &#123; //打开文件测试 // fstream file(&quot;xxoo.txt&quot;,ios::in|ios::out|ios::trunc); //等效下面两行 fstream file; file.open(&quot;xxoo.txt&quot;, ios::in | ios::out | ios::trunc); if (!file || !file.is_open()) &#123; cerr &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; file.close(); MM mm(&quot;xxx&quot;, 18, 1001); mm.saveFile(&quot;mm.txt&quot;); mm.readFile(&quot;mm.txt&quot;); asciiRWFile(&quot;mm.txt&quot;, &quot;xxoo.txt&quot;); binaryRWFile(&quot;xxoo.txt&quot;, &quot;rw.txt&quot;); cout &lt;&lt; &quot;size:&quot; &lt;&lt; getSize(&quot;size.txt&quot;) &lt;&lt; endl; return 0; &#125; //用write写入对象数组数据放到文件 //用read把数据读取出来，可以存储到对象数组中，打印出来 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* name, int age, int num) : age(age), num(num) &#123; strcpy(this-&gt;name, name); &#125; void writeFile(const char* fileName) &#123; fstream fread(fileName, ios::out | ios::app | ios::binary); fread.write((char*)this, sizeof(MM)); fread.close(); &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object); protected: char name[20]; int age; int num; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; &quot;\\t&quot; &lt;&lt; object.num &lt;&lt; endl; return out; &#125; void readFile(const char* fileName, MM* temp, int size) &#123; fstream fread(fileName, ios::in | ios::binary); // char str[1024] = &#123; &quot;&quot; &#125;; while (1) &#123; if (fread.eof()) break; fread.read((char*)temp, size); &#125; fread.close(); &#125; int main(int argc, char** argv) &#123; &#123; // MM array[3] = &#123; &#123;&quot;张三&quot;,18,1001&#125;,&#123;&quot;小美&quot;,28,1002&#125;,&#123;&quot;小丽&quot;,38,1003&#125; &#125;; // MM temp[3]; // readFile(&quot;mm.txt&quot;, temp, 3 * sizeof(MM)); // for (int i = 0; i &lt; 3; i++) //&#123; // cout &lt;&lt; temp[i]; //&#125; &#125; cout &lt;&lt; &quot;dsafdsfasda&quot; &lt;&lt; endl; fstream read(&quot;xx.txt&quot;, ios::in | ios::trunc | ios::_Nocreate); // ios::app: 追加方式，不能替换原文件 if (!read) &#123; cout &lt;&lt; &quot;文件打开失败!&quot; &lt;&lt; endl; return 0; &#125; read.close(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++虚函数与多态","slug":"C++虚函数与多态","date":"2022-05-23T08:04:05.000Z","updated":"2022-10-01T02:35:54.149Z","comments":true,"path":"2022/05/23/C++虚函数与多态/","link":"","permalink":"http://goskp.github.io/2022/05/23/C++%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++虚函数与多态虚函数virtual修饰的成员函数就是虚函数 虚函数对类的内存影响:需要增加一个指针类型的内存大小 无论多少虚函数，只会增加一个指针类型的内存大小 虚函数表的概念: 指向虚函数的指针 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: virtual void print() &#123; cout &lt;&lt; &quot;第一个虚函数&quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;第二个虚函数&quot; &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; cout &lt;&lt; sizeof(MM) &lt;&lt; endl; // 2.对类内存影响 MM mm; mm.print(); mm.printData(); int** pObject = (int**)(&amp;mm); typedef void (*PF)(); PF pf = (PF)pObject[0][0]; pf(); //调用第一个虚函数 pf = (PF)pObject[0][1]; pf(); //调用第二个虚函数 return 0; &#125; 纯虚函数具有一个或者多个纯虚函数的类型称之为抽象类，抽象类特性: 抽象类不能创建对象 抽象类可以创建对象指针 纯虚函数也是一个虚函数，需要virtual修饰，纯虚函数是没有函数体，函数&#x3D;0； #include &lt;iostream&gt; using namespace std; //抽象类 class MM &#123; public: //纯虚函数 virtual void print() = 0; protected: string name; &#125;; int main(int argc, char** argv) &#123; // MM object; 抽象类不能构建对象 MM* pMM = nullptr; return 0; &#125; 虚析构函数virtual修饰的析构函数 就是虚析构函数 当父类指针被子类对象初始化的时候需要用虚析构函数 所有析构函数底层解析其实函数名相同 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void print() &#123; cout &lt;&lt; &quot;MM::print&quot; &lt;&lt; endl; &#125; virtual ~MM() &#123; //虚析构函数 cout &lt;&lt; &quot;~MM&quot; &lt;&lt; endl; &#125; &#125;; class Son : public MM &#123; public: void print() &#123; cout &lt;&lt; &quot;Son::print&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;~Son&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; MM* pMM = new Son; //构造子类对象，必须构造父类对象在构造自身 pMM-&gt;print(); // MM看类型 delete pMM; pMM = nullptr; return 0; &#125; 虚函数和多态多态概念: 指在继承中指针的同一行为的不同结果 实现多态的两个前提条件: 必须是public继承 必须父类存在virtual类型的成员函数,并且子类中存在该函数的同名函数 一定存在指针的引用 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void print() &#123; cout &lt;&lt; &quot;MM::print&quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;MM virtual printData&quot; &lt;&lt; endl; &#125; virtual ~MM() &#123; //虚析构函数 cout &lt;&lt; &quot;~MM&quot; &lt;&lt; endl; &#125; &#125;; class Son : public MM &#123; public: void print() &#123; cout &lt;&lt; &quot;Son::print&quot; &lt;&lt; endl; &#125; void printData() &#123; cout &lt;&lt; &quot;Son printData&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;~Son&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; //正常对象的访问，不存在多态 //都是就近原则 cout &lt;&lt; &quot;正常对象访问&quot; &lt;&lt; endl; MM mmobject; mmobject.print(); mmobject.printData(); Son sonobject; sonobject.print(); sonobject.printData(); //正常的指针访问 cout &lt;&lt; &quot;正常指针访问&quot; &lt;&lt; endl; MM* pMM = new MM; pMM-&gt;print(); pMM-&gt;printData(); Son* pSon = new Son; pSon-&gt;print(); pSon-&gt;printData(); //非正常的初始化 //父类指针被子类初始化 cout &lt;&lt; &quot;不正常的指针赋值&quot; &lt;&lt; endl; MM* pObject = new Son; pObject-&gt;print(); //没有virutal 看指针类型 调用MM::print pObject-&gt;printData(); //有virtual 看对象 调用Son::printData pObject = new MM; pObject-&gt;printData(); //调用MM中 cout &lt;&lt; &quot;引用类型&quot; &lt;&lt; endl; MM&amp; girl = sonobject; girl.print(); girl.printData(); return 0; &#125; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: virtual void print() &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; virtual void printData() final &#123; //禁止子类重写方法 cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; &#125;; // final: 父类中用来禁止子类重写同名方法 // override: 强制重写，起说明作用，表示当前子类当前方法是重写父类 class B : public A &#123; public: //重写:子类实现父类虚函数的同名函数 void print() override &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125; // void printData()&#123;&#125; //final禁止重写 &#125;; class C : public B &#123; public: void print() &#123; cout &lt;&lt; &quot;C&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; B* pb = new C; pb-&gt;print(); //调用C::print pb = new B; pb-&gt;print(); //调用B::print return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++继承","slug":"C++继承","date":"2022-05-22T03:47:42.000Z","updated":"2022-09-18T02:35:53.138Z","comments":true,"path":"2022/05/22/C++继承/","link":"","permalink":"http://goskp.github.io/2022/05/22/C++%E7%BB%A7%E6%89%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++继承继承的实质就是父类有的属性在子类中也存在一份。只是根据继承方式不同，在子类中权限的体现不同。 继承:子类没有新的属性或者行为产生 父类 子类 派生:派生类中有新的属性产生 基类 派生类 单继承只有父类的继承称之为单继承 写法class 父类 &#123; &#125;; class 子类:继承方式 父类名 &#123; &#125;; //继承方式就是权限限定词 //公有继承: public //保护继承: protected //私有继承: private 继承中权限问题 public protected private public继承 public protected 不可访问 protected继承 protected protected 不可访问 private继承 private private 不可访问 综上: 权限限定词只会增强权限(public:最低权限 private:最高权限) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //父类 class MM &#123; public: string getName() &#123; return name; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; protected: int age = 18; private: string name = &quot;默认&quot;; &#125;; //子类 //公有继承 class Boy : public MM &#123; public: // print() void printBoy() &#123; // cout &lt;&lt; name &lt;&lt; endl; 不可能访问 cout &lt;&lt; age &lt;&lt; endl; print(); &#125; protected: // int age private: // string name; 不能访问 &#125;; //保护继承 class Girl : protected MM &#123; public: void printGirl() &#123; cout &lt;&lt; age &lt;&lt; endl; print(); &#125; protected: // void print() // int age; private: // string name; &#125;; //私有继承 class Son : private MM &#123; public: void printSon() &#123; print(); cout &lt;&lt; age &lt;&lt; endl; // cout &lt;&lt; name &lt;&lt; endl; // //父类的私有属性子类不能使用 只能间接调用父类的非私有方法访问 cout &lt;&lt; getName() &lt;&lt; endl; &#125; protected: private: // void print(); // int age; // string name; &#125;; int main(int argc, char** argv) &#123; Boy boy; boy.print(); boy.printBoy(); Girl girl; // girl.print(); //无法访问 girl.printGirl(); Son son; son.printSon(); return 0; &#125; 注意点: 继承的属性无论被继承多少次，都存在， A 被B继承 B被C继承 C被D继承 D包含ABC中所有属性 继承不易过多继承，导致子类臃肿 私有继承可以阻断父类属性被孙子类去使用(断子绝孙) 继承中构造函数写法 写法:子类必须先构造父类对象(子类必须调用父类的构造函数) ,调用父类的构造函数必须采用初始化参数列表 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: A() &#123; cout &lt;&lt; a; &#125; A(string a) : a(a) &#123; cout &lt;&lt; a; &#125; ~A() &#123; cout &lt;&lt; a; &#125; protected: string a = &quot;A&quot;; &#125;; class B : public A &#123; public: B() &#123; //就算没写，也会调用父类的无参构造函数 cout &lt;&lt; b; &#125; //子类完整写法: 除了初始化自身数据，还需要初始化父类数据 B(string a, string b) : A(a) &#123; this-&gt;b = b; //自身属性可以采用初始化列表 cout &lt;&lt; b; &#125; void print() &#123; cout &lt;&lt; a; cout &lt;&lt; b; &#125; ~B() &#123; cout &lt;&lt; b; &#125; protected: string b = &quot;B&quot;; &#125;; class C : public B &#123; public: C(string a, string b, string c) : B(a, b), c(c) &#123; cout &lt;&lt; c; &#125; void print() &#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; &#125; ~C() &#123; cout &lt;&lt; c; &#125; protected: string c; &#125;; int main(int argc, char** argv) &#123; &#123; B b; cout &lt;&lt; endl; B object(&quot;A&quot;, &quot;B&quot;); cout &lt;&lt; endl; object.print(); cout &lt;&lt; endl; C c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); cout &lt;&lt; endl; c.print(); &#125; cout &lt;&lt; endl; &#123; cout &lt;&lt; &quot;构造和析构顺序问题:&quot; &lt;&lt; endl; C cobject(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); // ABCCBA &#125; return 0; &#125; 多继承多继承就是存在两个以及两个以上父类 权限问题和构造函数和单继承一样的 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Father &#123; public: Father(string FFName) : FFName(FFName) &#123;&#125; protected: string FFName; &#125;; class Monther &#123; public: Monther(string MFName) : MFName(MFName) &#123;&#125; protected: string MFName; &#125;; class Son : public Father, public Monther &#123; public: Son(string FFName, string MFName, string SSName) : Father(FFName), Monther(MFName) &#123; this-&gt;SFName = FFName + MFName; this-&gt;SSName = SSName; &#125; void print() &#123; cout &lt;&lt; FFName &lt;&lt; endl; cout &lt;&lt; MFName &lt;&lt; endl; cout &lt;&lt; this-&gt;SFName + this-&gt;SSName &lt;&lt; endl; &#125; protected: string SFName; string SSName; &#125;; int main(int argc, char** argv) &#123; Son son(&quot;李&quot;, &quot;田&quot;, &quot;大牛&quot;); son.print(); return 0; &#125; 菱形继承菱形继承是因为多继承存在问题而衍生的继承方式(菱形继承就是虚继承) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: A(int a) : a(a) &#123;&#125; int a = 666; &#125;; class B : virtual public A &#123; public: B(int a) : A(a) &#123;&#125; &#125;; class C : virtual public A &#123; public: C(int a) : A(a) &#123;&#125; &#125;; //多继承构造顺序只和这个地方顺序(继承顺序)有关 class D : public C, public B &#123; public: //子类必须调用爷爷构造函数 D(int a) : C(14), B(12), A(a) &#123;&#125; void print() &#123; cout &lt;&lt; A::a &lt;&lt; endl; cout &lt;&lt; B::a &lt;&lt; endl; cout &lt;&lt; C::a &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; D dobject(23); dobject.print(); return 0; &#125; 继承中同名问题 数据成员同名 成员函数同名 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name) : name(name) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;MM::name&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; &#125; protected: string name; &#125;; class Son : public MM &#123; public: Son() : name(&quot;Son&quot;), MM(&quot;MM&quot;) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son::name&quot; &lt;&lt; endl; // No.1 不写任何标识 ，就近原则 cout &lt;&lt; name &lt;&lt; endl; // No.2 可以用类名 cout &lt;&lt; MM::name &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; &#125; protected: string name; &#125;; void printInfo(MM* p) &#123; p-&gt;print(); &#125; int main(int argc, char** argv) &#123; //对象访问: // No.1 不写任何标识 ，就近原则 Son son; son.print(); son.MM::print(); son.Son::print(); MM mm(&quot;MM&quot;); mm.print(); //指针访问 //正常初始化访问 cout &lt;&lt; &quot;正常初始化指针访问&quot; &lt;&lt; endl; Son* pSon = new Son; pSon-&gt;print(); MM* pMM = new MM(&quot;MM&quot;); pMM-&gt;print(); //非正常初始化访问 // 1.1 父类指针用子类对象初始化 //在没有写任何修饰词的，看指针类型 MM* pFather = new Son; pFather-&gt;print(); //调用那个函数？ // 1.2 子类指针被父类对象初始化，危险，一般不这样做 // Son* pp = new MM(&quot;MM&quot;); //错误的 Son* pp = NULL; pp = static_cast&lt;Son*&gt;(&amp;mm); //强制类型转换类似C语言强制 // pp-&gt;print(); //程序中断，没办法执行 cout &lt;&lt; &quot;当父类指针成为函数参数时候,传参子类和父类对象通用&quot; &lt;&lt; endl; printInfo(pMM); printInfo(pSon); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++运算符重载","slug":"C++运算符重载","date":"2022-05-21T00:32:18.000Z","updated":"2022-09-18T02:35:21.074Z","comments":true,"path":"2022/05/21/C++运算符重载/","link":"","permalink":"http://goskp.github.io/2022/05/21/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++运算符重载 运算符重载赋予运算能够操作自定义类型。 运算符重载前提条件： 必定存在一个自定义类型 运算符重载实质: 就是函数调用 友元重载 类重载 在同一自定义类型中，一个运算符只能被重载一次 C++重载只能重载已有的运算符，不能重载没有 C++重载一般情况不能违背运算符原来的含义(就算语法正确) 注意点: . ,.* ,?：，:: 不能被重载 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; protected: string name; int score; &#125;; int main(int argc, char** argv) &#123; int a = 1; int b = 2; int sum = a + b; MM mm(&quot;小芳&quot;, 6); MM girl(&quot;小芳&quot;, 2); // error: 没有与这些操作数匹配 &quot;xxx&quot; 运算符 // MM result = mm + girl; //错误 return 0; &#125; 重载写法重载函数的写法 //函数定义方式 函数返回值类型 函数名(参数) &#123; //函数体； &#125; //运算符重载也是函数，只是函数名写法不同 //函数名: operator加上运算符组成函数名 //参数： // 友元重载: 参数个数等于操作数 // 类成员函数: 参数个数等于操作-1 // 函数返回值类型:运算符组成表达式 最终结果是什么类型就返回类型 // int a; int b; a+b 返回int // 函数体：写你真正要实现的效果 友元重载#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; score &lt;&lt; endl; &#125; //友元重载 friend MM operator+(MM a, MM b); //加法重载函数的声明 protected: string name; int score; &#125;; MM operator+(MM a, MM b) &#123; return MM(a.name, a.score + b.score); //返回一个匿名对象 &#125; int main(int argc, char** argv) &#123; int a = 1; int b = 2; int sum = a + b; MM mm(&quot;小芳&quot;, 6); MM girl(&quot;小芳&quot;, 2); // error: 没有与这些操作数匹配 &quot;xxx&quot; 运算符 //重载函数的隐式调用 --&gt;mm + girl 解析为:operator+(mm, girl) MM result = mm + girl; //显示绿色就是运算符重载 result.print(); //重载函数显示调用：按照函数的调用方式 MM res = operator+(mm, girl); // operator+:函数名 参数 // string aa(&quot;12&quot;); // string bb(&quot;2323&quot;); // cout &lt;&lt; (aa &gt; bb) &lt;&lt; endl; return 0; &#125; 类重载#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; score &lt;&lt; endl; &#125; //友元重载 friend MM operator+(MM a, MM b); //加法重载函数的声明 protected: string name; int score; &#125;; //类成员函数少一个参数： 对象本身可以表示参数 MM MM::operator-(MM object) &#123; return MM(this-&gt;name, this-&gt;score - object.score); &#125; int main(int argc, char** argv) &#123; MM mul = mm.operator-(girl); //类重载显示调用，跟调用普通成员函数一样的 mul.print(); MM girlFriend = mm - girl; //编译器mm - girl翻译为: mm.operator-(girl) girlFriend.print(); return 0; &#125; 特殊运算符重载 通常情况:单目运算符用类成员函数重载，双目用友元重载 &#x3D; ,（）,-&gt;,[] 只能采用成员函数重载 ++ –运算符重载 增加一个无用参数，标识是后置++或者– 流运算符重载(&gt;&gt; &lt;&lt;) 输入流对象(cin): istream类 输出流对象(cout): ostream类 流重载必须用引用 流重载一定要用友元重载 后缀重载 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; // MM operator=(MM) = delete; //删掉默认的 //函数重载 void operator=(int data) &#123; this-&gt;age += data; &#125; //++ 为例 MM operator++() &#123; //前置 this-&gt;age++; return *this; //返回对象本身 &#125; MM operator++(int) &#123; //后置的 return MM(this-&gt;name, this-&gt;age++); &#125; //流运算符的重载 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MM&amp; object); friend istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object); private: string name; int age; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, MM&amp; object) &#123; // out当做cout用 out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; endl; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object) &#123; cout &lt;&lt; &quot;输入对象属性:&quot;; // in当做cin用即可 in &gt;&gt; object.name &gt;&gt; object.age; return in; &#125; //文本重载, 一般写成下划线系列 //后缀的重载 unsigned long long operator&quot;&quot;_h(unsigned long long data) &#123; return data * 60 * 60; &#125; unsigned long long operator&quot;&quot;_m(unsigned long long data) &#123; return data * 60; &#125; unsigned long long operator&quot;&quot;_s(unsigned long long data) &#123; return data; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;小芳&quot;, 18); MM girl; girl = mm; //每一个类中都存在默认的赋值重载 girl = 8; girl.print(); MM result = ++girl; result.print(); girl.print(); result = girl++; result.print(); girl.print(); cin &gt;&gt; girl; cout &lt;&lt; girl &lt;&lt; endl; // this_thread::sleep_for(10s); cout &lt;&lt; 1_h &lt;&lt; endl; cout &lt;&lt; (1_h + 30_m + 49_s) &lt;&lt; endl; return 0; &#125; 对象的隐式转换对象隐式转换: 就是让对象能够赋值给普通数据 // operator 转换的类型() &#123; // return 要转换类型的数据； // &#125; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) : name(name), age(age) &#123;&#125; operator int() &#123; return this-&gt;age; &#125; protected: string name; int age; &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 39); int age = mm; cout &lt;&lt; age &lt;&lt; endl; return 0; &#125; ()运算符的重载仿函数让类型可以模仿函数调用的行为： 函数名(参数)； 类名() 调用的函数行为 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; using namespace std; class Data &#123; public: // operator()组成函数名 void operator()() &#123; cout &lt;&lt; &quot;无参重载()&quot; &lt;&lt; endl; &#125; void operator()(int a, int b) &#123; cout &lt;&lt; &quot;有参重载(a,b)&quot; &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; // greater&lt;int&gt;(); //比较准则 // int array[5] = &#123; 3,4,1,2,32 &#125;; // sort(array, array + 5, greater&lt;int&gt;()); // for (auto&amp; v : array) //&#123; // cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; // &#125; // cout &lt;&lt; endl; Data data; data.operator()(); //显式调用 data.operator()(1, 2); //显式调用 data(); //隐式调用 data(1, 2); //隐式调用 Data&#123;&#125;(); //&#123;&#125;帮助识别 Data() Data&#123;&#125;(2, 3); return 0; &#125; 智能指针智能指针是用对象方式管理new的内存，可以做到自动释放(本质是析构函数自动调用)内存的功能 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; class Auto_Ptr &#123; public: Auto_Ptr(int* ptr) : ptr(ptr) &#123;&#125; ~Auto_Ptr() &#123; if (ptr) &#123; delete ptr; ptr = nullptr; &#125; &#125; //访问指针 int* operator-&gt;() &#123; return this-&gt;ptr; &#125; //访问数据 int&amp; operator*() &#123; return *ptr; &#125; //禁止拷贝，禁止赋值 Auto_Ptr(Auto_Ptr&amp;) = delete; Auto_Ptr&amp; operator=(Auto_Ptr&amp;) = delete; protected: int* ptr; &#125;; int main(int argc, char** argv) &#123; Auto_Ptr object(new int(1999)); cout &lt;&lt; *object &lt;&lt; endl; // shared_ptr&lt;int&gt; p(new int(19999)); // cout &lt;&lt; *p &lt;&lt; endl; // shared_ptr&lt;double&gt; p2(new double(19.99)); // cout &lt;&lt; *p2 &lt;&lt; endl; return 0; &#125; 封装数组#include &lt;iostream&gt; #include &lt;vector&gt; //动态数组 using namespace std; class my_vector &#123; public: my_vector(int capacity = 10) : capacity(capacity) &#123; mem = new int[capacity]&#123;0&#125;; curSize = 0; &#125; void push_back(int data) &#123; mem[curSize++] = data; &#125; int* begin() &#123; return mem + 0; &#125; int* end() &#123; return mem + capacity; &#125; int&amp; operator[](int index) &#123; if (curSize &lt; index) curSize = index; return mem[index]; &#125; //万金油函数 int size() &#123; return curSize; &#125; int empty() &#123; return curSize == 0; &#125; ~my_vector() &#123; if (mem) &#123; delete[] mem; mem = nullptr; &#125; &#125; protected: int* mem; int capacity; int curSize; &#125;; int main(int argc, char** argv) &#123; my_vector vec; for (int i = 0; i &lt; 3; i++) &#123; vec[i] = i; &#125; for (auto v : vec) &#123; cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; vec.size() &lt;&lt; endl; for (int i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 迭代器实现&#x2F;&#x2F;迭代器就是让一个类中类去遍历数据 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List() : headNode(new Node), curSize(0) &#123;&#125; void push_front(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); curSize++; &#125; Node* begin() &#123; return headNode-&gt;next;上 &#125; Node* end() &#123; return nullptr; &#125; class iterator &#123; public: iterator() : pmove(nullptr) &#123;&#125; void operator=(Node* pmove) &#123; this-&gt;pmove = pmove; &#125; bool operator!=(Node* pmove) &#123; return this-&gt;pmove != pmove; &#125; iterator operator++() &#123; this-&gt;pmove = this-&gt;pmove-&gt;next; //链表++不了 return *this; &#125; int operator*() &#123; return this-&gt;pmove-&gt;data; //*运算访问数据 &#125; private: Node* pmove; //需要指针访问数据 &#125;; protected: Node* headNode; int curSize; &#125;; void my_list() &#123; List list; for (int i = 0; i &lt; 3; i++) &#123; list.push_front(i); &#125; List::iterator it; for (it = list.begin(); it != list.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; string str = &quot;ILoveyou&quot;; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl; //类中类访问一个容器数据 string::iterator it; for (it = str.begin(); it != str.end(); it++) &#123; cout &lt;&lt; *it; //*指针取值运算 &#125; cout &lt;&lt; endl; // cout &lt;&lt; *str.end() &lt;&lt; endl; my_list(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++友元","slug":"C++友元","date":"2022-05-20T10:37:54.000Z","updated":"2022-09-18T02:35:38.145Z","comments":true,"path":"2022/05/20/C++友元/","link":"","permalink":"http://goskp.github.io/2022/05/20/C++%E5%8F%8B%E5%85%83/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++友元C++友元是用friend关键修饰的函数或者类，友元用来打破类封装(忽视权限限定) 友元并不是说直接访问数据成员，友元只是提供一个场所赋予对象具有打破权限限定 友元函数 友元类 友元函数和友元类不属于当前类，实现函数或者类不需要类名限定 友元函数 普通函数成为类的友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; void print(); //友元函数 friend void visitedData(); friend void visited(MM mm); protected: int num; private: int age; string name; &#125;; void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; //友元函数 void visitedData() &#123; // name = &quot;ILoveyou&quot;; 不是直接访问，赋予对象的具有这样权限 //创建对象的无视权限 MM mm(&quot;girl&quot;, 18, 1001); cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; MM* p = new MM(&quot;new&quot;, 28, 1002); cout &lt;&lt; p-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;\\t&quot; &lt;&lt; p-&gt;num &lt;&lt; endl; &#125; void visited(MM mm) &#123; cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM girl(&quot;girl&quot;, 19, 1002); // girl.name=&quot;name&quot;; //类外只能访问public girl.print(); visitedData(); visited(girl); return 0; &#125; 以另一个类的成员函数为友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //前向声明 class A; class B &#123; public: B(int b) : b(b) &#123;&#125; void printA(A object); private: int b; &#125;; class A &#123; public: A(int a) : a(a) &#123;&#125; friend void B::printA(A object); private: int a; &#125;; void B::printA(A object) &#123; cout &lt;&lt; object.a &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; B b(111); A a(222); b.printA(a); return 0; &#125; /* A以B的成员函数为友元函数， B又以A类的成员函数为友元， 如果存在这种需求， 代码设计有问题， 但是C++允许这种关系 */ 友元类#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; friend class Boy; //声明boy类是MM友元类 public: MM(string name) : name(name) &#123;&#125; private: string name; &#125;; //友元类中，MM类的对象无视权限 class Boy &#123; public: Boy() : mm(&quot;mm&quot;) &#123; pObject = new MM(&quot;Object&quot;); &#125; void print() &#123; cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; mm.name &lt;&lt; endl; cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; pObject-&gt;name &lt;&lt; endl; MM* pMM = new MM(&quot;new&quot;); cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; pMM-&gt;name &lt;&lt; endl; &#125; private: MM mm; MM* pObject; &#125;; class A &#123; public: friend class B; void printA(); private: string a_name = &quot;A&quot;; &#125;; class B &#123; public: friend class A; void printB() &#123; A a; cout &lt;&lt; a.a_name &lt;&lt; endl; &#125; private: string b_name = &quot;B&quot;; &#125;; void A::printA() &#123; B b; cout &lt;&lt; b.b_name &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; Boy boy; boy.print(); B b; b.printB(); A a; a.printA(); return 0; &#125; 顺便介绍一下C++的强制类型转换#include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; int num = 1.11; cout &lt;&lt; num &lt;&lt; endl; int cnum = (int)1.11; cout &lt;&lt; cnum &lt;&lt; endl; int cppnum = int(1.22); // C++强制类型转换 cout &lt;&lt; cppnum &lt;&lt; endl; return 0; &#125; static_cast类型转换类似C语言的强制类型转换，按照C++的说法 比C语言的更为安全 基本数据类型的强制转换 空指针转换目标类型指针 不能操作带const属性的类型 // static_cast&lt;要转换的类型&gt;(要转换目标) //要转换的类型: 数据类型 //要转换目标 可以是表达式，或者常量，都可以 #include &lt;iostream&gt; using namespace std; void test_static_cast() &#123; // No.1 基本数据类型的强制转换 int num = static_cast&lt;int&gt;(1.111); // No.2 空类型指针的转换 double* pD = new double(1.11); void* pVoid = static_cast&lt;void*&gt;(pD); // No.3 不能做const属性的类型的转换 //增加const属性 //不能去掉const属性 int number = 11; const int cNum = static_cast&lt;const int&gt;(number); const int ccNum = number; const int data = 1; int* pData = (int*)(&amp;data); // C语言强制类型转换 // int* pcData = static_cast&lt;int*&gt;(&amp;data); //错误 &#125; int main(int argc, char** argv) &#123; test_static_cast(); return 0; &#125; const_cast类型转换 去掉const属性(提供一个可以修改接口去操作const数据类型) 加上const属性(用的少一点) #include &lt;iostream&gt; using namespace std; class Str &#123; public: // 1.去掉const属性 Str(const char* str) : str(const_cast&lt;char*&gt;(str)) &#123;&#125; void print() &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; private: char* str; &#125;; class Test &#123; public: void print() &#123; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl; &#125; private: &#125;; void printTest(const Test&amp; object) &#123; Test&amp; m_test = const_cast&lt;Test&amp;&gt;(object); m_test.print(); &#125; void test_const_cast() &#123; // 2.增加const属性 const int data = 1; int* pData = const_cast&lt;int*&gt;(&amp;data); *pData = 1001; //不会作用到const变量，只是单纯提供一个接口 cout &lt;&lt; &quot;data:&quot; &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;*pData:&quot; &lt;&lt; *pData &lt;&lt; endl; cout &lt;&lt; &amp;data &lt;&lt; endl; cout &lt;&lt; pData &lt;&lt; endl; Str str(&quot;ILoveyou&quot;); //错误，C++对于const要求更为严格 str.print(); char sstr[20] = &quot;ILoveyoud&quot;; Str str2(sstr); str2.print(); // 3.引用类型 Test test; test.print(); const Test&amp; c_test = test; // c_test.print(); //常属性的对象只能调用常成员函数 Test&amp; m_test = const_cast&lt;Test&amp;&gt;(c_test); m_test.print(); &#125; int main(int argc, char** argv) &#123; test_const_cast(); return 0; &#125; reinterpreat_cast类型转换把指针转换为一个整数，又可以把整数转换为一个指针，指针的效果依然有效 #include &lt;iostream&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; //官方案例 unsigned short Hash(void* p) &#123; unsigned int val = reinterpret_cast&lt;unsigned int&gt;(p); return (unsigned short)(val ^ (val &gt;&gt; 16)); &#125; void test_reinterpret_cast() &#123; int* p = reinterpret_cast&lt;int*&gt;(0); // p=nullptr; //官方案例 int a[20]; for (int i = 0; i &lt; 20; i++) cout &lt;&lt; Hash(a + i) &lt;&lt; endl; //允许将任何指针转换为任何其他指针类型。 //也允许将任何整数类型转换为任何指针类型以及反向转换 int* num = reinterpret_cast&lt;int*&gt;(Max); //把函数地址转换为int类型的数字 cout &lt;&lt; *num &lt;&lt; endl; auto pMax = reinterpret_cast&lt;int (*)(int, int)&gt;(num); cout &lt;&lt; &quot;max:&quot; &lt;&lt; pMax(1, 2) &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; test_reinterpret_cast(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++特殊成员","slug":"C++特殊成员","date":"2022-05-19T13:07:35.000Z","updated":"2022-09-18T02:35:44.401Z","comments":true,"path":"2022/05/19/C++特殊成员/","link":"","permalink":"http://goskp.github.io/2022/05/19/C++%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++特殊成员const成员 const修饰的数据成员 初始化必须采用初始化参数列表 不能被修改 构造函数必须要初始化常数据成员 const修饰的成员函数 写法上要注意: const修饰是写在函数后面 const成员函数不能修改任何的数据成员 如果实在是要在常成员函数中修改该数据，用mutable修饰数据成员即可 常成员函数可以普通函数同时存在 const对象 const修饰的对象 常对象只能调用常成员函数 #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM(int age) : name(&quot;小芳&quot;), num(4323) &#123; this-&gt;age = age; &#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; // MM() &#123;&#125; 常数据必须要初始化，错误 // MM() = default; //正确，可以构造无参对象 void print() &#123; age = 18; // num = 11; //不能修改常数据成员 cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl; &#125; //常成员函数： const写在函数后面 void print() const &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; cout &lt;&lt; &quot;常成员函数&quot; &lt;&lt; endl; &#125; void printData() const &#123; // age = 23; //常成员函数，不能修改数据成员 cout &lt;&lt; this-&gt;name &lt;&lt; this-&gt;num &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; void test() &#123;&#125; protected: //常数据成员 const string name; const int num; int age; // mutable 可修改的意思 &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;小丽&quot;, 18, 1001); //如果普通函数和常成员函数同名 mm.print(); //普通对象优先调用普通函数 const MM object(18); object.print(); //常对象只能调用常成员函数 object.printData(); // object.test(); // //错误，常对象只能调用常成员函数 return 0; &#125; static成员static成员不属于某一个单独对象，是属于类的，通俗一点讲，是所有对象的共享的，static成员依然受权限 satic成员他的访问可以不需要对象(用类名限定的方式去访问) static数据成员 初始化必须在类外初始化 类实现的时候不需要用static修饰了 static成员函数 static写在修饰函数的前面 类外实现也不需要static修饰 静态函数中没有this指针 静态成员函数的访问问题 静态成员函数访问静态成员 是可以直接访问 静态成员函数访问非静态数据成员，必须通过指定对象的方式 静态成员函数传参 在静态成员函数定义对象去访问 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class User &#123; public: User(string name = &quot;默认&quot;) &#123; this-&gt;count++; //类中访问 this-&gt;m_count++; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl; &#125; // void test() &#123;&#125; 不能和普通函数形参重载效果，会造成重定义问题 public: static void test(); static void testData(User&amp; object); private: string name; public: static int count; int m_count = 0; &#125;; //必须在类外面做初始化，不需要static修饰了 int User::count = 0; void User::test() &#123; cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl; // cout &lt;&lt; &quot;m_count:&quot; &lt;&lt; m_count &lt;&lt; endl; // //静态成员函数中不能直接调用非静态成员 cout &lt;&lt; &quot;静态函数&quot; &lt;&lt; endl; &#125; void User::testData(User&amp; object) &#123; cout &lt;&lt; object.m_count &lt;&lt; endl; //传参 User mm; cout &lt;&lt; mm.m_count &lt;&lt; endl; //创建对象 &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; User::count &lt;&lt; endl; // static 成员访问不需要对象 User object[3]; cout &lt;&lt; User::count &lt;&lt; endl; User mm; cout &lt;&lt; mm.count &lt;&lt; endl; cout &lt;&lt; User::count &lt;&lt; endl; //可以用类名访问，前提是权限没问题 cout &lt;&lt; mm.m_count &lt;&lt; endl; //不能用类名 User::test(); //因为存在这种调用，所以静态成员函数中不能存在this指针 mm.test(); return 0; &#125; 顺便介绍一下多文件的写法(Google) 一个类一个模块 声明写在.h 实现写在.cpp 声明和试下写在一起 .hpp 头文件包含尽量在.cpp完成 设计项目时候，头文件形成交叉包含，说明思想有问题，自己重新设计代码 不要为了拆分而拆分 静态数据成员多文件写法","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++类的组合案例","slug":"C++类的组合案例","date":"2022-05-18T11:07:35.000Z","updated":"2022-09-18T02:35:49.900Z","comments":true,"path":"2022/05/18/C++类的组合案例/","link":"","permalink":"http://goskp.github.io/2022/05/18/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++类的组合什么是类的组合类的组合就是以另一个的对象为数据成员，这种情况称之为类的组合 优先使用组合而不是继承 组合表达式的含义一部分的关系 初始化参数列表初始化参数列表是构造函数的另一种写法 应用场景： 形参名和数据成员相同，避免二义性问题 类和组合 必须要初始化参数列表的方式写构造 常数据成员必须采用初始化参数列表的方式 继承中子类的构造函数也必须初始化参数列表的方式 初始化参数列表基本形态 构造函数名(形参1，形参2....):数据成员1(形参1),数据成员2(形参2)... 初始化参数列表其他形态#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: //初始化参数列表 //可以避免形参名和数据成员名字相同 MM(string name, int age) : name(name), age(age) &#123;&#125; MM(string name) &#123; MM::name = name; //用类名标识一下帮助IDE去识别 &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; private: string name; int age; &#125;; //初始化参数列表其他写法 string name = &quot;initName&quot;; int returnValue() &#123; return 23; &#125; class Boy &#123; public: //无参构造函数 Boy() : name(&quot;Boy&quot;), age(111) &#123;&#125; //::name标识name是全局的 Boy(int age) : name(::name), age(returnValue()) &#123; cout &lt;&lt; age &lt;&lt; endl; //就近原则 &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; private: string name; int age; &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;name&quot;, 18); mm.print(); Boy boy; boy.print(); Boy pInt(12); pInt.print(); return 0; &#125; 类的组合案例分析 类组合包含的类的对象，必须采用初始化参数列表方式调用各自类当中的构造函数去初始化 组合中初始化参数列表的写法 要通过包含的类的构造函数决定组合类的构造函数怎么写 构造函数名(形参1，形参2，形参3....):对象1(形参1，形参2),对象2(形参3)... 组合类注意问题 组合类必须要调用包含对象所属类的构造函数 形式上看不到包含对象所属类构造函数调用，必须准备无参的构造函数 #include &lt;iostream&gt; using namespace std; //一种的关系 //一部分：组合 class Button &#123; public: Button() &#123; cout &lt;&lt; &quot;Button&quot; &lt;&lt; endl; &#125; Button(int x, int y, int w, int h) : x(x), y(y), w(w), h(h) &#123; cout &lt;&lt; &quot;Button&quot; &lt;&lt; endl; &#125; void Draw() &#123; cout &lt;&lt; &quot;按钮...&quot; &lt;&lt; endl; &#125; private: int x; int y; int w; int h; &#125;; class Edit &#123; public: Edit() &#123; cout &lt;&lt; &quot;Edit&quot; &lt;&lt; endl; &#125; Edit(int x, int y) : x(x), y(y) &#123; cout &lt;&lt; &quot;Edit&quot; &lt;&lt; endl; &#125; void Draw() &#123; cout &lt;&lt; &quot;编辑框....&quot; &lt;&lt; endl; &#125; private: int x; int y; &#125;; class Label &#123; public: Label() &#123; cout &lt;&lt; &quot;Label&quot; &lt;&lt; endl; &#125; Label(int x, int y, string text) : x(x), y(y), text(text) &#123; cout &lt;&lt; &quot;Label&quot; &lt;&lt; endl; &#125; void Draw() &#123; cout &lt;&lt; &quot;标签:&quot; &lt;&lt; text &lt;&lt; endl; &#125; private: int x; int y; string text; &#125;; class Window &#123; public: // window():button(),label(),edit()&#123;&#125; //形式上没有调用，实际构造对象，必定调用包含对象的无参构造函数 Window() &#123;&#125; Window(int bx, int by, int bw, int bh, int lx, int ly, string text, int ex, int ey) : button(bx, by, bw, bh), edit(ex, ey), label(lx, ly, text) &#123;&#125; void Show() &#123; button.Draw(); label.Draw(); edit.Draw(); &#125; Button getButton() &#123; return button; &#125; Label getLabel() &#123; return label; &#125; Edit getEdit() &#123; return edit; &#125; private: //以其他类的对象为数据成员 //构造顺序只和此处有关，和初始化参数列表顺序无关 Button button; Label label; Edit edit; &#125;; //另一种包含指针写法 class A &#123; public: A(int a) : a(a) &#123;&#125; int geta() &#123; return a; &#125; private: int a; &#125;; class B &#123; public: B(int b) : b(b) &#123;&#125; int getb() &#123; return b; &#125; private: int b; &#125;; class C &#123; public: C() &#123; pa = new A(12); pb = new B(123); &#125; C(int a, int b) : pa(new A(a)), pb(new B(b)) &#123;&#125; void visitData() &#123; cout &lt;&lt; pa-&gt;geta() &lt;&lt; endl; cout &lt;&lt; pb-&gt;getb() &lt;&lt; endl; &#125; private: A* pa; B* pb; &#125;; int main(int argc, char** argv) &#123; Window object; //优先构造包含对象，在构造自身对象 // object.getButton().Draw(); // object.getEdit().Draw(); // object.getLabel().Draw(); object.Show(); Window window(10, 10, 10, 10, 20, 20, &quot;Label&quot;, 30, 30); window.Show(); C c; c.visitData(); C value(1, 2); value.visitData(); return 0; &#125; 组合中构造和析构顺序问题 一般构造顺序和析构是相反 类的组合中，优先构造包含对象，在构造自身对象 类的组合中，包含对象的构造顺序只和定义顺序有关，和初始化参数列表无关 #include &lt;iostream&gt; using namespace std; class A &#123; public: A() &#123; cout &lt;&lt; &quot;A&quot;; &#125; ~A() &#123; cout &lt;&lt; &quot;A&quot;; &#125; &#125;; class B &#123; public: B() &#123; cout &lt;&lt; &quot;B&quot;; &#125; ~B() &#123; cout &lt;&lt; &quot;B&quot;; &#125; &#125;; class C &#123; public: C() &#123; cout &lt;&lt; &quot;C&quot;; &#125; ~C() &#123; cout &lt;&lt; &quot;C&quot;; &#125; &#125;; class D &#123; public: D() &#123; cout &lt;&lt; &quot;D&quot;; &#125; //初始化参数列表写出去迷惑 ~D() &#123; cout &lt;&lt; &quot;D&quot;; &#125; A a; // A B b; // B C c; // C // D &#125;; int main(int argc, char** argv) &#123; &#123; D d; &#125; return 0; &#125; this指针任何类中都存在一个this指针，this指针只允许在类中函数的函数中使用 this指针代表的是每一个对象抽象地址 基本用法避免形参名和数据成员的名相同 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age); void modifyData(string name, int age) &#123; // MM::name = name; // MM::age = age; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; this &lt;&lt; endl; &#125; void print(); protected: string name; int age; &#125;; //初始化参数列表类外也行 MM::MM(string name, int age) : name(name), age(age) &#123;&#125; void MM::print() &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 18); mm.modifyData(&quot;MM&quot;, 28); // this=&amp;mm; cout &lt;&lt; &quot;&amp;mm:&quot; &lt;&lt; &amp;mm &lt;&lt; endl; MM girl(&quot;girl&quot;, 19); girl.modifyData(&quot;girl&quot;, 29); // this=&amp;girl; cout &lt;&lt; &quot;&amp;girl:&quot; &lt;&lt; &amp;girl &lt;&lt; endl; return 0; &#125; 其他作用操作对象自身做一些事情 返回对象本身函数 返回对象本身的地址 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age); void modifyData(string name, int age) &#123; // MM::name = name; // MM::age = age; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; this &lt;&lt; endl; &#125; MM&amp; returnMM() &#123; return *this; &#125; MM* returnMMPoint() &#123; return this; &#125; void print(); protected: string name; int age; &#125;; //初始化参数列表类外也行 MM::MM(string name, int age) : name(name), age(age) &#123;&#125; void MM::print() &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 18); mm.modifyData(&quot;MM&quot;, 28); // this=&amp;mm; cout &lt;&lt; &quot;&amp;mm:&quot; &lt;&lt; &amp;mm &lt;&lt; endl; MM girl(&quot;girl&quot;, 19); girl.modifyData(&quot;girl&quot;, 29); // this=&amp;girl; cout &lt;&lt; &quot;&amp;girl:&quot; &lt;&lt; &amp;girl &lt;&lt; endl; //奇葩写法 mm.returnMM().returnMM().returnMM().returnMM().print(); mm.returnMMPoint()-&gt;returnMMPoint()-&gt;returnMMPoint()-&gt;print(); mm.print(); mm.returnMMPoint()-&gt;print(); return 0; &#125; 类中类类中类就是一个类定义在另一个类当中 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List(); void insertData(int data); void printList() &#123; Node* pmove = headNode-&gt;next; while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;data &lt;&lt; &quot; &quot;; pmove = pmove-&gt;next; &#125; cout &lt;&lt; endl; &#125; Node* begin() &#123; return headNode; &#125; private: Node* headNode; public: //类中类 class Iterator &#123; public: Iterator(Node* pmove = nullptr); private: Node* pmove; &#125;; &#125;; List::List() &#123; headNode = new Node; &#125; void List::insertData(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); &#125; //类中类的访问剥洋葱 List::Iterator::Iterator(Node* pmove) : pmove(pmove) &#123;&#125; int main(int argc, char** argv) &#123; List list; List::Iterator it = list.begin(); list.insertData(1); list.insertData(2); list.insertData(3); list.printList(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++构造与析构","slug":"C++构造与析构","date":"2022-05-17T05:17:08.000Z","updated":"2022-09-18T02:35:55.011Z","comments":true,"path":"2022/05/17/C++构造与析构/","link":"","permalink":"http://goskp.github.io/2022/05/17/C++%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++构造和析构构造函数 名字和类名相同 没有返回值 构造函数是用来构造对象，构造对象时候必定调用构造函数 不写构造函数，存在一个默认的构造函数，默认的构造函数是无参，所以可以构造无参对象 默认的构造函数可以删掉，通过delete删除默认的构造函数 显示使用默认的构造函数, 通过default做显示调用 通常情况构造函数是public属性 自己写了构造函数，默认的构造函数就不存在了 构造函数决定对象的长相(构造函数无参，对象无参，构造有一个，对象必须也要一个参数) 构造函数通常做的事情，就是给数据成员初始化 构造函数也是函数，所以也可以重载，也可以缺省 通过重载和缺省，实现构造不同长相对象 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: // MM() = default; //显式使用默认的构造函数 // MM() = delete; //删掉默认的构造函数 MM(string name, int age) &#123; m_name = name; m_age = age; cout &lt;&lt; &quot;两个参数的构造函数&quot; &lt;&lt; endl; &#125; MM() = default; //默认无参构造函数，据说速度更快 void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; protected: string m_name; int m_age; &#125;; // MM::MM() //&#123; // cout &lt;&lt; &quot;调用无参构造函数&quot; &lt;&lt; endl; // &#125; struct Boy &#123; string name; int age; int num; //一旦C++结构体中写了构造函数，必须当做类去操作，不能用C语言的那种方式使用 Boy() &#123;&#125; Boy(string bname, int bage) &#123; name = bname; age = bage; &#125; &#125;; void testStruct() &#123; // Boy boy = &#123; &quot;string&quot;,18,1001&#125;; //错误 //这个地方也是创建对象过程，所以数据也需要和构造函数 Boy boy = &#123;&quot;string&quot;, 18&#125;; //这里数据必须和构造函数的一致 Boy boy2; Boy array[3]; &#125; int main(int argc, char** argv) &#123; // MM mm; // //因为构造函数有两个参数，对象也必须带有两参数 MM mm(&quot;对象&quot;, 18); //这步创建对象的过程就是调用构造函数构造函数的过程 mm.printMM(); MM empty; //调用无参构造函数 // new一个对象 MM* p = new MM; //调用无参的构造函数 MM* p2 = new MM(&quot;对象&quot;, 29); //调用有参的构造函数 return 0; &#125; 析构函数 ~类名 当做析构函数名字 没有参数 释放数据成员new的内存 在对象死亡前自动调用 通常如果数据成员没有做new操作，就可以不写析构函数 不写析构函数，存在一个默认的析构函数 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM(const char* str =&quot;ILoveyou&quot;) &#123; //缺省,相当于存在两个构造函数，一个是无参的，一个是有参 int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; ~MM(); protected: char* name; &#125;; MM::~MM() &#123; if (name != nullptr) &#123; delete[] name; name = nullptr; &#125; cout &lt;&lt; &quot;析构函数....\\n&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; &#123; MM mm; MM* p = new MM; cout &lt;&lt; &quot;1......&quot; &lt;&lt; endl; delete p; //立刻调用析构函数 p = nullptr; cout &lt;&lt; &quot;2.......&quot; &lt;&lt; endl; &#125; &#123; MM beauty(&quot;Continue&quot;); &#125; cout &lt;&lt; &quot;对象死亡&quot; &lt;&lt; endl; return 0; &#125; 拷贝构造函数 拷贝构造函数也是构造函数 拷贝构造函数参数是固定的:对对象的引用 拷贝构造函数不写会存在一个默认的拷贝构造函数 拷贝构造函数作用： 通过一个对象产生另一个对象 关键点：一定是有一个新的对象产生 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) &#123; m_name = name; m_age = age; &#125; MM(MM&amp; object); void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; protected: string m_name; int m_age; &#125;; //拷贝构造函数 //通过传入对象属性确定创建对象的属性 MM::MM(MM&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; cout &lt;&lt; &quot;调用自己写的拷贝构造函数&quot; &lt;&lt; endl; &#125; //函数传参也可以隐式调用 void print(MM object) &#123; // MM object=girl object.printMM(); &#125; // C++中传参能用引用就用，效率搞 void printData(MM&amp; object) &#123; //引用就是别名，没有产生新的对象 object.printMM(); &#125; int main(int argc, char** argv) &#123; MM mm(&quot;C神&quot;, 18); //产生一个对象 MM beauty = mm; //隐式调用拷贝构造函数 MM girl(beauty); //显式调用拷贝构造函数 print(girl); //调用拷贝构造函数 printData(girl); MM boy; //对象先有了，才赋值，不调用拷贝 boy = girl; //不调用拷贝构造函数--&gt;默认重载=运算符(后续会详细阐述) return 0; &#125; 深浅拷贝问题浅拷贝 没有在拷贝构造函数中给数据成员做new操作 默认拷贝构造函数都是浅拷贝 深拷贝 在拷贝构造函数中做了new操作 浅拷贝导致内存释放问题浅拷贝会导致同一段内存重复释放问题 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* str) &#123; int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; // MM(MM&amp; object) &#123; // name = object.name; // &#125; ~MM() &#123; if (name != nullptr) &#123; //浅拷贝导致内存释放问题 //浅拷贝会导致同一段内存重复释放问题 //两个指针都指向同一段内存 delete[] name; name = nullptr; &#125; &#125; private: char* name; &#125;; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;); MM mm = girl; //调用拷贝构造函数 &#125; return 0; &#125; 深拷贝解决方案#include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* str) &#123; int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; MM(MM&amp; object) &#123; // name = object.name; int length = strlen(object.name) + 1; name = new char[length]; strcpy(name, object.name); &#125; ~MM() &#123; if (name != nullptr) &#123; delete[] name; name = nullptr; &#125; &#125; private: char* name; &#125;; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;); MM mm = girl; //调用拷贝构造函数 &#125; return 0; &#125; 综上： 一旦类中有指针，做了内存申请，并且要对对象做拷贝操作，就必须使用深拷贝 匿名对象匿名对象就是无名对象，匿名对象只能充当右值，所以匿名对象拷贝必须存在移动拷贝，或者准备一个ecosnt限定普通拷贝构造函数。 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM()&#123;&#125;; MM(string name, int age) &#123; m_name = name; m_age = age; &#125; void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; MM(MM&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; &#125; //移动构造---&gt;新标准的 MM(MM&amp;&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; cout &lt;&lt; &quot;调用移动构造&quot; &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构打印name:&quot; &lt;&lt; m_name &lt;&lt; endl; &#125; private: string m_name; int m_age; &#125;; MM returnMM(string name, int age) &#123; return MM(name, age); //构造一个匿名对象当做函数返回值 &#125; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;, 19); //匿名对象是一个右值 MM mm = MM(&quot;mm&quot;, 29); //匿名对象 ---&gt;匿名对象转正 ，mm接管所有权 cout &lt;&lt; &quot;匿名对象已死亡&quot; &lt;&lt; endl; &#125; MM beauty = returnMM(&quot;返回值&quot;, 18); beauty.printMM(); return 0; &#125; 构造和析构顺序问题 一般情况构造顺序和析构是相反的 静态的和全局的是最后释放的 delete 立刻调用析构函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test &#123; public: Test(string data = &quot;A&quot;) &#123; m_data = data; cout &lt;&lt; m_data; &#125; ~Test() &#123; cout &lt;&lt; m_data; &#125; protected: string m_data; &#125;; int main(int argc, char** argv) &#123; &#123; Test t1; // A static Test t2(&quot;B&quot;); // B Test array[3]; // AAA //数组就是多个无参 Test* p = new Test(&quot;C&quot;); // C delete p; // C p = nullptr; &#125; // ABAAACCAAAAB return 0; &#125; //用构造函数的方式简单实现单链表 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List(); void insertData(int data); void printList() &#123; Node* pmove = headNode-&gt;next; while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;data &lt;&lt; &quot; &quot;; pmove = pmove-&gt;next; &#125; cout &lt;&lt; endl; &#125; private: Node* headNode; &#125;; List::List() &#123; headNode = new Node; &#125; void List::insertData(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); &#125; int main(int argc, char** argv) &#123; List list; list.insertData(1); list.insertData(2); list.insertData(3); list.printList(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++类和对象","slug":"C++类和对象","date":"2022-05-16T03:58:16.000Z","updated":"2022-09-18T02:35:48.187Z","comments":true,"path":"2022/05/16/C++类和对象/","link":"","permalink":"http://goskp.github.io/2022/05/16/C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++类和对象初识类的创建 类和结构体区别 在没写构造函数之前，C语言结构体就按照C语言的方式用即可 用了构造函数时候，结构体直接当做C++类去使用 结构体其实可以当做一个默认权限是公有属性的类 C++是允许空类和结构体存在 class 类名 &#123; //默认为私有属性 //..... public: //类外只能访问公有属性 //....公有属性 //公有函数---&gt;类外的公有接口 protected: //....保护属性 private: //....私有属性 &#125;; //保护和私有属性区别，暂时不需要知道，后续讲继承的时候会讲 //类中没有权限可言 创建类完整代码class MM &#123; public: void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; void print(); protected: private: //一般数据成员写：私有属性 string name; int age; int num; &#125;; //在类外实现类中的函数，必须要用类名限定(类名::函数名) void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; 结构体和类的区别// C++类和对象 #include &lt;iostream&gt; using namespace std; class MM &#123; int num; //类中默认的是私有属性 public: int age; private: string name; &#125;; struct Boy &#123; //结构体中默认的公有属性 int num; int age; private: string name; &#125;; // C语言是不能写空的结构体 // C++允许空结构体或者类 struct Empty &#123; //占用内存不是0 是1(标记),写了数据这个标记就不存在 &#125; m; //作用:泛型编程做参数包解析的递归循环终止处理 int main(int argc, char** argv) &#123; struct Boy boy; // boy.num = 1001; // boy.age = 12; MM mm; mm.age = 19; cout &lt;&lt; sizeof(Empty) &lt;&lt; endl; cout &lt;&lt; sizeof(Boy) &lt;&lt; endl; return 0; &#125; 对象创建和初始化对象创建 创建普通对象 创建对象数组 创建对象指针 对象的初始化 类中直接给数据赋值 提供一个共有接口去操作数据 提供一个返回引用的接口 完整代码#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void printData() &#123; //普通成员函数只是写在类中，不占对象内存 cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; void print(); void initData(string mmName, int mmAge, int mmNum) &#123; name = mmName; age = mmAge; num = mmNum; &#125; string&amp; getName() &#123; return name; &#125; int&amp; getAge() &#123; return age; &#125; int&amp; getNum() &#123; return num; &#125; protected: private: //一般数据成员写：私有属性 string name = &quot;默认值&quot;; int age = 0; int num = 0; &#125;; //在类外实现类中的函数，必须要用类名限定(类名::函数名) void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm; //创建对象 MM array[3]; MM* pMM; pMM = &amp;mm; pMM = new MM; // new一个对象 // new一个对象过程 // 1.创建一个匿名对象(没有名字的对象) // 2.把匿名对象的首地址赋值指针 pMM-&gt;print(); pMM-&gt;printData(); // pMM-&gt;name = &quot;小芳&quot;; 不可访问，类外不能访问public之外的所有属性 cout &lt;&lt; &quot;通过提供共有接口传参的方式初始化对象的数据&quot; &lt;&lt; endl; mm.initData(&quot;小芳&quot;, 18, 1001); mm.printData(); cout &lt;&lt; &quot;返回引用的去访问数据&quot; &lt;&lt; endl; MM* p = new MM; p-&gt;getName() = &quot;MM&quot;; p-&gt;getAge() = 28; p-&gt;getNum() = 1004; p-&gt;printData(); return 0; &#125; 成员的访问 类中普通数据成员和成员函数必须通过对象去访问 只有两种方案 普通对象: 用 对象.成员访问 对象指针:用 对象指针-&gt;成员 案例代码#include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void initData(string mmName, int mmAge, int mmNum) &#123; name = mmName; age = mmAge; num = mmNum; &#125; //不想让别人直接修改数据，不要返回引用，只能看不能操作 string getName() &#123; return name; &#125; int getAge() &#123; return age; &#125; int getNum() &#123; return num; &#125; private: string name; int age; int num; &#125;; void testObject() &#123; MM mm; mm.initData(&quot;小芳&quot;, 19, 1002); cout &lt;&lt; mm.getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.getNum() &lt;&lt; endl; // IMAGE img; // img.getwidth(); // img.getheight(); &#125; void testObjectPoint() &#123; MM* pMM = new MM; pMM-&gt;initData(&quot;小丽&quot;, 29, 1004); cout &lt;&lt; pMM-&gt;getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;getNum() &lt;&lt; endl; &#125; void testArray() &#123; MM array[3]; for (int i = 0; i &lt; 3; i++) &#123; string name = &quot;name&quot; + to_string(i); //iomanip array[i].initData(name, 18 + i, 1002 + i); cout &lt;&lt; (array + i)-&gt;getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; (array + i)-&gt;getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; (array + i)-&gt;getNum() &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; // age = 123; 不能直接访问 testObject(); testObjectPoint(); testArray(); return 0; &#125; 类和对象的其他操作类中含有指针问题含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题 // 含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: void initData(const char* mmName, int mmAge); void initMM(const char* mmName, int mmAge); void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; char*&amp; getName() &#123; return name; &#125; protected: char* name; int age; &#125;; //一般不采用这种方案处理,诟病很大 void MM::initData(const char* mmName, int mmAge) &#123; name = (char*)mmName; age = mmAge; &#125; void MM::initMM(const char* mmName, int mmAge) &#123; name = new char[strlen(mmName) + 1]; strcpy(name, mmName); age = mmAge; &#125; void printConst(const char* str) &#123; //传入常量和变量 传参const修饰 cout &lt;&lt; str &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM* pMM = new MM; pMM-&gt;initData(&quot;张三&quot;, 19); pMM-&gt;print(); // strcpy(pMM-&gt;getName(), &quot;ILoveyou&quot;); // // 百分百有问题，name没有指向一段可操作内存 char str[10] = &quot;ILoveyou&quot;; // C++const要求更为严格，尤其是字符串处理 printConst(&quot;ILoveyou&quot;); printConst(str); pMM-&gt;getName() = str; pMM-&gt;print(); MM* p = new MM; p-&gt;initMM(&quot;ILoveyou&quot;, 20); p-&gt;print(); strcpy(p-&gt;getName(), &quot;IMiss&quot;); p-&gt;print(); return 0; &#125; 类不能直接包含自身的对象只能包含自身指针不能包含自身对象 class Boy &#123; public: //Boy boy; 错误代码 Boy* pBoy; //指针正确 &#125;; 成员函数指针调用成员函数#include &lt;iostream&gt; using namespace std; class Test &#123; public: void print(string info) &#123; cout &lt;&lt; info &lt;&lt; endl; &#125; &#125;; void testFunc() &#123; Test test; // void (*Func)(string) = nullptr; // Func = &amp;Test::print; 错误写法，类型 // 1.auto自动推断出类成员函数指针类型 auto Funcf = &amp;Test::print; //没问题 (test.*Funcf)(&quot;测试函数&quot;); //调用还是要学会 Test testb; (testb.*Funcf)(&quot;测试函数2&quot;); testb.print(&quot;直接调用&quot;); // 2.正规写一下正常写法 //不是简单的用*指针名替换函数，而是要加上类名限定 void (Test::*Func)(string) = nullptr; Func = &amp;Test::print; //类中所有东西，无论怎么访问，必须类名限定 (test.*Func)(&quot;类成员函数指针访问成员函数&quot;); &#125; int main(int argc, char** argv) &#123; testFunc(); return 0; &#125; 对象本质 对象的本质就是一个数据,只是数据包含操作 因为对象的本质是一个数据，所以变量能做的，它都可以 当做函数参数 当做函数返回值 当做另一个结构体数据成员 当做另一个类的数据成员 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student &#123; public: void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; string&amp; getName() &#123; return name; &#125; int&amp; getAge() &#123; return age; &#125; protected: string name; int age; &#125;; void printData(Student student) &#123; student.print(); &#125; //子函数修改实参，C语言传入实参地址，C++传引用 void modifyStudent(Student&amp; stu) &#123; stu.getName() = &quot;Memory&quot;; stu.getAge() = 28; &#125; Student* createStu(string name, int age) &#123; Student* p = new Student; p-&gt;getName() = name; p-&gt;getAge() = age; return p; &#125; void testStudent() &#123; Student stu; modifyStudent(stu); printData(stu); Student* p = createStu(&quot;C++&quot;, 19); p-&gt;print(); Student temp = *p; temp.print(); //除了赋值之外，其他运算不能直接做 // Student temp1 = temp + temp; //算术+条件 &#125; int main(int argc, char** argv) &#123; testStudent(); return 0; &#125; // C++的方式简单实现链表操作 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; struct Node* p_next; &#125;; class List &#123; public: void Initlist(); Node* CreateNode(int new_data); void InsertNode(int new_data); void DeleteNodeByPosData(int pos_data); void PrintList(); protected: Node* p_head_node; //表头 int cur_size; //链表中结点个数 &#125;; void List::Initlist() &#123; p_head_node = new Node; p_head_node-&gt;p_next = nullptr; cur_size = 0; &#125; Node* List::CreateNode(int new_data) &#123; Node* p_new_node = new Node; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = nullptr; return p_new_node; &#125; void List::InsertNode(int new_data) &#123; Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; cur_size++; &#125; void List::DeleteNodeByPosData(int pos_data) &#123; Node* p_pre_node = p_head_node; Node* p_cur_node = p_head_node-&gt;p_next; while (p_cur_node != nullptr &amp;&amp; p_cur_node-&gt;data != pos_data) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (p_cur_node == nullptr) &#123; cout &lt;&lt; &quot;没有找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; delete p_cur_node; p_cur_node = nullptr; &#125; &#125; void List::PrintList() &#123; Node* p_move = p_head_node-&gt;p_next; while (p_move != nullptr) &#123; cout &lt;&lt; p_move-&gt;data; p_move = p_move-&gt;p_next; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; List* p_list = new List; p_list-&gt;Initlist(); for (int i = 0; i &lt; 3; ++i) &#123; p_list-&gt;InsertNode(i); &#125; p_list-&gt;PrintList(); p_list-&gt;DeleteNodeByPosData(1); p_list-&gt;PrintList(); return 0; &#125; 结点和链表都用类#include &lt;iostream&gt; using namespace std; class Node &#123; public: int&amp; getData() &#123; return data; &#125; struct Node*&amp; getNext() &#123; return next; &#125; protected: int data; struct Node* next; &#125;; class List &#123; public: void initList(); void insertData(int data); void printData(); void deleteNode(int posData); protected: Node* headNode; //表示表头 int curSize; //当前节点个数 &#125;; void List::initList() &#123; headNode = new Node; headNode-&gt;getNext() = nullptr; curSize = 0; &#125; void List::insertData(int data) &#123; //创建新节点 Node* newNode = new Node; newNode-&gt;getData() = data; newNode-&gt;getNext() = nullptr; //表头插入链接 newNode-&gt;getNext() = headNode-&gt;getNext(); headNode-&gt;getNext() = newNode; curSize++; &#125; void List::printData() &#123; Node* pmove = headNode-&gt;getNext(); while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;getData() &lt;&lt; &quot; &quot;; pmove = pmove-&gt;getNext(); &#125; cout &lt;&lt; endl; &#125; void List::deleteNode(int posData) &#123; Node* preNode = headNode; Node* curPos = headNode-&gt;getNext(); while (curPos != nullptr &amp;&amp; curPos-&gt;getData() != posData) &#123; preNode = curPos; curPos = preNode-&gt;getNext(); &#125; if (curPos == nullptr) &#123; cout &lt;&lt; &quot;没有找到无法做指定位置删除...&quot; &lt;&lt; endl; &#125; else &#123; preNode-&gt;getNext() = curPos-&gt;getNext(); delete curPos; curPos = nullptr; &#125; &#125; int main(int argc, char** argv) &#123; List* p = new List; p-&gt;initList(); for (int i = 0; i &lt; 3; i++) &#123; p-&gt;insertData(i); &#125; p-&gt;printData(); p-&gt;deleteNode(1); p-&gt;printData(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++和C的区别","slug":"C++和C的区别","date":"2022-05-15T07:24:31.000Z","updated":"2022-09-18T02:36:17.894Z","comments":true,"path":"2022/05/15/C++和C的区别/","link":"","permalink":"http://goskp.github.io/2022/05/15/C++%E5%92%8CC%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++和C的区别头文件包含问题#include &lt;iostream&gt; //不需要.h 直接包含 int main(int argc, char** argv) &#123; return 0; &#125; 创建的项目源文件是.cpp 头文件的包含不同 不需要.h 直接包含 C语言的标准库头文件 依然按照原来方式包含，一定程序C++兼容C语言 C++包含方式: c+原来的头文件，去掉.h #include &lt;ctime&gt; 完整代码#include &lt;stdio.h&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; #include &quot;myhead.h&quot; //自己写的依旧是按照原来方式 int main(int argc, char** argv) &#123; printf(&quot;C语言的函数！\\n&quot;); return 0; &#125; C++命名空间什么是命名空间namespace 空间名 &#123; //变量 //函数 //结构体 //类 &#125; // namespace 空间名 //用namespace 声明一个东西 可以提高标识符使用，可以避免命名污染 如何创建命名空间namespace 空间名 &#123; //变量 //函数 //结构体 //类 &#125; //用namespace 声明一个东西 怎么访问命名空间 :: :作用域分辨符 访问空间中的成员: 空间名::成员名 用来区分全局变量和局部变量 ::全局变量 #include &lt;cstdio&gt; #include &lt;iostream&gt; namespace MM &#123; int age = 1; void print() &#123; printf(&quot;MM\\n&quot;); &#125; &#125; // namespace MM namespace Boy &#123; int age = 2; &#125; int g_num = 1001; int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, MM::age); printf(&quot;%d\\n&quot;, Boy::age); int g_num = 1; printf(&quot;全局变量:%d\\n&quot;, ::g_num); return 0; &#125; 省略前缀的方式去调用 //using namespace 空间名; //要省略的空间名 //注意点：有作用域 #include &lt;iostream&gt; #include &lt;cstdio&gt; namespace MM &#123; int age = 1; void print() &#123; printf(&quot;MM\\n&quot;); &#125; &#125; namespace Boy &#123; int age = 2; &#125; int g_num = 1001; int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, MM::age); printf(&quot;%d\\n&quot;, Boy::age); int g_num = 1; printf(&quot;全局变量:%d\\n&quot;, ::g_num); MM::print(); using namespace MM; //省略前缀的调用方式 print(); using namespace Boy; //printf(&quot;%d\\n&quot;, age); //二义性问题：有两个选择，不知道找谁 printf(&quot;%d\\n&quot;, Boy::age); printf(&quot;%d\\n&quot;, MM::age); return 0; &#125; 命名空间嵌套namespace A &#123; int a=1; namespace B &#123; int b = 1; &#125; &#125; void test() &#123; //剥洋葱 A::a = 1; A::B::b = 2; using namespace A::B; b = 3; &#125; 先声明后实现//其他写法： 先声明后实现的一种写法 namespace Data &#123; void print(); struct student; &#125; //必须空间名限定 void Data::print() &#123; &#125; struct Data::student &#123; int age; int num; &#125;; 标准的命名空间std C++所有的函数和类都是属于标准命名空间 不写using namespace std; 意味着所有C++标准库中的东西都需要加上std:: using namespace std; //习惯性的操作 C++函数新思想函数重载什么是函数重载C++允许同名不同参数的函数存在，C语言不允许同名函数存在 不同参数的三个体现 数目不同 类型不同 顺序不同：前提条件是存在不同类型 #include &lt;iostream&gt; using namespace std; //类型不同 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; float Max(float a, float b) &#123; return a &gt; b ? a : b; &#125; //顺序不同 // error C2084: 函数“int Max(int,int)”已有主体 // int Max(int b, int a) //&#123; // //&#125; void print(int a, char c) &#123;&#125; void print(char a, int c) &#123;&#125; //数目不同 void print(int a, int b, int c) &#123;&#125; //想当然了 // double就是末尾加个d 错误的 // char就是加个c嘛 错误的 int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, Max(1, 2)); printf(&quot;%.1f\\n&quot;, Max(1.1f, 2.2f)); //错误，C++对于类型要求比C语言严格 1L; // long 1.1f; // float 1u; // unsiged; //默认的小数是double; return 0; &#125; 函数重载和函数返回值一点毛线关系都没有。 函数缺省什么是函数缺省函数缺省就是给形参赋初始值，当不传参的时候使用的是默认值 函数缺省规则 只能从右往左缺省，中间不能有空着的 多文件中，.h文件缺省了，cpp不需要缺省(声明做了缺省，实现就不需要缺省) 缺省的好处实现函数的不同形态的调用，针对不同需求做不同实现 #include &lt;iostream&gt; using namespace std; //函数缺省 void printData(int a = 1, float b = 1.11f, double c = 1.11, char d = &#39;A&#39;) &#123; printf(&quot;%d\\t%f\\t%lf\\t%c\\n&quot;, a, b, c, d); &#125; int main(int argc, char** argv) &#123; printData(); //所有形参都是默认值 printData(9); // a=9,其他值用默认值 printData(9, 2.22f); // a=9 b=2.22 其他默认值 printData(9, 2.22f, 9.9); // a=9,b=2.22 c=9.9 其他默认值 printData(9, 2.22f, 9.9, &#39;D&#39;); //所有的值用的是传入的值 return 0; &#125; C++标准输入和输出标准输出 cout + &lt;&lt; 一起完成的 换行: endl替换”\\n” #include &lt;iostream&gt; using namespace std; //缺省std前缀的 struct MM &#123; char name[20]; int age; int num; &#125;; int main(int argc, char** argv) &#123; //单个数据输出 std::cout &lt;&lt; &quot;ILoveyou&quot;; //没有写using namespace std; 必须加前缀 cout &lt;&lt; 1; //多个数据的输出 cout &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;编号\\n&quot;; struct MM mm = &#123;&quot;mm&quot;, 18, 1001&#125;; cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; &quot;\\n&quot;; //和上面一行代码效果一样 cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; mm.num &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; endl; //等效:cout&lt;&lt;&quot;\\n&quot;; std::cout &lt;&lt; std::endl; //一样的是std命名空间中的 return 0; &#125; 标准输入 cin+ &gt;&gt; 一起完成 输入不需要任何的格式控制字符 #include &lt;iostream&gt; using namespace std; //缺省std前缀的 struct MM &#123; char name[20]; int age; int num; &#125;; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;请输入一个整数:&quot;; int num; cin &gt;&gt; num; //变量名 cout &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;请输入一个字符串:&quot;; char str[20]; while (getchar() != &#39;\\n&#39;); //存在跳过显现:清空缓冲区 // setbuf(stdin, NULL); // //影响汉字输入，汉字的文件操作出现问题 fflush(stdin); // //C++中已经淘汰了，有时候使用没有效果 cin &gt;&gt; str; //数组名 cout &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;input num and str:&quot;; cin &gt;&gt; num &gt;&gt; str; cout &lt;&lt; num &lt;&lt; &quot;\\t&quot; &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;input name,age,num:&quot;; struct MM temp; cin &gt;&gt; temp.name &gt;&gt; temp.age &gt;&gt; temp.num; cout &lt;&lt; &quot;姓名\\t年龄\\t编号&quot; &lt;&lt; endl; cout &lt;&lt; temp.name &lt;&lt; &quot;\\t&quot; &lt;&lt; temp.age &lt;&lt; &quot;\\t&quot; &lt;&lt; temp.num &lt;&lt; endl; return 0; &#125; //用C++ 子函数的方式实现模拟登录 #include &lt;conio.h&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void Input(char* userName, char* passWord) &#123; //..... //登录实现密码不可见 cout &lt;&lt; &quot;用户名:&quot;; cin &gt;&gt; userName; while (getchar() != &#39;\\n&#39;); int i = 0; char key = 0; cout &lt;&lt; &quot;密 码:&quot;; while ((key = _getch()) != &#39;\\r&#39;) &#123; cout &lt;&lt; &quot;*&quot;; passWord[i++] = key; &#125; passWord[i] = &#39;\\0&#39;; cout &lt;&lt; endl; &#125; int Login(char* username, char* passWord, const char* root = &quot;root&quot;, const char* pass = &quot;12345&quot;) &#123; //比较验证 if (strcmp(username, root) == 0 &amp;&amp; strcmp(passWord, pass) == 0) &#123; return 1; &#125; return 0; &#125; int main(int argc, char** argv) &#123; char userName[20] = &#123;&quot;&quot;&#125;; char passWord[7] = &#123;&quot;&quot;&#125;; Input(userName, passWord); if (Login(userName, passWord) == 1) &#123; //登录成功 cout &lt;&lt; &quot;登录成功&quot; &lt;&lt; endl; &#125; else &#123; //打印用户名和密码错误 cout &lt;&lt; &quot;打印用户名和密码错误&quot; &lt;&lt; endl; &#125; return 0; &#125; 新基本数据类型bool类型 占用内存是1个字节 打印出来的值是： 0或者1 非零值表示成立 通常用的是false和true做初始化 #include &lt;iostream&gt; void testBool() &#123; bool bNum = 5; std::cout &lt;&lt; bNum &lt;&lt; std::endl; //一般是会用都用关键字初始化 bNum = false; bNum = true; //用途: //做开关 //做标记--&gt;查找类的操作 //做函数返回值 while (true) ; //死循环 &#125; int main(int argc, char** argv) &#123; testBool(); return 0; &#125; 引用类型把引用类型理解为一个起别名的用法 左值引用 当做函数参数: 直接修改实参，防止拷贝本产生 当做返回值: 增加左值使用 const属性限定问题 右值引用 给右值起别名 当做函数参数: 函数只能传入右值 想要传入左值，使用move函数移动 // 引用类型 /* 左值引用: 当做函数参数: 直接修改实参，防止拷贝本产生 当做返回值: 增加左值使用 const属性限定问题 右值引用: 给右值起别名 当做函数参数: 函数只能传入右值 想要传入左值，使用move函数移动 */ #include &lt;iostream&gt; using namespace std; // 引用类型 // int&amp; x=b; void Modify(int&amp; x) &#123; x = 9999; &#125; //返回引用等效返回一个变量 //不能返回局部变量的引用 int g_num = 1001; int&amp; getValue() &#123; //就相当于与一个变量,可充当左值 return g_num; &#125; int getData() &#123; //返回变量相当于一个值,不能充当左值 return g_num; &#125; // char* str=&quot;Iloveyou&quot; void printString(const char* str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; void modifyNum(const int&amp; num) &#123; // num++; //常引用不能做++ cout &lt;&lt; num &lt;&lt; endl; &#125; //只能传入右值 void modifyNum2(int&amp;&amp; num) &#123; num++; //提供修改接口 cout &lt;&lt; num &lt;&lt; endl; &#125; void testNew() &#123; int a = 1; int&amp; b = a; b = 1001; cout &lt;&lt; a &lt;&lt; endl; //当做函数返回值：增加左值使用好处 //当做函数参数：防止拷贝本的产生 Modify(b); cout &lt;&lt; a &lt;&lt; endl; // getData() = 1003; 错误，返回是一个值，不是一个变量，不能充当运算符左值 getValue() = 9999; // 等效于g_num=9999; cout &lt;&lt; g_num &lt;&lt; endl; //常量起别名 // C++对于const属性要求更为严格 // 1.用常引用 const int&amp; xx = 13; cout &lt;&lt; xx &lt;&lt; endl; //char* pStr = &quot;ILoveyou&quot;; //error const char* pstr = &quot;ILoveyou&quot;; printString(&quot;ILoveyou&quot;); char array[10] = &quot;LLLL&quot;; printString(array); //常引用不能修改 // 2.右值引用 &amp;&amp; ---&gt;提供修改接口 int&amp;&amp; yy = 134; yy = 55; const int c_num = 112; //常属性的变量，依旧是左值 // int&amp;&amp; zz = c_num; //错误 modifyNum(1); modifyNum2(23); //左值变成右值 int data = 1001; int&amp;&amp; data2 = move(data); //移动函数：把左值变成右值 int value = 1234; // modifyNum2(value); // //错误，用右值引用当做函数参数，不能传左值 modifyNum2(move(value)); //移动语义(完美转发) &#125; int main(int argc, char** argv) &#123; testNew(); return 0; &#125; C++结构体类型 类型名不在需要struct关键字了 C++结构体可以给成员直接赋初始值 C++结构体可以包含函数 其实C++结构体的处理就是按照类的方式处理（后续在意） 用了构造函数时候C++结构体和C语言结构体处理方案是完全不同的 #include &lt;iostream&gt; using namespace std; //描述的是事物特征和行为 struct MM &#123; char name[20] = &quot;MM&quot;; int age = 111; int num = 1001; void initData(const char* str, int age, int num); //在结构体声明 void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; &#125;; //在外面实现，必须结构体名限定 void MM::initData(const char* str, int age, int num) &#123; strcpy_s(name, 20, str); //同名问题 MM::age = age; MM::num = num; &#125; int main(int argc, char** argv) &#123; // No.1 类型不需要struct MM mm; // cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; mm.printData(); MM mm2 = &#123;&quot;mm2&quot;, 18, 1030&#125;; // cout &lt;&lt; mm2.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm2.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm2.num &lt;&lt; endl; mm2.printData(); mm2.initData(&quot;小芳&quot;, 18, 1004); mm2.printData(); return 0; &#125; C++枚举类型#include &lt;iostream&gt; using namespace std; enum State &#123; Open, Close &#125;; enum class Color &#123; Red, Blue &#125;; void print(int state) &#123; cout &lt;&lt; state &lt;&lt; endl; &#125; void printEnum(Color color) &#123; // cout &lt;&lt; color &lt;&lt; endl; 不能直接打印 &#125; void testEnum() &#123; print(1); print(Open); // C++的枚举类型不能当做一个简单的int类型 // print(Color::Red); //访问必须要用枚举类型名限定 printEnum(Color::Red); &#125; int main(int argc, char** argv) &#123; testEnum() return 0; &#125; C++string类型C++string本身是一个类，所以大家本节课只要学会使用即可，不需要问问什么 头文件： #include 注意点和cstring区别，这个是C语言头文件 没有用using namespace std ; string类型需要改为std::string 掌握string常用方式 创建方式 基本操作(比较,连接) 转C语言char* 微软帮助文档:basic_string 类 | Microsoft Docs #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; // std::string str; // No.1创建 string str1; str1 = &quot;ILoveyoudsfasdfasdfasdfasdfasd&quot;; cout &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;ILoveyousdfsdafads&quot;; cout &lt;&lt; str2 &lt;&lt; endl; string str3(str2); string str4 = str2; cout &lt;&lt; str3 &lt;&lt; endl; cout &lt;&lt; str4 &lt;&lt; endl; // No.2 基本操作 cout &lt;&lt; (str3 == str4) &lt;&lt; endl; cout &lt;&lt; (str3 &gt;= str4) &lt;&lt; endl; string password; cin &gt;&gt; password; cout &lt;&lt; password; //原理是：运算符重载 后面会讲 //比较直接比 if (password == string(&quot;12345&quot;)) &#123; cout &lt;&lt; endl &lt;&lt; &quot;密码正确&quot; &lt;&lt; endl; &#125; int a = (int)1.3; // C语言强制类型转换 int b = int(1.34); // C++强制类型转换 //连接直接加法 string name = &quot;张三&quot;; string info = name + &quot;很帅&quot;; cout &lt;&lt; info &lt;&lt; endl; //上述复杂的用法 cout &lt;&lt; info.compare(name) &lt;&lt; endl; //和strcmp 返回值一样 cout &lt;&lt; info.append(name) &lt;&lt; endl; //下标的方式访问 cout &lt;&lt; info.length() &lt;&lt; endl; //当前长度 cout &lt;&lt; info.size() &lt;&lt; endl; for (int i = 0; i &lt; info.length(); i++) &#123; cout &lt;&lt; info[i]; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; info.length(); i++) &#123; cout &lt;&lt; info.at(i); &#125; cout &lt;&lt; endl; cout &lt;&lt; info.capacity() &lt;&lt; endl; //容量 //和C语言string.h有区别的 char* // 不能用%s的方式打印 // printf(&quot;%s\\n&quot;, info); // 图形库中传char* 函数 都不能直接用string类型 //提供两个函数： c_str() data(); printf(&quot;%s\\n&quot;, info.c_str()); printf(&quot;%s\\n&quot;, info.data()); return 0; &#125; C++自动推断类型 auto类型 decltype类型 #include &lt;iostream&gt; using namespace std; struct MM &#123; int age; &#125;; MM g_MM = &#123;12&#125;; MM* createMM() &#123; MM* p = &amp;g_MM; return p; &#125; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; void print(int (*Max)(int, int), int a, int b) &#123; cout &lt;&lt; Max(a, b) &lt;&lt; endl; &#125; void printData(int (*)(int, int), int, int) &#123; cout &lt;&lt; &quot;另一个函数&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // auto 类型自动推断: 一定要有赋值 所以不能单独定义变量 // auto a; 没有赋值 推断不出来 auto a = 1; // int a = 134; auto pMM = createMM(); cout &lt;&lt; pMM-&gt;age &lt;&lt; endl; auto pFunc = print; // void (*)(int(*)(int, int), int , int ) pFunc(Max, 1, 3); pFunc = printData; pFunc(Max, 1, 3); int* p = nullptr; //新的空 等效C语言NULL // decltype 不需要赋值 decltype(123) num = 123; // decltype(123) 表示一个int类型 //函数指针必须取地址 decltype(&amp;print) ppFunc; ppFunc = printData; //推断一个int decltype(num) Num = num; decltype(&amp;num) pNum = &amp;num; //当你们用的时候，不知道类型，推断定义变量去赋值 return 0; &#125; C++动态内存申请C++申请的内存是自由存储区的，C语言的堆区内存，所以C++类的对象内存不能用malloc申请 &#x2F;&#x2F; IMAGE * new申请内存 申请单个变量内存 申请一段内存 申请内存可以手动初始化 申请内存后可以再分配 delete释放内存 释放单个变量内存：delete 指针名; 释放一段变量内存： delete[] 指针名; #include &lt;iostream&gt; using namespace std; struct MM &#123; char name[20]; int age; int num; &#125;; void testOne() &#123; int* pInt = new int; *pInt = 123; cout &lt;&lt; pInt[0] &lt;&lt; endl; delete pInt; pInt = nullptr; char* pc = new char; delete pc; int* pNum = new int(1234); //申请并且初始化 cout &lt;&lt; pNum[0] &lt;&lt; endl; delete pNum; MM* pMM = new MM(&#123;&quot;name&quot;, 12, 1101&#125;); cout &lt;&lt; pMM-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;age &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;num &lt;&lt; endl; &#125; void testTwo() &#123; //一段内存的申请 int size = 4; int* pArray = new int[size]; // int pArray[4]; MM* pMM = new MM[4]; // MM pMM[4]; delete[] pArray; delete[] pMM; pArray = nullptr; pMM = nullptr; int* pNum = new int[4]&#123;1, 2, 3, 4&#125;; for (int i = 0; i &lt; 4; i++) &#123; cout &lt;&lt; pNum[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; delete[] pNum; pNum = nullptr; &#125; void testThree() &#123; char* pMem = new char[1024]; //在原来上面拿个20字节存整数 int* pInt = new (pMem + 0) int[5]&#123;1, 2, 3, 4, 5&#125;; //在原来上面拿出20个存字符 char* pChar = new (pMem + 20) char[20]&#123;&quot;ILoveyou&quot;&#125;; //等效：char* pChar = new(pInt + 5) char[20]&#123;&quot;ILoveyou&quot;&#125;; delete[] pMem; pMem = nullptr; &#125; int main(int argc, char** argv) &#123; testOne(); testTwo(); testThree(); return 0; &#125; 小试牛刀#include &lt;iostream&gt; using namespace std; int** create2DArray(int row, int cols) &#123; int** pArray = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; pArray[i] = new int[cols]; &#125; return pArray; &#125; void create2DArray(int**&amp; pArray, int row, int cols) &#123; pArray = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; pArray[i] = new int[cols]; &#125; &#125; void Free(int**&amp; array, int row) &#123; for (int i = 0; i &lt; row; i++) &#123; delete[] array[i]; &#125; delete[] array; array = nullptr; &#125; int main(int argc, char** argv) &#123; int** p2D = nullptr; int cols, rows; //让用户输入行列 cin &gt;&gt; rows &gt;&gt; cols; // create2DArray(p2D, rows, cols); p2D = create2DArray(rows, cols); //让用户赋值 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; cin &gt;&gt; p2D[i][j]; &#125; &#125; //打印结果 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; cout &lt;&lt; p2D[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //释放 Free(p2D, rows); &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"计组-计算机硬件基础","slug":"计组-计算机硬件基础","date":"2022-05-10T02:30:46.000Z","updated":"2022-10-20T15:00:31.904Z","comments":true,"path":"2022/05/10/计组-计算机硬件基础/","link":"","permalink":"http://goskp.github.io/2022/05/10/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"参考视频: 计算机硬件基础 机箱 够不够大. 主板能不能放下 散热 外观 主板 接口,型号,品牌… 可以理解为电路板 CPU:中央处理器 整个机箱里最重要的就是CPU,就是大脑 用于电脑下命令的 CPU如果卡了,其他的部件性能再好也没用 CPU厂商 IntelCPU实战分析Intel中国官网请点击此蓝色字体Intel 代表的处理器型号: 赛扬,奔腾 酷睿 core四类,分等级 :i3 i5 i7 i9 从*大体来看,越来越好*,注意是同代相比,不能拿今年的i5和几年前的i7相比 i3 针对的是轻量化办公, (打字,文稿,处理文档,客户沟通等等) i5 处理简单视频, 程序, 简答项目,游戏 i7 发烧, 大型游戏, 大型工程, 专业用户… i9 最屌 ,顶级性能 解读:Intel 第12代酷睿 i9-12900K台式机CPU处理器 16核24线程 单核睿频至高可达5.2Ghz 30M三级缓存 i9-12900K i9就不解释了,就代表酷睿的这一系列产品 12900K: (12就是代号) 读作:i9第十二代 如i9-9900K , 9900K中的第一个9是代号 读作:i9第九代 具体代号指是哪一年的产品 ,去官网搜索就可以了 后面的900K 在900K中,第一个9代表的是性能 数字排名[0-9] 举个例子, i9-12900K 和 i9-12700K ,那显然是i9-12900K性能好了(9&gt;7嘛) 但如果是i3-9500 i5-2700 ,这样就不好比较了, 可以google搜索,找一下测评视频,这两款cpu跑分怎么样 中间的两个0 不用管,没有什么特别的意义,注意台式机大部分是00 末尾的字母:K? KF? G1? G7? 产品后缀,同代相比G7是一定比G1好的 F,Intel全新推出的后缀,代表无内置核心显卡版本,显然买带F的需要自己配显卡 G,Y,主打续航,不是性能 U 稍微有点续航, 办公 H 焊接,不可拆卸,打游戏的 大多数台式是不带字母的, 如果带基本都是K,超频(满功率运行) 后缀比较多, 这里没有介绍的搜索就可以 英特尔® 处理器名称和编号请点击此蓝色字体 CPU厂商 AMDCPU实战分析AMD中国官网请点击此蓝色字体 AMD 于 2016&#x2F;8&#x2F;17 推出 Zen 架构，但直到 2017&#x2F;3 才发布第一款 Zen 架构处理器。现在已经进化到第四代，分别是 Zen、Zen+、Zen2、Zen3。 14nm Zen：2017&#x2F;3 12nm Zen+：2018&#x2F;4 7nm Zen2：2019&#x2F;7 7nm Zen3：2020&#x2F;11 在解释 AMD 命名规则前，先看看一些 AMD 处理器型号 Ryzen Threadripper 1950X Ryzen 7 2700X Ryzen 5 3600XT Ryzen 7 4700G …. 命名规则 AMD Ryzen 5 3600X AMD: Company Name Ryzen: Brand Name 5: CPU Family 3: CPU Generation 6: CPU Performance Level 00: Model Number Or SKU Number X: Power Suffix 型号的第一个数字 这里说的型号，是指由 4 个数字和字母后缀组成的那段字符，例如“5900X”。AMD 官方通常根据型号的第一个数字，把处理器称为 xxxx 系列，例如 5700U 是 5000 系列移动处理器，5900X 是 5000 系列桌面处理器。 Ryzen 后的数字 Ryzen 后面的系列，主要有 3、5、7、9、Threadripper。除了有 Ryzen，还有 Ryzen pro、Ryzen Threadripper Pro，它们主要面向商业用途，而不是大众消费者。 同一个系列下，Ryzen 后面的第一个数字越大，性能通常越强，最强的是 Threadripper(线程撕裂者)。如果系列不同，则不一定。 比如 Ryzen 7 5800X 的性能比 Ryzen 9 3900XT 强，虽然前者是 Ryzen 7，后者是 Ryzen 9，似乎 9 强于 7，但前者是 5000 系列，后者是 3000 系列。不同的系列代表不同的架构，前者是 Zen3 架构，后者是 Zen2 架构。 CPU性能天梯图请点击此蓝色字体 总结:比较两款处理器的性能，首先看型号的第一个数字，即先看系列(架构)，系列(架构)相同，则看 代号后的数字，数字越大性能通常越强。如果系列不同，则需要考虑更多因素。16核24线程 可以理解为16个脑子,24个脑仁, 肯定是越多越好 单核 主频 睿频 主频:智商.平常工作时的节奏 睿频:智商爆表, 比如玩游戏时的节奏,集中注意力的运行这个东西 30M三级缓存 就相当于是库存,能存多块,同样是越高越好 如何查看电脑CPU详细信息 CPU-Z下载地址请点击此蓝色字体 内存(RAM 运行内存) 意味着最大能开多少的空间 每个正在运行的软件都会占用内存空间 也就是说此电脑后台和前台能同时运行多少APP 现在是2022年8月, 就电脑来讲大部分都是16G运行内存了,属于是最低标准 内存频率的用途DDR4 3200 代号 DDR1 DDR2 DDR3 3200 当然也是越高越好… 但是需要注意的是, 频率越高,需要的主板应当越好 电源(主要针对台式机) 好的CPU,好的显卡,功率可能会更大 功率如果不够,硬件可能出现带不动的情况,导致不能发挥顶级的性能 硬盘注意:硬盘和内存是不一样的 内存 :吃完了扔了,扔完再放(完全是临时的东西) 一旦关机,临时的东西全部释放, 内存条 保存的是开机时运行的APP和数据 硬盘(存储永久数据的) 机械硬盘(不推荐个人用户买机械硬盘) 最古老的硬盘 现在是2022年8月,机械硬盘并不流行 举个例子: 2TB 256MB 7200PRM SATA接口 2TB : 2000G, 256MB: 缓存 7200RPM: 转 硬盘的转速,越大越好 SATA接口: 详见文章开篇电路板图片 固态硬盘(部分可支持台式,笔记本互联) SATA接口 为了兼容旧电脑 MiniSATA PCI-E U.2 M.2 读写速度,缓存速度 机械银盘读写速度都 &lt;&#x3D; 110MB&#x2F;S 固态硬盘读写速度 SATA接口 &lt;&#x3D; 550 MB&#x2F;s MiniSATA接口,老式笔记本电脑使用,即将被淘汰 PCI-E占用了一个显卡的接口位置 读6000M&#x2F;s 写 4000M&#x2F;s(不推荐),注意查看主板是否支持 U.2 即将被淘汰 M.2(21世纪20年代的主流硬盘, 遵循NVME协议) 读写速度没有看到具体上限 显卡(图形显示处理器,3D,动画渲染的能力)AMD NVIDIA IntelArc(新潮流) NVIDIA(玩游戏推荐) GeForce900 GTX980 GeForce10 GTX1050TI GeForce16 GeForce RTX 20系列 RTX2060(RTX采用了光线追中技术,游戏里的光反射,画面更加好) GeForce RTX 30系列 RTX2080 RTX3090 同代相比Ti比super好,super比什么都不带的好 显存 能丢多少图形渲染到显卡里(3A大作) 显卡分类 集成显卡(核显): 买CPU送显卡 作用就是链接显示器(屏幕): 显示内容 ,玩游戏不行 独立显卡 注意: Intel CPU后缀是F的都不带显卡 如何查看自己电脑显卡 GPU-Z下载地址请点击此蓝色字体 桌面显卡性能天梯图请点击此蓝色字体 显示器 分辨率越高,画面显示越好,显卡负载越大 1080p 3060 2k 3060 4k 3080TI 3090 屏幕刷新率 144hz 感谢Frank","categories":[{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://goskp.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"},{"name":"数据库","slug":"数据库","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","permalink":"http://goskp.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://goskp.github.io/tags/Algorithm/"},{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"},{"name":"MySQL","slug":"MySQL","permalink":"http://goskp.github.io/tags/MySQL/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://goskp.github.io/tags/DesignPattern/"},{"name":"Rust","slug":"Rust","permalink":"http://goskp.github.io/tags/Rust/"},{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"},{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}]}